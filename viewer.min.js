/*! For license information please see viewer.min.js.LICENSE.txt */
( () => {
  "use strict";
  var t, e;
  window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t, e) {
      window.setTimeout(t, 1e3 / 60)
  }
  ,
  jQuery.support.cors = !0,
  $.ajaxTransport ? ($.ajaxSetup({
      flatOptions: {
          renderer: !0
      }
  }),
  $.ajaxTransport("+binary", (function(t, e, i) {
      if (window.FormData && (t.dataType && "binary" == t.dataType || t.data && (window.ArrayBuffer && t.data instanceof ArrayBuffer || window.Blob && t.data instanceof Blob)))
          return {
              send: function(e, i) {
                  var s = new XMLHttpRequest
                    , r = t.url
                    , n = t.type
                    , a = t.responseType || "blob"
                    , o = t.data || null;
                  t.renderer && s.addEventListener("progress", (function(e) {
                      e.lengthComputable && (t.renderer.downloads[this.responseURL] ? t.renderer.downloads[this.responseURL].loaded = e.loaded : t.renderer.downloads[this.responseURL] = {
                          loaded: e.loaded,
                          total: e.total
                      },
                      t.renderer.updateProgress())
                  }
                  )),
                  s.addEventListener("load", (function() {
                      t.renderer && (delete t.renderer.downloads[this.responseURL],
                      t.renderer.updateProgress());
                      var e = {};
                      e[t.dataType] = s.response,
                      i(s.status, s.statusText, e, s.getAllResponseHeaders())
                  }
                  )),
                  s.open(n, r, !0),
                  s.responseType = a,
                  s.send(o)
              },
              abort: function() {
                  i.abort()
              }
          }
  }
  ))) : (t = $.httpData,
  $.httpData = function(e, i, s) {
      return "binary" == i ? e.response : t(e, i, s)
  }
  ,
  $.ajaxSetup({
      beforeSend: function(t, e) {
          "binary" == e.dataType && (t.responseType = e.responseType || "arraybuffer",
          t.addEventListener("progress", (function(t) {
              e.renderer && t.lengthComputable && (e.renderer.downloads[this.responseURL] ? e.renderer.downloads[this.responseURL].loaded = t.loaded : e.renderer.downloads[this.responseURL] = {
                  loaded: t.loaded,
                  total: t.total
              },
              e.renderer.updateProgress())
          }
          ), !1),
          t.addEventListener("load", (function() {
              e.renderer && (delete e.renderer.downloads[this.responseURL],
              e.renderer.updateProgress())
          }
          ), !1))
      }
  })),
  Math.randomInt = Math.randomInt || function(t, e) {
      return Math.floor(Math.random() * (e - t)) + t
  }
  ,
  "function" != typeof Object.create && (Object.create = (e = function() {}
  ,
  function(t) {
      if (arguments.length > 1)
          throw Error("Second argument not supported");
      if ("object" != typeof t)
          throw TypeError("Argument must be an object");
      e.prototype = t;
      var i = new e;
      return e.prototype = null,
      i
  }
  )),
  window.console = window.console || {
      log: function() {},
      error: function() {},
      warn: function() {}
  };
  let i = Float32Array;
  function s(t, e, s) {
      const r = new i(3);
      return t && (r[0] = t),
      e && (r[1] = e),
      s && (r[2] = s),
      r
  }
  function r(t, e, s) {
      return (s = s || new i(3))[0] = t[0] + e[0],
      s[1] = t[1] + e[1],
      s[2] = t[2] + e[2],
      s
  }
  function n(t, e, s) {
      return (s = s || new i(3))[0] = t[0] * e[0],
      s[1] = t[1] * e[1],
      s[2] = t[2] * e[2],
      s
  }
  let a = Float32Array;
  function o(t) {
      return (t = t || new a(16))[0] = 1,
      t[1] = 0,
      t[2] = 0,
      t[3] = 0,
      t[4] = 0,
      t[5] = 1,
      t[6] = 0,
      t[7] = 0,
      t[8] = 0,
      t[9] = 0,
      t[10] = 1,
      t[11] = 0,
      t[12] = 0,
      t[13] = 0,
      t[14] = 0,
      t[15] = 1,
      t
  }
  function h(t, e) {
      e = e || new a(16);
      const i = t[0]
        , s = t[1]
        , r = t[2]
        , n = t[3]
        , o = t[4]
        , h = t[5]
        , l = t[6]
        , u = t[7]
        , c = t[8]
        , d = t[9]
        , f = t[10]
        , g = t[11]
        , b = t[12]
        , _ = t[13]
        , p = t[14]
        , m = t[15]
        , v = f * m
        , x = p * g
        , T = l * m
        , w = p * u
        , y = l * g
        , A = f * u
        , E = r * m
        , C = p * n
        , M = r * g
        , k = f * n
        , F = r * u
        , S = l * n
        , D = c * _
        , I = b * d
        , R = o * _
        , U = b * h
        , O = o * d
        , P = c * h
        , B = i * _
        , z = b * s
        , N = i * d
        , G = c * s
        , j = i * h
        , L = o * s
        , H = v * h + w * d + y * _ - (x * h + T * d + A * _)
        , V = x * s + E * d + k * _ - (v * s + C * d + M * _)
        , q = T * s + C * h + F * _ - (w * s + E * h + S * _)
        , X = A * s + M * h + S * d - (y * s + k * h + F * d)
        , W = 1 / (i * H + o * V + c * q + b * X);
      return e[0] = W * H,
      e[1] = W * V,
      e[2] = W * q,
      e[3] = W * X,
      e[4] = W * (x * o + T * c + A * b - (v * o + w * c + y * b)),
      e[5] = W * (v * i + C * c + M * b - (x * i + E * c + k * b)),
      e[6] = W * (w * i + E * o + S * b - (T * i + C * o + F * b)),
      e[7] = W * (y * i + k * o + F * c - (A * i + M * o + S * c)),
      e[8] = W * (D * u + U * g + O * m - (I * u + R * g + P * m)),
      e[9] = W * (I * n + B * g + G * m - (D * n + z * g + N * m)),
      e[10] = W * (R * n + z * u + j * m - (U * n + B * u + L * m)),
      e[11] = W * (P * n + N * u + L * g - (O * n + G * u + j * g)),
      e[12] = W * (R * f + P * p + I * l - (O * p + D * l + U * f)),
      e[13] = W * (N * p + D * r + z * f - (B * f + G * p + I * r)),
      e[14] = W * (B * l + L * p + U * r - (j * p + R * r + z * l)),
      e[15] = W * (j * f + O * r + G * l - (N * l + L * f + P * r)),
      e
  }
  function l(t, e, i) {
      i = i || s();
      const r = e[0]
        , n = e[1]
        , a = e[2]
        , o = r * t[3] + n * t[7] + a * t[11] + t[15];
      return i[0] = (r * t[0] + n * t[4] + a * t[8] + t[12]) / o,
      i[1] = (r * t[1] + n * t[5] + a * t[9] + t[13]) / o,
      i[2] = (r * t[2] + n * t[6] + a * t[10] + t[14]) / o,
      i
  }
  function u(t, e, i) {
      i = i || s();
      const r = e[0]
        , n = e[1]
        , a = e[2];
      return i[0] = r * t[0] + n * t[4] + a * t[8],
      i[1] = r * t[1] + n * t[5] + a * t[9],
      i[2] = r * t[2] + n * t[6] + a * t[10],
      i
  }
  const c = 5120
    , d = 5121
    , f = 5122
    , g = 5123
    , b = 5124
    , _ = 5125
    , p = 5126
    , m = {};
  {
      const t = m;
      t[c] = Int8Array,
      t[d] = Uint8Array,
      t[f] = Int16Array,
      t[g] = Uint16Array,
      t[b] = Int32Array,
      t[_] = Uint32Array,
      t[p] = Float32Array,
      t[32819] = Uint16Array,
      t[32820] = Uint16Array,
      t[33635] = Uint16Array,
      t[5131] = Uint16Array,
      t[33640] = Uint32Array,
      t[35899] = Uint32Array,
      t[35902] = Uint32Array,
      t[36269] = Uint32Array,
      t[34042] = Uint32Array
  }
  function v(t) {
      if (t instanceof Int8Array)
          return c;
      if (t instanceof Uint8Array)
          return d;
      if (t instanceof Uint8ClampedArray)
          return d;
      if (t instanceof Int16Array)
          return f;
      if (t instanceof Uint16Array)
          return g;
      if (t instanceof Int32Array)
          return b;
      if (t instanceof Uint32Array)
          return _;
      if (t instanceof Float32Array)
          return p;
      throw new Error("unsupported typed array type")
  }
  function x(t) {
      if (t === Int8Array)
          return c;
      if (t === Uint8Array)
          return d;
      if (t === Uint8ClampedArray)
          return d;
      if (t === Int16Array)
          return f;
      if (t === Uint16Array)
          return g;
      if (t === Int32Array)
          return b;
      if (t === Uint32Array)
          return _;
      if (t === Float32Array)
          return p;
      throw new Error("unsupported typed array type")
  }
  function T(t) {
      const e = m[t];
      if (!e)
          throw new Error("unknown gl type");
      return e
  }
  const w = "undefined" != typeof SharedArrayBuffer ? function(t) {
      return t && t.buffer && (t.buffer instanceof ArrayBuffer || t.buffer instanceof SharedArrayBuffer)
  }
  : function(t) {
      return t && t.buffer && t.buffer instanceof ArrayBuffer
  }
  ;
  function y(...t) {
      console.error(...t)
  }
  const A = new Map;
  function E(t, e) {
      if (!t || "object" != typeof t)
          return !1;
      let i = A.get(e);
      i || (i = new WeakMap,
      A.set(e, i));
      let s = i.get(t);
      if (void 0 === s) {
          const r = Object.prototype.toString.call(t);
          s = r.substring(8, r.length - 1) === e,
          i.set(t, s)
      }
      return s
  }
  function C(t, e) {
      return "undefined" != typeof WebGLTexture && E(e, "WebGLTexture")
  }
  const M = 35044
    , k = 34962
    , F = 34963
    , S = 34660
    , D = 5120
    , I = 5121
    , R = 5122
    , U = 5123
    , O = 5124
    , P = 5125
    , B = 5126
    , z = {
      attribPrefix: ""
  };
  function N(t, e, i, s, r) {
      t.bindBuffer(e, i),
      t.bufferData(e, s, r || M)
  }
  function G(t, e, i, s) {
      if (r = e,
      "undefined" != typeof WebGLBuffer && E(r, "WebGLBuffer"))
          return e;
      var r;
      i = i || k;
      const n = t.createBuffer();
      return N(t, i, n, e, s),
      n
  }
  function j(t) {
      return "indices" === t
  }
  function L(t) {
      return t.length ? t : t.data
  }
  const H = /coord|texture/i
    , V = /color|colour/i;
  function q(t, e, i) {
      return t.numComponents || t.size || function(t, e) {
          let i;
          if (i = H.test(t) ? 2 : V.test(t) ? 4 : 3,
          e % i > 0)
              throw new Error(`Can not guess numComponents for attribute '${t}'. Tried ${i} but ${e} values is not evenly divisible by ${i}. You should specify it.`);
          return i
      }(e, i || L(t).length)
  }
  function X(t, e) {
      if (w(t))
          return t;
      if (w(t.data))
          return t.data;
      Array.isArray(t) && (t = {
          data: t
      });
      let i = t.type ? W(t.type) : void 0;
      return i || (i = j(e) ? Uint16Array : Float32Array),
      new i(t.data)
  }
  function W(t) {
      return "number" == typeof t ? T(t) : t || Float32Array
  }
  function Z(t, e) {
      return {
          buffer: e.buffer,
          numValues: 24,
          type: (i = e.type,
          "number" == typeof i ? i : i ? x(i) : B),
          arrayType: W(e.type)
      };
      var i
  }
  function K(t, e) {
      const i = e.data || e
        , s = W(e.type)
        , r = i * s.BYTES_PER_ELEMENT
        , n = t.createBuffer();
      return t.bindBuffer(k, n),
      t.bufferData(k, r, e.drawType || M),
      {
          buffer: n,
          numValues: i,
          type: x(s),
          arrayType: s
      }
  }
  function Y(t, e, i) {
      const s = X(e, i);
      return {
          arrayType: s.constructor,
          buffer: G(t, s, void 0, e.drawType),
          type: v(s),
          numValues: 0
      }
  }
  function J(t, e) {
      const i = {};
      return Object.keys(e).forEach((function(s) {
          if (!j(s)) {
              const n = e[s]
                , a = n.attrib || n.name || n.attribName || z.attribPrefix + s;
              if (n.value) {
                  if (!Array.isArray(n.value) && !w(n.value))
                      throw new Error("array.value is not array or typedarray");
                  i[a] = {
                      value: n.value
                  }
              } else {
                  let e;
                  e = n.buffer && n.buffer instanceof WebGLBuffer ? Z : "number" == typeof n || "number" == typeof n.data ? K : Y;
                  const {buffer: o, type: h, numValues: l, arrayType: u} = e(t, n, s)
                    , c = void 0 !== n.normalize ? n.normalize : (r = u) === Int8Array || r === Uint8Array
                    , d = q(n, s, l);
                  i[a] = {
                      buffer: o,
                      numComponents: d,
                      type: h,
                      normalize: c,
                      stride: n.stride || 0,
                      offset: n.offset || 0,
                      divisor: void 0 === n.divisor ? void 0 : n.divisor,
                      drawType: n.drawType
                  }
              }
          }
          var r
      }
      )),
      t.bindBuffer(k, null),
      i
  }
  const Q = ["position", "positions", "a_position"];
  function tt(t, e) {
      let i, s;
      for (s = 0; s < Q.length && (i = Q[s],
      !(i in e)) && (i = z.attribPrefix + i,
      !(i in e)); ++s)
          ;
      s === Q.length && (i = Object.keys(e)[0]);
      const r = e[i];
      if (!r.buffer)
          return 1;
      t.bindBuffer(k, r.buffer);
      const n = t.getBufferParameter(k, S);
      t.bindBuffer(k, null);
      var a;
      const o = n / ((a = r.type) === D || a === I ? 1 : a === R || a === U ? 2 : a === O || a === P || a === B ? 4 : 0)
        , h = r.numComponents || r.size
        , l = o / h;
      if (l % 1 != 0)
          throw new Error(`numComponents ${h} not correct for length ${length}`);
      return l
  }
  function et(t, e, i) {
      const s = J(t, e)
        , r = Object.assign({}, i || {});
      r.attribs = Object.assign({}, i ? i.attribs : {}, s);
      const n = e.indices;
      if (n) {
          const e = X(n, "indices");
          r.indices = G(t, e, F),
          r.numElements = e.length,
          r.elementType = v(e)
      } else
          r.numElements || (r.numElements = tt(t, r.attribs));
      return r
  }
  function it(t, e, i) {
      const s = "indices" === i ? F : k;
      return G(t, X(e, i), s)
  }
  function st(t, e) {
      const i = {};
      return Object.keys(e).forEach((function(s) {
          i[s] = it(t, e[s], s)
      }
      )),
      e.indices ? (i.numElements = e.indices.length,
      i.elementType = v(X(e.indices))) : i.numElements = function(t) {
          let e, i;
          for (i = 0; i < Q.length && (e = Q[i],
          !(e in t)); ++i)
              ;
          i === Q.length && (e = Object.keys(t)[0]);
          const s = t[e]
            , r = L(s).length;
          if (void 0 === r)
              return 1;
          const n = q(s, e)
            , a = r / n;
          if (r % n > 0)
              throw new Error(`numComponents ${n} not correct for length ${r}`);
          return a
      }(e),
      i
  }
  function rt(t, e) {
      let i = 0;
      return t.push = function() {
          for (let e = 0; e < arguments.length; ++e) {
              const s = arguments[e];
              if (s instanceof Array || w(s))
                  for (let e = 0; e < s.length; ++e)
                      t[i++] = s[e];
              else
                  t[i++] = s
          }
      }
      ,
      t.reset = function(t) {
          i = t || 0
      }
      ,
      t.numComponents = e,
      Object.defineProperty(t, "numElements", {
          get: function() {
              return this.length / this.numComponents | 0
          }
      }),
      t
  }
  function nt(t, e, i) {
      return rt(new (i || Float32Array)(t * e), t)
  }
  function at(t, e, i) {
      const s = t.length
        , r = new Float32Array(3);
      for (let n = 0; n < s; n += 3)
          i(e, [t[n], t[n + 1], t[n + 2]], r),
          t[n] = r[0],
          t[n + 1] = r[1],
          t[n + 2] = r[2]
  }
  function ot(t, e, i) {
      i = i || s();
      const r = e[0]
        , n = e[1]
        , a = e[2];
      return i[0] = r * t[0] + n * t[1] + a * t[2],
      i[1] = r * t[4] + n * t[5] + a * t[6],
      i[2] = r * t[8] + n * t[9] + a * t[10],
      i
  }
  function ht(t, e) {
      return at(t, e, u),
      t
  }
  function lt(t, e) {
      return at(t, h(e), ot),
      t
  }
  function ut(t, e) {
      return at(t, e, l),
      t
  }
  function ct(t, e) {
      return Object.keys(t).forEach((function(i) {
          const s = t[i];
          i.indexOf("pos") >= 0 ? ut(s, e) : i.indexOf("tan") >= 0 || i.indexOf("binorm") >= 0 ? ht(s, e) : i.indexOf("norm") >= 0 && lt(s, e)
      }
      )),
      t
  }
  function dt(t, e, i) {
      return t = t || 2,
      {
          position: {
              numComponents: 2,
              data: [(e = e || 0) + -1 * (t *= .5), (i = i || 0) + -1 * t, e + 1 * t, i + -1 * t, e + -1 * t, i + 1 * t, e + 1 * t, i + 1 * t]
          },
          normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
          texcoord: [0, 0, 1, 0, 0, 1, 1, 1],
          indices: [0, 1, 2, 2, 1, 3]
      }
  }
  function ft(t, e, i, s, r) {
      t = t || 1,
      e = e || 1,
      i = i || 1,
      s = s || 1,
      r = r || o();
      const n = (i + 1) * (s + 1)
        , a = nt(3, n)
        , h = nt(3, n)
        , l = nt(2, n);
      for (let r = 0; r <= s; r++)
          for (let n = 0; n <= i; n++) {
              const o = n / i
                , u = r / s;
              a.push(t * o - .5 * t, 0, e * u - .5 * e),
              h.push(0, 1, 0),
              l.push(o, u)
          }
      const u = i + 1
        , c = nt(3, i * s * 2, Uint16Array);
      for (let t = 0; t < s; t++)
          for (let e = 0; e < i; e++)
              c.push((t + 0) * u + e, (t + 1) * u + e, (t + 0) * u + e + 1),
              c.push((t + 1) * u + e, (t + 1) * u + e + 1, (t + 0) * u + e + 1);
      return ct({
          position: a,
          normal: h,
          texcoord: l,
          indices: c
      }, r)
  }
  function gt(t, e, i, s, r, n, a) {
      if (e <= 0 || i <= 0)
          throw new Error("subdivisionAxis and subdivisionHeight must be > 0");
      s = s || 0,
      n = n || 0;
      const o = (r = r || Math.PI) - s
        , h = (a = a || 2 * Math.PI) - n
        , l = (e + 1) * (i + 1)
        , u = nt(3, l)
        , c = nt(3, l)
        , d = nt(2, l);
      for (let r = 0; r <= i; r++)
          for (let a = 0; a <= e; a++) {
              const l = a / e
                , f = r / i
                , g = h * l + n
                , b = o * f + s
                , _ = Math.sin(g)
                , p = Math.cos(g)
                , m = Math.sin(b)
                , v = p * m
                , x = Math.cos(b)
                , T = _ * m;
              u.push(t * v, t * x, t * T),
              c.push(v, x, T),
              d.push(1 - l, f)
          }
      const f = e + 1
        , g = nt(3, e * i * 2, Uint16Array);
      for (let t = 0; t < e; t++)
          for (let e = 0; e < i; e++)
              g.push((e + 0) * f + t, (e + 0) * f + t + 1, (e + 1) * f + t),
              g.push((e + 1) * f + t, (e + 0) * f + t + 1, (e + 1) * f + t + 1);
      return {
          position: u,
          normal: c,
          texcoord: d,
          indices: g
      }
  }
  const bt = [[3, 7, 5, 1], [6, 2, 0, 4], [6, 7, 3, 2], [0, 1, 5, 4], [7, 6, 4, 5], [2, 3, 1, 0]];
  function _t(t) {
      const e = (t = t || 1) / 2
        , i = [[-e, -e, -e], [+e, -e, -e], [-e, +e, -e], [+e, +e, -e], [-e, -e, +e], [+e, -e, +e], [-e, +e, +e], [+e, +e, +e]]
        , s = [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]]
        , r = [[1, 0], [0, 0], [0, 1], [1, 1]]
        , n = nt(3, 24)
        , a = nt(3, 24)
        , o = nt(2, 24)
        , h = nt(3, 12, Uint16Array);
      for (let t = 0; t < 6; ++t) {
          const e = bt[t];
          for (let h = 0; h < 4; ++h) {
              const l = i[e[h]]
                , u = s[t]
                , c = r[h];
              n.push(l),
              a.push(u),
              o.push(c)
          }
          const l = 4 * t;
          h.push(l + 0, l + 1, l + 2),
          h.push(l + 0, l + 2, l + 3)
      }
      return {
          position: n,
          normal: a,
          texcoord: o,
          indices: h
      }
  }
  function pt(t, e, i, s, r, n, a) {
      if (s < 3)
          throw new Error("radialSubdivisions must be 3 or greater");
      if (r < 1)
          throw new Error("verticalSubdivisions must be 1 or greater");
      const o = void 0 === n || n
        , h = void 0 === a || a
        , l = (o ? 2 : 0) + (h ? 2 : 0)
        , u = (s + 1) * (r + 1 + l)
        , c = nt(3, u)
        , d = nt(3, u)
        , f = nt(2, u)
        , g = nt(3, s * (r + l / 2) * 2, Uint16Array)
        , b = s + 1
        , _ = Math.atan2(t - e, i)
        , p = Math.cos(_)
        , m = Math.sin(_)
        , v = r + (h ? 2 : 0);
      for (let n = o ? -2 : 0; n <= v; ++n) {
          let a, o = n / r, h = i * o;
          n < 0 ? (h = 0,
          o = 1,
          a = t) : n > r ? (h = i,
          o = 1,
          a = e) : a = t + n / r * (e - t),
          -2 !== n && n !== r + 2 || (a = 0,
          o = 0),
          h -= i / 2;
          for (let t = 0; t < b; ++t) {
              const e = Math.sin(t * Math.PI * 2 / s)
                , i = Math.cos(t * Math.PI * 2 / s);
              c.push(e * a, h, i * a),
              n < 0 ? d.push(0, -1, 0) : n > r ? d.push(0, 1, 0) : 0 === a ? d.push(0, 0, 0) : d.push(e * p, m, i * p),
              f.push(t / s, 1 - o)
          }
      }
      for (let t = 0; t < r + l; ++t)
          if (!(1 === t && o || t === r + l - 2 && h))
              for (let e = 0; e < s; ++e)
                  g.push(b * (t + 0) + 0 + e, b * (t + 0) + 1 + e, b * (t + 1) + 1 + e),
                  g.push(b * (t + 0) + 0 + e, b * (t + 1) + 1 + e, b * (t + 1) + 0 + e);
      return {
          position: c,
          normal: d,
          texcoord: f,
          indices: g
      }
  }
  function mt(t, e) {
      e = e || [];
      const i = [];
      for (let s = 0; s < t.length; s += 4) {
          const r = t[s]
            , n = t.slice(s + 1, s + 4);
          n.push.apply(n, e);
          for (let t = 0; t < r; ++t)
              i.push.apply(i, n)
      }
      return i
  }
  function vt() {
      const t = [0, 0, 0, 0, 150, 0, 30, 0, 0, 0, 150, 0, 30, 150, 0, 30, 0, 0, 30, 0, 0, 30, 30, 0, 100, 0, 0, 30, 30, 0, 100, 30, 0, 100, 0, 0, 30, 60, 0, 30, 90, 0, 67, 60, 0, 30, 90, 0, 67, 90, 0, 67, 60, 0, 0, 0, 30, 30, 0, 30, 0, 150, 30, 0, 150, 30, 30, 0, 30, 30, 150, 30, 30, 0, 30, 100, 0, 30, 30, 30, 30, 30, 30, 30, 100, 0, 30, 100, 30, 30, 30, 60, 30, 67, 60, 30, 30, 90, 30, 30, 90, 30, 67, 60, 30, 67, 90, 30, 0, 0, 0, 100, 0, 0, 100, 0, 30, 0, 0, 0, 100, 0, 30, 0, 0, 30, 100, 0, 0, 100, 30, 0, 100, 30, 30, 100, 0, 0, 100, 30, 30, 100, 0, 30, 30, 30, 0, 30, 30, 30, 100, 30, 30, 30, 30, 0, 100, 30, 30, 100, 30, 0, 30, 30, 0, 30, 60, 30, 30, 30, 30, 30, 30, 0, 30, 60, 0, 30, 60, 30, 30, 60, 0, 67, 60, 30, 30, 60, 30, 30, 60, 0, 67, 60, 0, 67, 60, 30, 67, 60, 0, 67, 90, 30, 67, 60, 30, 67, 60, 0, 67, 90, 0, 67, 90, 30, 30, 90, 0, 30, 90, 30, 67, 90, 30, 30, 90, 0, 67, 90, 30, 67, 90, 0, 30, 90, 0, 30, 150, 30, 30, 90, 30, 30, 90, 0, 30, 150, 0, 30, 150, 30, 0, 150, 0, 0, 150, 30, 30, 150, 30, 0, 150, 0, 30, 150, 30, 30, 150, 0, 0, 0, 0, 0, 0, 30, 0, 150, 30, 0, 0, 0, 0, 150, 30, 0, 150, 0]
        , e = mt([18, 0, 0, 1, 18, 0, 0, -1, 6, 0, 1, 0, 6, 1, 0, 0, 6, 0, -1, 0, 6, 1, 0, 0, 6, 0, 1, 0, 6, 1, 0, 0, 6, 0, -1, 0, 6, 1, 0, 0, 6, 0, -1, 0, 6, -1, 0, 0])
        , i = mt([18, 200, 70, 120, 18, 80, 70, 200, 6, 70, 200, 210, 6, 200, 200, 70, 6, 210, 100, 70, 6, 210, 160, 70, 6, 70, 180, 210, 6, 100, 70, 210, 6, 76, 210, 100, 6, 140, 210, 80, 6, 90, 130, 110, 6, 160, 160, 220], [255])
        , s = t.length / 3
        , r = {
          position: nt(3, s),
          texcoord: nt(2, s),
          normal: nt(3, s),
          color: nt(4, s, Uint8Array),
          indices: nt(3, s / 3, Uint16Array)
      };
      r.position.push(t),
      r.texcoord.push([.22, .19, .22, .79, .34, .19, .22, .79, .34, .79, .34, .19, .34, .19, .34, .31, .62, .19, .34, .31, .62, .31, .62, .19, .34, .43, .34, .55, .49, .43, .34, .55, .49, .55, .49, .43, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0]),
      r.normal.push(e),
      r.color.push(i);
      for (let t = 0; t < s; ++t)
          r.indices.push(t);
      return r
  }
  function xt(t, e, i, s, a, o, h) {
      if (a <= 0)
          throw new Error("subdivisionDown must be > 0");
      const l = (h = h || 1) - (o = o || 0)
        , u = 2 * (a + 1) * 4
        , c = nt(3, u)
        , d = nt(3, u)
        , f = nt(2, u);
      function g(t, e, i) {
          return t + (e - t) * i
      }
      function b(e, i, h, u, b, _) {
          for (let p = 0; p <= a; p++) {
              const m = i / 1
                , v = p / a
                , x = 2 * (m - .5)
                , T = (o + v * l) * Math.PI
                , w = Math.sin(T)
                , y = Math.cos(T)
                , A = g(t, e, w)
                , E = x * s
                , C = y * t
                , M = w * A;
              c.push(E, C, M);
              const k = r(n([0, w, y], h), u);
              d.push(k),
              f.push(m * b + _, v)
          }
      }
      for (let t = 0; t < 2; t++) {
          const s = 2 * (t / 1 - .5);
          b(e, t, [1, 1, 1], [0, 0, 0], 1, 0),
          b(e, t, [0, 0, 0], [s, 0, 0], 0, 0),
          b(i, t, [1, 1, 1], [0, 0, 0], 1, 0),
          b(i, t, [0, 0, 0], [s, 0, 0], 0, 1)
      }
      const _ = nt(3, 2 * a * 4, Uint16Array);
      function p(t, e) {
          for (let i = 0; i < a; ++i)
              _.push(t + i + 0, t + i + 1, e + i + 0),
              _.push(t + i + 1, e + i + 1, e + i + 0)
      }
      const m = a + 1;
      return p(0 * m, 4 * m),
      p(5 * m, 7 * m),
      p(6 * m, 2 * m),
      p(3 * m, 1 * m),
      {
          position: c,
          normal: d,
          texcoord: f,
          indices: _
      }
  }
  function Tt(t, e, i, s, r, n) {
      return pt(t, t, e, i, s, r, n)
  }
  function wt(t, e, i, s, r, n) {
      if (i < 3)
          throw new Error("radialSubdivisions must be 3 or greater");
      if (s < 3)
          throw new Error("verticalSubdivisions must be 3 or greater");
      r = r || 0;
      const a = (n = n || 2 * Math.PI) - r
        , o = i + 1
        , h = s + 1
        , l = o * h
        , u = nt(3, l)
        , c = nt(3, l)
        , d = nt(2, l)
        , f = nt(3, i * s * 2, Uint16Array);
      for (let n = 0; n < h; ++n) {
          const h = n / s
            , l = h * Math.PI * 2
            , f = Math.sin(l)
            , g = t + f * e
            , b = Math.cos(l)
            , _ = b * e;
          for (let t = 0; t < o; ++t) {
              const e = t / i
                , s = r + e * a
                , n = Math.sin(s)
                , o = Math.cos(s)
                , l = n * g
                , p = o * g
                , m = n * f
                , v = o * f;
              u.push(l, _, p),
              c.push(m, b, v),
              d.push(e, 1 - h)
          }
      }
      for (let t = 0; t < s; ++t)
          for (let e = 0; e < i; ++e) {
              const i = 1 + e
                , s = 1 + t;
              f.push(o * t + e, o * s + e, o * t + i),
              f.push(o * s + e, o * s + i, o * t + i)
          }
      return {
          position: u,
          normal: c,
          texcoord: d,
          indices: f
      }
  }
  function yt(t, e, i, s, r) {
      if (e < 3)
          throw new Error("divisions must be at least 3");
      r = r || 1,
      s = s || 0;
      const n = (e + 1) * ((i = i || 1) + 1)
        , a = nt(3, n)
        , o = nt(3, n)
        , h = nt(2, n)
        , l = nt(3, i * e * 2, Uint16Array);
      let u = 0;
      const c = t - s
        , d = e + 1;
      for (let t = 0; t <= i; ++t) {
          const n = s + c * Math.pow(t / i, r);
          for (let s = 0; s <= e; ++s) {
              const r = 2 * Math.PI * s / e
                , c = n * Math.cos(r)
                , f = n * Math.sin(r);
              if (a.push(c, 0, f),
              o.push(0, 1, 0),
              h.push(1 - s / e, t / i),
              t > 0 && s !== e) {
                  const t = u + (s + 1)
                    , e = u + s
                    , i = u + s - d
                    , r = u + (s + 1) - d;
                  l.push(t, e, i),
                  l.push(t, i, r)
              }
          }
          u += e + 1
      }
      return {
          position: a,
          normal: o,
          texcoord: h,
          indices: l
      }
  }
  function At(t) {
      return function(e) {
          return st(e, t.apply(this, Array.prototype.slice.call(arguments, 1)))
      }
  }
  function Et(t) {
      return function(e) {
          return et(e, t.apply(null, Array.prototype.slice.call(arguments, 1)))
      }
  }
  Et(vt),
  At(vt),
  Et(_t),
  At(_t),
  Et(ft),
  At(ft),
  Et(gt),
  At(gt),
  Et(pt),
  At(pt),
  Et(dt),
  At(dt),
  Et(xt),
  At(xt),
  Et(Tt),
  At(Tt),
  Et(wt),
  At(wt),
  Et(yt),
  At(yt);
  function Ct(t) {
      return !!t.texStorage2D
  }
  const Mt = function() {
      const t = {}
        , e = {};
      return function(i, s) {
          return function(i) {
              const s = i.constructor.name;
              if (!t[s]) {
                  for (const t in i)
                      if ("number" == typeof i[t]) {
                          const s = e[i[t]];
                          e[i[t]] = s ? `${s} | ${t}` : t
                      }
                  t[s] = !0
              }
          }(i),
          e[s] || ("number" == typeof s ? `0x${s.toString(16)}` : s)
      }
  }();
  new Uint8Array([128, 192, 255, 255]),
  function() {
      let t
  }();
  const kt = 6406
    , Ft = 6407
    , St = 6408
    , Dt = 6409
    , It = 6410
    , Rt = 6402
    , Ut = 34041
    , Ot = 33319
    , Pt = 33320
    , Bt = 6403
    , zt = 36244
    , Nt = 36248
    , Gt = 36249
    , jt = {};
  {
      const t = jt;
      t[kt] = {
          numColorComponents: 1
      },
      t[Dt] = {
          numColorComponents: 1
      },
      t[It] = {
          numColorComponents: 2
      },
      t[Ft] = {
          numColorComponents: 3
      },
      t[St] = {
          numColorComponents: 4
      },
      t[Bt] = {
          numColorComponents: 1
      },
      t[zt] = {
          numColorComponents: 1
      },
      t[Ot] = {
          numColorComponents: 2
      },
      t[Pt] = {
          numColorComponents: 2
      },
      t[Ft] = {
          numColorComponents: 3
      },
      t[Nt] = {
          numColorComponents: 3
      },
      t[St] = {
          numColorComponents: 4
      },
      t[Gt] = {
          numColorComponents: 4
      },
      t[Rt] = {
          numColorComponents: 1
      },
      t[Ut] = {
          numColorComponents: 2
      }
  }
  const Lt = y;
  function Ht(t) {
      return "undefined" != typeof document && document.getElementById ? document.getElementById(t) : null
  }
  const Vt = 33984
    , qt = 34962
    , Xt = 35713
    , Wt = 35714
    , Zt = 35632
    , Kt = 35633
    , Yt = 35981
    , Jt = 35718
    , Qt = 35721
    , $t = 35971
    , te = 35382
    , ee = 35396
    , ie = 35398
    , se = 35392
    , re = 35395
    , ne = 5126
    , ae = 5124
    , oe = 5125
    , he = 3553
    , le = 34067
    , ue = 32879
    , ce = 35866
    , de = {};
  function fe(t, e) {
      return de[e].bindPoint
  }
  function ge(t, e) {
      return function(i) {
          t.uniform1i(e, i)
      }
  }
  function be(t, e) {
      return function(i) {
          t.uniform1iv(e, i)
      }
  }
  function _e(t, e) {
      return function(i) {
          t.uniform2iv(e, i)
      }
  }
  function pe(t, e) {
      return function(i) {
          t.uniform3iv(e, i)
      }
  }
  function me(t, e) {
      return function(i) {
          t.uniform4iv(e, i)
      }
  }
  function ve(t, e, i, s) {
      const r = fe(0, e);
      return Ct(t) ? function(e) {
          let n, a;
          !e || C(0, e) ? (n = e,
          a = null) : (n = e.texture,
          a = e.sampler),
          t.uniform1i(s, i),
          t.activeTexture(Vt + i),
          t.bindTexture(r, n),
          t.bindSampler(i, a)
      }
      : function(e) {
          t.uniform1i(s, i),
          t.activeTexture(Vt + i),
          t.bindTexture(r, e)
      }
  }
  function xe(t, e, i, s, r) {
      const n = fe(0, e)
        , a = new Int32Array(r);
      for (let t = 0; t < r; ++t)
          a[t] = i + t;
      return Ct(t) ? function(e) {
          t.uniform1iv(s, a),
          e.forEach((function(e, s) {
              let r, o;
              t.activeTexture(Vt + a[s]),
              !e || C(0, e) ? (r = e,
              o = null) : (r = e.texture,
              o = e.sampler),
              t.bindSampler(i, o),
              t.bindTexture(n, r)
          }
          ))
      }
      : function(e) {
          t.uniform1iv(s, a),
          e.forEach((function(e, i) {
              t.activeTexture(Vt + a[i]),
              t.bindTexture(n, e)
          }
          ))
      }
  }
  function Te(t, e) {
      return function(i) {
          if (i.value)
              switch (t.disableVertexAttribArray(e),
              i.value.length) {
              case 4:
                  t.vertexAttrib4fv(e, i.value);
                  break;
              case 3:
                  t.vertexAttrib3fv(e, i.value);
                  break;
              case 2:
                  t.vertexAttrib2fv(e, i.value);
                  break;
              case 1:
                  t.vertexAttrib1fv(e, i.value);
                  break;
              default:
                  throw new Error("the length of a float constant value must be between 1 and 4!")
              }
          else
              t.bindBuffer(qt, i.buffer),
              t.enableVertexAttribArray(e),
              t.vertexAttribPointer(e, i.numComponents || i.size, i.type || ne, i.normalize || !1, i.stride || 0, i.offset || 0),
              t.vertexAttribDivisor && t.vertexAttribDivisor(e, i.divisor || 0)
      }
  }
  function we(t, e) {
      return function(i) {
          if (i.value) {
              if (t.disableVertexAttribArray(e),
              4 !== i.value.length)
                  throw new Error("The length of an integer constant value must be 4!");
              t.vertexAttrib4iv(e, i.value)
          } else
              t.bindBuffer(qt, i.buffer),
              t.enableVertexAttribArray(e),
              t.vertexAttribIPointer(e, i.numComponents || i.size, i.type || ae, i.stride || 0, i.offset || 0),
              t.vertexAttribDivisor && t.vertexAttribDivisor(e, i.divisor || 0)
      }
  }
  function ye(t, e) {
      return function(i) {
          if (i.value) {
              if (t.disableVertexAttribArray(e),
              4 !== i.value.length)
                  throw new Error("The length of an unsigned integer constant value must be 4!");
              t.vertexAttrib4uiv(e, i.value)
          } else
              t.bindBuffer(qt, i.buffer),
              t.enableVertexAttribArray(e),
              t.vertexAttribIPointer(e, i.numComponents || i.size, i.type || oe, i.stride || 0, i.offset || 0),
              t.vertexAttribDivisor && t.vertexAttribDivisor(e, i.divisor || 0)
      }
  }
  function Ae(t, e, i) {
      const s = i.size
        , r = i.count;
      return function(i) {
          t.bindBuffer(qt, i.buffer);
          const n = i.size || i.numComponents || s
            , a = n / r
            , o = i.type || ne
            , h = de[o].size * n
            , l = i.normalize || !1
            , u = i.offset || 0
            , c = h / r;
          for (let s = 0; s < r; ++s)
              t.enableVertexAttribArray(e + s),
              t.vertexAttribPointer(e + s, a, o, l, h, u + c * s),
              t.vertexAttribDivisor && t.vertexAttribDivisor(e + s, i.divisor || 0)
      }
  }
  de[5126] = {
      Type: Float32Array,
      size: 4,
      setter: function(t, e) {
          return function(i) {
              t.uniform1f(e, i)
          }
      },
      arraySetter: function(t, e) {
          return function(i) {
              t.uniform1fv(e, i)
          }
      }
  },
  de[35664] = {
      Type: Float32Array,
      size: 8,
      setter: function(t, e) {
          return function(i) {
              t.uniform2fv(e, i)
          }
      },
      cols: 2
  },
  de[35665] = {
      Type: Float32Array,
      size: 12,
      setter: function(t, e) {
          return function(i) {
              t.uniform3fv(e, i)
          }
      },
      cols: 3
  },
  de[35666] = {
      Type: Float32Array,
      size: 16,
      setter: function(t, e) {
          return function(i) {
              t.uniform4fv(e, i)
          }
      },
      cols: 4
  },
  de[ae] = {
      Type: Int32Array,
      size: 4,
      setter: ge,
      arraySetter: be
  },
  de[35667] = {
      Type: Int32Array,
      size: 8,
      setter: _e,
      cols: 2
  },
  de[35668] = {
      Type: Int32Array,
      size: 12,
      setter: pe,
      cols: 3
  },
  de[35669] = {
      Type: Int32Array,
      size: 16,
      setter: me,
      cols: 4
  },
  de[5125] = {
      Type: Uint32Array,
      size: 4,
      setter: function(t, e) {
          return function(i) {
              t.uniform1ui(e, i)
          }
      },
      arraySetter: function(t, e) {
          return function(i) {
              t.uniform1uiv(e, i)
          }
      }
  },
  de[36294] = {
      Type: Uint32Array,
      size: 8,
      setter: function(t, e) {
          return function(i) {
              t.uniform2uiv(e, i)
          }
      },
      cols: 2
  },
  de[36295] = {
      Type: Uint32Array,
      size: 12,
      setter: function(t, e) {
          return function(i) {
              t.uniform3uiv(e, i)
          }
      },
      cols: 3
  },
  de[36296] = {
      Type: Uint32Array,
      size: 16,
      setter: function(t, e) {
          return function(i) {
              t.uniform4uiv(e, i)
          }
      },
      cols: 4
  },
  de[35670] = {
      Type: Uint32Array,
      size: 4,
      setter: ge,
      arraySetter: be
  },
  de[35671] = {
      Type: Uint32Array,
      size: 8,
      setter: _e,
      cols: 2
  },
  de[35672] = {
      Type: Uint32Array,
      size: 12,
      setter: pe,
      cols: 3
  },
  de[35673] = {
      Type: Uint32Array,
      size: 16,
      setter: me,
      cols: 4
  },
  de[35674] = {
      Type: Float32Array,
      size: 32,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix2fv(e, !1, i)
          }
      },
      rows: 2,
      cols: 2
  },
  de[35675] = {
      Type: Float32Array,
      size: 48,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix3fv(e, !1, i)
          }
      },
      rows: 3,
      cols: 3
  },
  de[35676] = {
      Type: Float32Array,
      size: 64,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix4fv(e, !1, i)
          }
      },
      rows: 4,
      cols: 4
  },
  de[35685] = {
      Type: Float32Array,
      size: 32,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix2x3fv(e, !1, i)
          }
      },
      rows: 2,
      cols: 3
  },
  de[35686] = {
      Type: Float32Array,
      size: 32,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix2x4fv(e, !1, i)
          }
      },
      rows: 2,
      cols: 4
  },
  de[35687] = {
      Type: Float32Array,
      size: 48,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix3x2fv(e, !1, i)
          }
      },
      rows: 3,
      cols: 2
  },
  de[35688] = {
      Type: Float32Array,
      size: 48,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix3x4fv(e, !1, i)
          }
      },
      rows: 3,
      cols: 4
  },
  de[35689] = {
      Type: Float32Array,
      size: 64,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix4x2fv(e, !1, i)
          }
      },
      rows: 4,
      cols: 2
  },
  de[35690] = {
      Type: Float32Array,
      size: 64,
      setter: function(t, e) {
          return function(i) {
              t.uniformMatrix4x3fv(e, !1, i)
          }
      },
      rows: 4,
      cols: 3
  },
  de[35678] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: he
  },
  de[35680] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: le
  },
  de[35679] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: ue
  },
  de[35682] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: he
  },
  de[36289] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: ce
  },
  de[36292] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: ce
  },
  de[36293] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: le
  },
  de[36298] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: he
  },
  de[36299] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: ue
  },
  de[36300] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: le
  },
  de[36303] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: ce
  },
  de[36306] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: he
  },
  de[36307] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: ue
  },
  de[36308] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: le
  },
  de[36311] = {
      Type: null,
      size: 0,
      setter: ve,
      arraySetter: xe,
      bindPoint: ce
  };
  const Ee = {};
  Ee[5126] = {
      size: 4,
      setter: Te
  },
  Ee[35664] = {
      size: 8,
      setter: Te
  },
  Ee[35665] = {
      size: 12,
      setter: Te
  },
  Ee[35666] = {
      size: 16,
      setter: Te
  },
  Ee[ae] = {
      size: 4,
      setter: we
  },
  Ee[35667] = {
      size: 8,
      setter: we
  },
  Ee[35668] = {
      size: 12,
      setter: we
  },
  Ee[35669] = {
      size: 16,
      setter: we
  },
  Ee[5125] = {
      size: 4,
      setter: ye
  },
  Ee[36294] = {
      size: 8,
      setter: ye
  },
  Ee[36295] = {
      size: 12,
      setter: ye
  },
  Ee[36296] = {
      size: 16,
      setter: ye
  },
  Ee[35670] = {
      size: 4,
      setter: we
  },
  Ee[35671] = {
      size: 8,
      setter: we
  },
  Ee[35672] = {
      size: 12,
      setter: we
  },
  Ee[35673] = {
      size: 16,
      setter: we
  },
  Ee[35674] = {
      size: 4,
      setter: Ae,
      count: 2
  },
  Ee[35675] = {
      size: 9,
      setter: Ae,
      count: 3
  },
  Ee[35676] = {
      size: 16,
      setter: Ae,
      count: 4
  };
  const Ce = /ERROR:\s*\d+:(\d+)/gi;
  const Me = /^[ \t]*\n/;
  function ke(t) {
      let e = 0;
      return Me.test(t) && (e = 1,
      t = t.replace(Me, "")),
      {
          lineOffset: e,
          shaderSource: t
      }
  }
  function Fe(t, e) {
      return t.errorCallback(e),
      t.callback && setTimeout(( () => {
          t.callback(`${e}\n${t.errors.join("\n")}`)
      }
      )),
      null
  }
  function Se(t, e, i, s) {
      s = s || Lt;
      if (!t.getShaderParameter(i, Xt)) {
          const r = t.getShaderInfoLog(i)
            , {lineOffset: n, shaderSource: a} = ke(t.getShaderSource(i))
            , o = `${function(t, e="", i=0) {
              const s = [...e.matchAll(Ce)]
                , r = new Map(s.map(( (t, i) => {
                  const r = parseInt(t[1])
                    , n = s[i + 1]
                    , a = n ? n.index : e.length;
                  return [r - 1, e.substring(t.index, a)]
              }
              )));
              return t.split("\n").map(( (t, e) => {
                  const s = r.get(e);
                  return `${e + 1 + i}: ${t}${s ? `\n\n^^^ ${s}` : ""}`
              }
              )).join("\n")
          }(a, r, n)}\nError compiling ${Mt(t, e)}: ${r}`;
          return s(o),
          o
      }
      return ""
  }
  function De(t, e, i) {
      let s, r, n;
      if ("function" == typeof e && (i = e,
      e = void 0),
      "function" == typeof t)
          i = t,
          t = void 0;
      else if (t && !Array.isArray(t)) {
          const e = t;
          i = e.errorCallback,
          t = e.attribLocations,
          s = e.transformFeedbackVaryings,
          r = e.transformFeedbackMode,
          n = e.callback
      }
      const a = i || Lt
        , o = []
        , h = {
          errorCallback(t, ...e) {
              o.push(t),
              a(t, ...e)
          },
          transformFeedbackVaryings: s,
          transformFeedbackMode: r,
          callback: n,
          errors: o
      };
      {
          let i = {};
          Array.isArray(t) ? t.forEach((function(t, s) {
              i[t] = e ? e[s] : s
          }
          )) : i = t || {},
          h.attribLocations = i
      }
      return h
  }
  const Ie = ["VERTEX_SHADER", "FRAGMENT_SHADER"];
  const Re = (t=0) => new Promise((e => setTimeout(e, t)));
  function Ue(t, e, i) {
      const s = t.createProgram()
        , {attribLocations: r, transformFeedbackVaryings: n, transformFeedbackMode: a} = De(i);
      for (let i = 0; i < e.length; ++i) {
          let r = e[i];
          if ("string" == typeof r) {
              const e = Ht(r)
                , n = e ? e.text : r;
              let a = t[Ie[i]];
              e && e.type && (a = ((o = e.type).indexOf("frag") >= 0 ? Zt : o.indexOf("vert") >= 0 ? Kt : void 0) || a),
              r = t.createShader(a),
              t.shaderSource(r, ke(n).shaderSource),
              t.compileShader(r),
              t.attachShader(s, r)
          }
      }
      var o;
      Object.entries(r).forEach(( ([e,i]) => t.bindAttribLocation(s, i, e)));
      {
          let e = n;
          e && (e.attribs && (e = e.attribs),
          Array.isArray(e) || (e = Object.keys(e)),
          t.transformFeedbackVaryings(s, e, a || Yt))
      }
      return t.linkProgram(s),
      s
  }
  function Oe(t, e, i, s, r) {
      const n = De(i, s, r)
        , a = new Set(e)
        , o = Ue(t, e, n);
      function h(t, e) {
          const i = ze(t, e, n.errorCallback);
          return i && function(t, e, i) {
              const s = t.getAttachedShaders(e);
              for (const e of s)
                  i.has(e) && t.deleteShader(e);
              t.deleteProgram(e)
          }(t, e, a),
          i
      }
      if (!n.callback)
          return h(t, o) ? void 0 : o;
      Be(t, o).then(( () => {
          const e = h(t, o);
          n.callback(e, e ? void 0 : o)
      }
      ))
  }
  function Pe(t) {
      return function(e, i, ...s) {
          return new Promise(( (r, n) => {
              const a = De(...s);
              a.callback = (t, e) => {
                  t ? n(t) : r(e)
              }
              ,
              t(e, i, a)
          }
          ))
      }
  }
  Pe(Oe),
  Pe(Qe);
  async function Be(t, e) {
      const i = t.getExtension("KHR_parallel_shader_compile")
        , s = i ? (t, e) => t.getProgramParameter(e, i.COMPLETION_STATUS_KHR) : () => !0;
      let r = 0;
      do {
          await Re(r),
          r = 1e3 / 60
      } while (!s(t, e))
  }
  function ze(t, e, i) {
      i = i || Lt;
      if (!t.getProgramParameter(e, Wt)) {
          const s = t.getProgramInfoLog(e);
          i(`Error in program linking: ${s}`);
          return `${s}\n${t.getAttachedShaders(e).map((e => Se(t, t.getShaderParameter(e, t.SHADER_TYPE), e, i))).filter((t => t)).join("\n")}`
      }
  }
  function Ne(t, e, i, s, r) {
      return Oe(t, e, i, s, r)
  }
  function Ge(t) {
      const e = t.name;
      return e.startsWith("gl_") || e.startsWith("webgl_")
  }
  const je = /(\.|\[|]|\w+)/g
    , Le = t => t >= "0" && t <= "9";
  function He(t, e, i, s) {
      const r = t.split(je).filter((t => "" !== t));
      let n = 0
        , a = "";
      for (; ; ) {
          const t = r[n++];
          a += t;
          const o = Le(t[0])
            , h = o ? parseInt(t) : t;
          o && (a += r[n++]);
          if (n === r.length) {
              i[h] = e;
              break
          }
          {
              const t = r[n++]
                , e = "[" === t
                , o = i[h] || (e ? [] : {});
              i[h] = o,
              i = o,
              s[a] = s[a] || function(t) {
                  return function(e) {
                      We(t, e)
                  }
              }(o),
              a += t
          }
      }
  }
  function Ve(t, e) {
      let i = 0;
      function s(e, s, r) {
          const n = s.name.endsWith("[0]")
            , a = s.type
            , o = de[a];
          if (!o)
              throw new Error(`unknown type: 0x${a.toString(16)}`);
          let h;
          if (o.bindPoint) {
              const e = i;
              i += s.size,
              h = n ? o.arraySetter(t, a, e, r, s.size) : o.setter(t, a, e, r, s.size)
          } else
              h = o.arraySetter && n ? o.arraySetter(t, r) : o.setter(t, r);
          return h.location = r,
          h
      }
      const r = {}
        , n = {}
        , a = t.getProgramParameter(e, Jt);
      for (let i = 0; i < a; ++i) {
          const a = t.getActiveUniform(e, i);
          if (Ge(a))
              continue;
          let o = a.name;
          o.endsWith("[0]") && (o = o.substr(0, o.length - 3));
          const h = t.getUniformLocation(e, a.name);
          if (h) {
              const t = s(0, a, h);
              r[o] = t,
              He(o, t, n, r)
          }
      }
      return r
  }
  function qe(t, e) {
      const i = {}
        , s = t.getProgramParameter(e, $t);
      for (let r = 0; r < s; ++r) {
          const s = t.getTransformFeedbackVarying(e, r);
          i[s.name] = {
              index: r,
              type: s.type,
              size: s.size
          }
      }
      return i
  }
  function Xe(t, e) {
      const i = t.getProgramParameter(e, Jt)
        , s = []
        , r = [];
      for (let n = 0; n < i; ++n) {
          r.push(n),
          s.push({});
          const i = t.getActiveUniform(e, n);
          s[n].name = i.name
      }
      [["UNIFORM_TYPE", "type"], ["UNIFORM_SIZE", "size"], ["UNIFORM_BLOCK_INDEX", "blockNdx"], ["UNIFORM_OFFSET", "offset"]].forEach((function(i) {
          const n = i[0]
            , a = i[1];
          t.getActiveUniforms(e, r, t[n]).forEach((function(t, e) {
              s[e][a] = t
          }
          ))
      }
      ));
      const n = {}
        , a = t.getProgramParameter(e, te);
      for (let i = 0; i < a; ++i) {
          const s = t.getActiveUniformBlockName(e, i)
            , r = {
              index: t.getUniformBlockIndex(e, s),
              usedByVertexShader: t.getActiveUniformBlockParameter(e, i, ee),
              usedByFragmentShader: t.getActiveUniformBlockParameter(e, i, ie),
              size: t.getActiveUniformBlockParameter(e, i, se),
              uniformIndices: t.getActiveUniformBlockParameter(e, i, re)
          };
          r.used = r.usedByVertexShader || r.usedByFragmentShader,
          n[s] = r
      }
      return {
          blockSpecs: n,
          uniformData: s
      }
  }
  function We(t, e) {
      for (const i in e) {
          const s = t[i];
          "function" == typeof s ? s(e[i]) : We(t[i], e[i])
      }
  }
  function Ze(t, ...e) {
      const i = t.uniformSetters || t
        , s = e.length;
      for (let t = 0; t < s; ++t) {
          const s = e[t];
          if (Array.isArray(s)) {
              const t = s.length;
              for (let e = 0; e < t; ++e)
                  Ze(i, s[e])
          } else
              for (const t in s) {
                  const e = i[t];
                  e && e(s[t])
              }
      }
  }
  function Ke(t, e) {
      const i = {}
        , s = t.getProgramParameter(e, Qt);
      for (let r = 0; r < s; ++r) {
          const s = t.getActiveAttrib(e, r);
          if (Ge(s))
              continue;
          const n = t.getAttribLocation(e, s.name)
            , a = Ee[s.type]
            , o = a.setter(t, n, a);
          o.location = n,
          i[s.name] = o
      }
      return i
  }
  function Ye(t, e) {
      const i = {
          program: e,
          uniformSetters: Ve(t, e),
          attribSetters: Ke(t, e)
      };
      return Ct(t) && (i.uniformBlockSpec = Xe(t, e),
      i.transformFeedbackInfo = qe(t, e)),
      i
  }
  const Je = /\s|{|}|;/;
  function Qe(t, e, i, s, r) {
      const n = De(i, s, r)
        , a = [];
      if (e = e.map((function(t) {
          if (!Je.test(t)) {
              const e = Ht(t);
              if (e)
                  t = e.text;
              else {
                  const e = `no element with id: ${t}`;
                  n.errorCallback(e),
                  a.push(e)
              }
          }
          return t
      }
      )),
      a.length)
          return Fe(n, "");
      const o = n.callback;
      o && (n.callback = (e, i) => {
          o(e, e ? void 0 : Ye(t, i))
      }
      );
      const h = Ne(t, e, n);
      return h ? Ye(t, h) : null
  }
  function $e(t, e, i, s, r) {
      for (const [n,a] of Object.entries(e)) {
          const o = {
              ...r
          }
            , h = i[n];
          Array.isArray(h) || Object.assign(o, h);
          const l = ze(t, a, o.errorCallback);
          if (l) {
              for (const i of Object.values(e)) {
                  const e = t.getAttachedShaders(i);
                  t.deleteProgram(i);
                  for (const i of e)
                      s.has(i) || t.deleteShader(i)
              }
              return l
          }
      }
  }
  function ti(t, e, i={}) {
      const s = new Set
        , r = Object.fromEntries(Object.entries(e).map(( ([e,r]) => {
          const n = {
              ...i
          }
            , a = Array.isArray(r) ? r : r.shaders;
          return Array.isArray(r) || Object.assign(n, r),
          a.forEach(s.add, s),
          [e, Ue(t, a, n)]
      }
      )));
      if (i.callback)
          return void async function(t, e) {
              for (const i of Object.values(e))
                  await Be(t, i)
          }(t, r).then(( () => {
              const n = $e(t, r, e, s, i);
              i.callback(n, n ? void 0 : r)
          }
          ));
      return $e(t, r, e, s, i) ? void 0 : r
  }
  function ei(t, e, i) {
      function s(t, e) {
          return Object.fromEntries(Object.entries(e).map(( ([e,i]) => [e, Ye(t, i)])))
      }
      const r = (i = De(i)).callback;
      r && (i.callback = (e, i) => {
          r(e, e ? void 0 : s(t, i))
      }
      );
      const n = ti(t, e, i);
      if (!r && n)
          return s(t, n)
  }
  Pe(ti),
  Pe(ei);
  const ii = 36096
    , si = 33306
    , ri = {};
  ri[34041] = si,
  ri[6401] = 36128,
  ri[36168] = 36128,
  ri[6402] = ii,
  ri[33189] = ii,
  ri[33190] = ii,
  ri[36012] = ii,
  ri[35056] = si,
  ri[36013] = si;
  const ni = {};
  ni[32854] = !0,
  ni[32855] = !0,
  ni[36194] = !0,
  ni[34041] = !0,
  ni[33189] = !0,
  ni[6401] = !0,
  ni[36168] = !0;
  var ai = {};
  const oi = {
      position: 3,
      normal: 3,
      tangent: 3,
      texcoord: 2,
      texcoord0: 2,
      texcoord1: 2,
      texcoord2: 2
  };
  var hi = {};
  class li {
      constructor() {
          this.attribs = {}
      }
      disableAll() {
          for (let t in this.attribs)
              this.gl.disableVertexAttribArray(this.attribs[t]);
          this.attribs = {}
      }
      enable(t, e) {
          this.gl = t;
          var i = {};
          for (let r in e) {
              var s = e[r];
              void 0 !== s.loc && (void 0 === this.attribs[s.loc] && t.enableVertexAttribArray(s.loc),
              t.vertexAttribPointer(s.loc, s.size, s.type, !1, s.stride, s.offset),
              i[s.loc] = s.loc,
              this.attribs[r] = null)
          }
          for (let t in this.attribs)
              ;
          this.attribs = i
      }
  }
  class ui {
      static CreateProgramAttributes(t, e) {
          var i = {}
            , s = 0;
          for (let a in e) {
              var r = e[a]
                , n = oi[a];
              i[r] = {
                  type: t.FLOAT,
                  size: n,
                  offset: 4 * s
              },
              s += n
          }
          for (let t in i)
              i[t].stride = 4 * s;
          return i
      }
      CleanUpPrograms() {
          hi = {}
      }
      ReleaseProgram(t) {}
      static _GetProgram(t) {
          return hi[t]
      }
      static RegisterProgram(t, e) {
          if (!hi[t]) {
              var i = e.shaders;
              hi[t] = {
                  shaders: [i[0], i[1]],
                  attributes: e.attributes
              }
          }
          return hi[t]
      }
      static GetProgram(t, e, i, s) {
          var r = hi[e]
            , n = "";
          for (var a in i)
              n += a + ":" + i[a] + "-";
          if (!r) {
              var o = e.split(".")
                , h = ai[o[0]][o[1]];
              h && (r = ui.RegisterProgram(e, h))
          }
          if (!r)
              throw "Program not registered: " + o;
          r.programInfo || (r.programInfo = {}),
          r.programInfo[n] = ui.CompileProgram(t, r.shaders, i),
          s = s || r.attributes && ui.CreateProgramAttributes(t, r.attributes);
          var l = r.programInfo[n];
          if (s)
              for (var a in s) {
                  var u = l.attribSetters[a];
                  u && (s[a] = s[a] || {},
                  s[a].loc = u.location)
              }
          return l.attributes = s,
          l
      }
      static CompileProgram(t, e, i, s) {
          var r = "";
          for (var n in i) {
              var a = i[n];
              r = "#define " + n + " " + (null === a ? "" : a) + "\n"
          }
          var o = {};
          const h = Qe(t, [r + e[0], r + e[1]], null, null);
          if (s)
              for (var n in s) {
                  var l = h.attribSetters[n];
                  l && (s[n] = s[n] || {},
                  s[n].loc = l.location)
              }
          for (var n in h.uniformSetters)
              o[n] = h.uniformSetters[n].location;
          return h.uniforms = o,
          h
      }
  }
  var ci = new ui
    , di = 1e-6
    , fi = "undefined" != typeof Float32Array ? Float32Array : Array;
  Math.random;
  Math.PI;
  function gi() {
      var t = new fi(3);
      return fi != Float32Array && (t[0] = 0,
      t[1] = 0,
      t[2] = 0),
      t
  }
  function bi(t) {
      var e = t[0]
        , i = t[1]
        , s = t[2];
      return Math.hypot(e, i, s)
  }
  function _i(t, e, i) {
      var s = new fi(3);
      return s[0] = t,
      s[1] = e,
      s[2] = i,
      s
  }
  function pi(t, e) {
      return t[0] = e[0],
      t[1] = e[1],
      t[2] = e[2],
      t
  }
  function mi(t, e, i, s) {
      return t[0] = e,
      t[1] = i,
      t[2] = s,
      t
  }
  function vi(t, e, i) {
      return t[0] = e[0] + i[0],
      t[1] = e[1] + i[1],
      t[2] = e[2] + i[2],
      t
  }
  function xi(t, e, i) {
      return t[0] = e[0] - i[0],
      t[1] = e[1] - i[1],
      t[2] = e[2] - i[2],
      t
  }
  function Ti(t, e, i) {
      return t[0] = e[0] * i[0],
      t[1] = e[1] * i[1],
      t[2] = e[2] * i[2],
      t
  }
  function wi(t, e, i) {
      return t[0] = Math.min(e[0], i[0]),
      t[1] = Math.min(e[1], i[1]),
      t[2] = Math.min(e[2], i[2]),
      t
  }
  function yi(t, e, i) {
      return t[0] = Math.max(e[0], i[0]),
      t[1] = Math.max(e[1], i[1]),
      t[2] = Math.max(e[2], i[2]),
      t
  }
  function Ai(t, e, i) {
      return t[0] = e[0] * i,
      t[1] = e[1] * i,
      t[2] = e[2] * i,
      t
  }
  function Ei(t, e, i, s) {
      return t[0] = e[0] + i[0] * s,
      t[1] = e[1] + i[1] * s,
      t[2] = e[2] + i[2] * s,
      t
  }
  function Ci(t) {
      var e = t[0]
        , i = t[1]
        , s = t[2];
      return e * e + i * i + s * s
  }
  function Mi(t, e) {
      return t[0] = -e[0],
      t[1] = -e[1],
      t[2] = -e[2],
      t
  }
  function ki(t, e) {
      var i = e[0]
        , s = e[1]
        , r = e[2]
        , n = i * i + s * s + r * r;
      return n > 0 && (n = 1 / Math.sqrt(n)),
      t[0] = e[0] * n,
      t[1] = e[1] * n,
      t[2] = e[2] * n,
      t
  }
  function Fi(t, e) {
      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
  }
  function Si(t, e, i) {
      var s = e[0]
        , r = e[1]
        , n = e[2]
        , a = i[0]
        , o = i[1]
        , h = i[2];
      return t[0] = r * h - n * o,
      t[1] = n * a - s * h,
      t[2] = s * o - r * a,
      t
  }
  function Di(t, e, i, s) {
      var r = e[0]
        , n = e[1]
        , a = e[2];
      return t[0] = r + s * (i[0] - r),
      t[1] = n + s * (i[1] - n),
      t[2] = a + s * (i[2] - a),
      t
  }
  function Ii(t, e, i) {
      var s = e[0]
        , r = e[1]
        , n = e[2]
        , a = i[3] * s + i[7] * r + i[11] * n + i[15];
      return a = a || 1,
      t[0] = (i[0] * s + i[4] * r + i[8] * n + i[12]) / a,
      t[1] = (i[1] * s + i[5] * r + i[9] * n + i[13]) / a,
      t[2] = (i[2] * s + i[6] * r + i[10] * n + i[14]) / a,
      t
  }
  function Ri(t, e, i) {
      var s = e[0]
        , r = e[1]
        , n = e[2];
      return t[0] = s * i[0] + r * i[3] + n * i[6],
      t[1] = s * i[1] + r * i[4] + n * i[7],
      t[2] = s * i[2] + r * i[5] + n * i[8],
      t
  }
  Math.hypot || (Math.hypot = function() {
      for (var t = 0, e = arguments.length; e--; )
          t += arguments[e] * arguments[e];
      return Math.sqrt(t)
  }
  );
  var Ui, Oi = xi, Pi = bi;
  Ui = gi();
  function Bi() {
      var t = new fi(16);
      return fi != Float32Array && (t[1] = 0,
      t[2] = 0,
      t[3] = 0,
      t[4] = 0,
      t[6] = 0,
      t[7] = 0,
      t[8] = 0,
      t[9] = 0,
      t[11] = 0,
      t[12] = 0,
      t[13] = 0,
      t[14] = 0),
      t[0] = 1,
      t[5] = 1,
      t[10] = 1,
      t[15] = 1,
      t
  }
  function zi(t, e) {
      return t[0] = e[0],
      t[1] = e[1],
      t[2] = e[2],
      t[3] = e[3],
      t[4] = e[4],
      t[5] = e[5],
      t[6] = e[6],
      t[7] = e[7],
      t[8] = e[8],
      t[9] = e[9],
      t[10] = e[10],
      t[11] = e[11],
      t[12] = e[12],
      t[13] = e[13],
      t[14] = e[14],
      t[15] = e[15],
      t
  }
  function Ni(t, e, i, s, r, n, a, o, h, l, u, c, d, f, g, b) {
      var _ = new fi(16);
      return _[0] = t,
      _[1] = e,
      _[2] = i,
      _[3] = s,
      _[4] = r,
      _[5] = n,
      _[6] = a,
      _[7] = o,
      _[8] = h,
      _[9] = l,
      _[10] = u,
      _[11] = c,
      _[12] = d,
      _[13] = f,
      _[14] = g,
      _[15] = b,
      _
  }
  function Gi(t) {
      return t[0] = 1,
      t[1] = 0,
      t[2] = 0,
      t[3] = 0,
      t[4] = 0,
      t[5] = 1,
      t[6] = 0,
      t[7] = 0,
      t[8] = 0,
      t[9] = 0,
      t[10] = 1,
      t[11] = 0,
      t[12] = 0,
      t[13] = 0,
      t[14] = 0,
      t[15] = 1,
      t
  }
  function ji(t, e) {
      if (t === e) {
          var i = e[1]
            , s = e[2]
            , r = e[3]
            , n = e[6]
            , a = e[7]
            , o = e[11];
          t[1] = e[4],
          t[2] = e[8],
          t[3] = e[12],
          t[4] = i,
          t[6] = e[9],
          t[7] = e[13],
          t[8] = s,
          t[9] = n,
          t[11] = e[14],
          t[12] = r,
          t[13] = a,
          t[14] = o
      } else
          t[0] = e[0],
          t[1] = e[4],
          t[2] = e[8],
          t[3] = e[12],
          t[4] = e[1],
          t[5] = e[5],
          t[6] = e[9],
          t[7] = e[13],
          t[8] = e[2],
          t[9] = e[6],
          t[10] = e[10],
          t[11] = e[14],
          t[12] = e[3],
          t[13] = e[7],
          t[14] = e[11],
          t[15] = e[15];
      return t
  }
  function Li(t, e) {
      var i = e[0]
        , s = e[1]
        , r = e[2]
        , n = e[3]
        , a = e[4]
        , o = e[5]
        , h = e[6]
        , l = e[7]
        , u = e[8]
        , c = e[9]
        , d = e[10]
        , f = e[11]
        , g = e[12]
        , b = e[13]
        , _ = e[14]
        , p = e[15]
        , m = i * o - s * a
        , v = i * h - r * a
        , x = i * l - n * a
        , T = s * h - r * o
        , w = s * l - n * o
        , y = r * l - n * h
        , A = u * b - c * g
        , E = u * _ - d * g
        , C = u * p - f * g
        , M = c * _ - d * b
        , k = c * p - f * b
        , F = d * p - f * _
        , S = m * F - v * k + x * M + T * C - w * E + y * A;
      return S ? (S = 1 / S,
      t[0] = (o * F - h * k + l * M) * S,
      t[1] = (r * k - s * F - n * M) * S,
      t[2] = (b * y - _ * w + p * T) * S,
      t[3] = (d * w - c * y - f * T) * S,
      t[4] = (h * C - a * F - l * E) * S,
      t[5] = (i * F - r * C + n * E) * S,
      t[6] = (_ * x - g * y - p * v) * S,
      t[7] = (u * y - d * x + f * v) * S,
      t[8] = (a * k - o * C + l * A) * S,
      t[9] = (s * C - i * k - n * A) * S,
      t[10] = (g * w - b * x + p * m) * S,
      t[11] = (c * x - u * w - f * m) * S,
      t[12] = (o * E - a * M - h * A) * S,
      t[13] = (i * M - s * E + r * A) * S,
      t[14] = (b * v - g * T - _ * m) * S,
      t[15] = (u * T - c * v + d * m) * S,
      t) : null
  }
  function Hi(t, e, i) {
      var s = e[0]
        , r = e[1]
        , n = e[2]
        , a = e[3]
        , o = e[4]
        , h = e[5]
        , l = e[6]
        , u = e[7]
        , c = e[8]
        , d = e[9]
        , f = e[10]
        , g = e[11]
        , b = e[12]
        , _ = e[13]
        , p = e[14]
        , m = e[15]
        , v = i[0]
        , x = i[1]
        , T = i[2]
        , w = i[3];
      return t[0] = v * s + x * o + T * c + w * b,
      t[1] = v * r + x * h + T * d + w * _,
      t[2] = v * n + x * l + T * f + w * p,
      t[3] = v * a + x * u + T * g + w * m,
      v = i[4],
      x = i[5],
      T = i[6],
      w = i[7],
      t[4] = v * s + x * o + T * c + w * b,
      t[5] = v * r + x * h + T * d + w * _,
      t[6] = v * n + x * l + T * f + w * p,
      t[7] = v * a + x * u + T * g + w * m,
      v = i[8],
      x = i[9],
      T = i[10],
      w = i[11],
      t[8] = v * s + x * o + T * c + w * b,
      t[9] = v * r + x * h + T * d + w * _,
      t[10] = v * n + x * l + T * f + w * p,
      t[11] = v * a + x * u + T * g + w * m,
      v = i[12],
      x = i[13],
      T = i[14],
      w = i[15],
      t[12] = v * s + x * o + T * c + w * b,
      t[13] = v * r + x * h + T * d + w * _,
      t[14] = v * n + x * l + T * f + w * p,
      t[15] = v * a + x * u + T * g + w * m,
      t
  }
  function Vi(t, e, i) {
      var s, r, n, a, o, h, l, u, c, d, f, g, b = i[0], _ = i[1], p = i[2];
      return e === t ? (t[12] = e[0] * b + e[4] * _ + e[8] * p + e[12],
      t[13] = e[1] * b + e[5] * _ + e[9] * p + e[13],
      t[14] = e[2] * b + e[6] * _ + e[10] * p + e[14],
      t[15] = e[3] * b + e[7] * _ + e[11] * p + e[15]) : (s = e[0],
      r = e[1],
      n = e[2],
      a = e[3],
      o = e[4],
      h = e[5],
      l = e[6],
      u = e[7],
      c = e[8],
      d = e[9],
      f = e[10],
      g = e[11],
      t[0] = s,
      t[1] = r,
      t[2] = n,
      t[3] = a,
      t[4] = o,
      t[5] = h,
      t[6] = l,
      t[7] = u,
      t[8] = c,
      t[9] = d,
      t[10] = f,
      t[11] = g,
      t[12] = s * b + o * _ + c * p + e[12],
      t[13] = r * b + h * _ + d * p + e[13],
      t[14] = n * b + l * _ + f * p + e[14],
      t[15] = a * b + u * _ + g * p + e[15]),
      t
  }
  function qi(t, e, i) {
      var s = i[0]
        , r = i[1]
        , n = i[2];
      return t[0] = e[0] * s,
      t[1] = e[1] * s,
      t[2] = e[2] * s,
      t[3] = e[3] * s,
      t[4] = e[4] * r,
      t[5] = e[5] * r,
      t[6] = e[6] * r,
      t[7] = e[7] * r,
      t[8] = e[8] * n,
      t[9] = e[9] * n,
      t[10] = e[10] * n,
      t[11] = e[11] * n,
      t[12] = e[12],
      t[13] = e[13],
      t[14] = e[14],
      t[15] = e[15],
      t
  }
  function Xi(t, e, i) {
      var s = Math.sin(i)
        , r = Math.cos(i)
        , n = e[4]
        , a = e[5]
        , o = e[6]
        , h = e[7]
        , l = e[8]
        , u = e[9]
        , c = e[10]
        , d = e[11];
      return e !== t && (t[0] = e[0],
      t[1] = e[1],
      t[2] = e[2],
      t[3] = e[3],
      t[12] = e[12],
      t[13] = e[13],
      t[14] = e[14],
      t[15] = e[15]),
      t[4] = n * r + l * s,
      t[5] = a * r + u * s,
      t[6] = o * r + c * s,
      t[7] = h * r + d * s,
      t[8] = l * r - n * s,
      t[9] = u * r - a * s,
      t[10] = c * r - o * s,
      t[11] = d * r - h * s,
      t
  }
  function Wi(t, e, i) {
      var s = Math.sin(i)
        , r = Math.cos(i)
        , n = e[0]
        , a = e[1]
        , o = e[2]
        , h = e[3]
        , l = e[4]
        , u = e[5]
        , c = e[6]
        , d = e[7];
      return e !== t && (t[8] = e[8],
      t[9] = e[9],
      t[10] = e[10],
      t[11] = e[11],
      t[12] = e[12],
      t[13] = e[13],
      t[14] = e[14],
      t[15] = e[15]),
      t[0] = n * r + l * s,
      t[1] = a * r + u * s,
      t[2] = o * r + c * s,
      t[3] = h * r + d * s,
      t[4] = l * r - n * s,
      t[5] = u * r - a * s,
      t[6] = c * r - o * s,
      t[7] = d * r - h * s,
      t
  }
  function Zi(t, e, i) {
      var s = e[0]
        , r = e[1]
        , n = e[2]
        , a = e[3]
        , o = s + s
        , h = r + r
        , l = n + n
        , u = s * o
        , c = s * h
        , d = s * l
        , f = r * h
        , g = r * l
        , b = n * l
        , _ = a * o
        , p = a * h
        , m = a * l;
      return t[0] = 1 - (f + b),
      t[1] = c + m,
      t[2] = d - p,
      t[3] = 0,
      t[4] = c - m,
      t[5] = 1 - (u + b),
      t[6] = g + _,
      t[7] = 0,
      t[8] = d + p,
      t[9] = g - _,
      t[10] = 1 - (u + f),
      t[11] = 0,
      t[12] = i[0],
      t[13] = i[1],
      t[14] = i[2],
      t[15] = 1,
      t
  }
  function Ki(t, e) {
      return t[0] = e[12],
      t[1] = e[13],
      t[2] = e[14],
      t
  }
  function Yi(t, e) {
      var i = e[0]
        , s = e[1]
        , r = e[2]
        , n = e[4]
        , a = e[5]
        , o = e[6]
        , h = e[8]
        , l = e[9]
        , u = e[10];
      return t[0] = Math.hypot(i, s, r),
      t[1] = Math.hypot(n, a, o),
      t[2] = Math.hypot(h, l, u),
      t
  }
  var Ji = function(t, e, i, s, r) {
      var n, a = 1 / Math.tan(e / 2);
      return t[0] = a / i,
      t[1] = 0,
      t[2] = 0,
      t[3] = 0,
      t[4] = 0,
      t[5] = a,
      t[6] = 0,
      t[7] = 0,
      t[8] = 0,
      t[9] = 0,
      t[11] = -1,
      t[12] = 0,
      t[13] = 0,
      t[15] = 0,
      null != r && r !== 1 / 0 ? (n = 1 / (s - r),
      t[10] = (r + s) * n,
      t[14] = 2 * r * s * n) : (t[10] = -1,
      t[14] = -2 * s),
      t
  };
  var Qi = Hi;
  const $i = {
      2: "Wowhead",
      3: "LolKing",
      6: "HeroKing",
      7: "DestinyDB"
  };
  class ts {
      constructor(t) {
          if (!t.type || !$i[t.type])
              throw "Viewer error: Bad viewer type given";
          if (!t.container)
              throw "Viewer error: Bad container given";
          if (!t.aspect)
              throw "Viewer error: Bad aspect ratio given";
          if (!t.contentPath)
              throw "Viewer error: No content path given";
          console.log("Creating viewer with options", t),
          this.type = t.type,
          this.container = t.container,
          this.aspect = parseFloat(t.aspect),
          this.renderer = null,
          this.options = t;
          const e = this.container.width()
            , i = Math.round(e / this.aspect);
          this.init(e, i)
      }
      destroy() {
          this.renderer && this.renderer.destroy(),
          this.options = null,
          this.container = null
      }
      init(t, e) {
          if (void 0 !== typeof window.Uint8Array && void 0 !== typeof window.DataView)
              try {
                  const t = document.createElement("canvas");
                  if (!(t.getContext("webgl", {
                      alpha: !1
                  }) || t.getContext("experimental-webgl", {
                      alpha: !1
                  })))
                      return void console.log("viewer init failed")
              } catch (t) {
                  return void console.log("viewer init failed")
              }
          this.mode = 1,
          this.renderer = new Ll(this),
          this.renderer.resize(t, e),
          this.renderer.init()
      }
      setAdaptiveMode(t) {
          this.renderer.setAdaptiveMode(t)
      }
      setZoom(t) {
          this.renderer.zoom.target = t
      }
      setOffset(t, e) {
          this.renderer.setTranslation(t, e, 0)
      }
      setFullscreen(t) {
          t ? ts.requestFullscreen(this.renderer.canvas[0]) : ts.exitFullscreen()
      }
      method(t, e) {
          return void 0 === e && (e = []),
          this.renderer ? this.renderer.method(t, [].concat(e)) : null
      }
      option(t, e) {
          return void 0 !== e && (this.options[t] = e),
          this.options[t]
      }
      static isFullscreen() {
          return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
      }
      static requestFullscreen(t) {
          document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || (t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.msRequestFullscreen && t.msRequestFullscreen())
      }
      static exitFullscreen() {
          (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) && (document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen())
      }
  }
  const es = ts;
  const is = class {
      constructor(t, e, i) {
          this.dc = t,
          this.ba = e,
          this.g = i,
          this.e = !1,
          this.f = t.createBuffer(),
          this.ba = 0
      }
      b(t) {
          const e = this.dc;
          e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.f),
          !this.e || this.ba < t.byteLength ? (e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, this.g ? e.DYNAMIC_DRAW : e.STATIC_DRAW),
          this.ba = t.byteLength,
          this.e = !0) : e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t),
          e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)
      }
      a() {
          return this.ba
      }
      d() {
          const t = this.dc;
          t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.f)
      }
      c() {
          const t = this.dc;
          t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)
      }
  }
  ;
  const ss = class {
      constructor(t, e, i) {
          this.e = t,
          this.f = e,
          this.dc = i,
          this.ba = !1,
          this.g = t.createBuffer(),
          this.f = 0
      }
      d() {
          const t = this.e;
          t.bindBuffer(t.ARRAY_BUFFER, this.g)
      }
      c() {
          const t = this.e;
          t.bindBuffer(t.ARRAY_BUFFER, null)
      }
      b(t) {
          const e = this.e;
          e.bindBuffer(e.ARRAY_BUFFER, this.g),
          !this.ba || this.f < t.byteLength ? (e.bufferData(e.ARRAY_BUFFER, t, this.dc ? e.DYNAMIC_DRAW : e.STATIC_DRAW),
          this.ba = !0,
          this.f = t.byteLength) : e.bufferSubData(e.ARRAY_BUFFER, 0, t),
          e.bindBuffer(e.ARRAY_BUFFER, null)
      }
      a() {
          return this.f
      }
  }
  ;
  var rs;
  !function(t) {
      t[t.GFLOAT = 0] = "GFLOAT",
      t[t.GUNSIGNED_BYTE = 1] = "GUNSIGNED_BYTE"
  }(rs || (rs = {}));
  class ns {
      constructor(t, e, i, s, r, n) {
          this.a = t,
          this.b = e,
          this.c = i,
          this.f = s,
          this.e = r,
          this.d = n
      }
  }
  function as(t, e) {
      switch (e) {
      case rs.GFLOAT:
          return t.FLOAT;
      case rs.GUNSIGNED_BYTE:
          return t.UNSIGNED_BYTE
      }
  }
  const os = class {
      constructor(t, e) {
          this.e = t,
          this.ba = e,
          this.dc = null,
          this.f = [],
          this.dc = e.createVertexArrayOES()
      }
      c(t) {
          this.e;
          this.a(),
          t.d(),
          this.b(),
          this.f.push(t)
      }
      d(t, e) {
          const i = this.e;
          this.a(),
          t.d();
          for (const t of e)
              i.enableVertexAttribArray(t.a),
              i.vertexAttribPointer(t.a, t.b, as(i, t.c), t.f, t.e, t.d);
          this.b(),
          this.f.push(t)
      }
      a() {
          this.ba.bindVertexArrayOES(this.dc)
      }
      b() {
          this.ba.bindVertexArrayOES(null)
      }
  }
  ;
  const hs = class {
      constructor(t, e) {
          this.f = t,
          this.ba = e,
          this.e = []
      }
      c(t) {
          this.dc = t
      }
      d(t, e) {
          this.e.push({
              buffer: t,
              bindings: e
          })
      }
      a() {
          const t = this.f;
          this.dc.d();
          const e = this.ba.e();
          for (const e of this.e) {
              e.a.d();
              for (const i of e.b)
                  this.ba.a(i.a),
                  t.vertexAttribPointer(i.a, i.b, as(t, i.c), i.f, i.e, i.d)
          }
          this.ba.b(e)
      }
      b() {}
  }
  ;
  class ls {
  }
  class us {
      constructor(t, e, i, s) {
          this.b = t,
          this.d = e,
          this.c = i,
          this.a = s
      }
  }
  class cs {
      constructor(t, e) {
          this.b = t,
          this.a = e
      }
  }
  class ds {
      constructor(t, e) {
          this.b = t,
          this.a = e
      }
  }
  class fs extends ls {
  }
  const gs = class extends fs {
      constructor(t, e, i, s) {
          super(),
          this.e = t,
          this.cba = e,
          this.d = i,
          this.ba = s
      }
      b() {
          return this.d.b
      }
      a(t) {
          const e = this.d;
          t.c(this.cba),
          t.h(e.b),
          t.a(e.f),
          t.d(e.a),
          t.f(e.e),
          t.b(e.c),
          t.e(e.d),
          Ze(this.cba.c(), this.ba)
      }
  }
  ;
  const bs = class {
      constructor(t, e, i, s) {
          if (this.ba = t,
          this.d = Qe(t, [i, s], Object.keys(e), null),
          !this.d)
              throw "Failed to create program"
      }
      a() {
          this.ba.useProgram(this.d.program)
      }
      c() {
          return this.d
      }
  }
  ;
  class _s {
      static d(t) {
          const e = 32767 & t;
          return e < ps.length ? ps[e] : (WH.debug("Unknown shader effect:", e),
          ["PS_Combiners_Opaque", "VS_Diffuse_T1"])
      }
      static a(t, e) {
          let i = "";
          if (-1e3 == t && 3 == e)
              return "Skin";
          if (32768 & t)
              return _s.d(t)[0];
          if (1 == e)
              i = 112 & t ? "PS_Combiners_Mod" : "PS_Combiners_Opaque";
          else {
              i = (112 & t ? "PS_Combiners_Mod" : "PS_Combiners_Opaque") + "_" + (112 & t ? ["Opaque", "Mod", "Mod", "Add", "Mod2x", "Mod", "Mod2xNA", "AddNA"] : ["Opaque", "Mod", "Mod", "AddAlpha", "Mod2x", "Mod", "Mod2xNA", "AddAlpha"])[7 & t]
          }
          return i
      }
      static f(t, e) {
          let i = "";
          if (-1e3 == t && 3 == e)
              i = "T1_T1_T1";
          else {
              if (32768 & t)
                  return _s.d(t)[1];
              i = 1 == e ? 128 & t ? "Env" : 16384 & t ? "T2" : "T1" : 128 & t ? 8 & t ? "Env_Env" : "Env_T1" : 8 & t ? "T1_Env" : 16384 & t ? "T1_T2" : "T1_T1"
          }
          return "VS_Diffuse_" + i
      }
      static e(t, e, i) {
          const s = _s.a(t, e)
            , r = _s.f(t, e)
            , n = "Wow." + r + "_" + s;
          if (ui._GetProgram(n))
              return {
                  name: n
              };
          const a = {
              shaders: [_s.c(r, i), _s.b(r, s, !1)],
              attributes: {
                  position: "aPosition",
                  normal: "aNormal",
                  texcoord0: "aTexCoord0",
                  texcoord1: "aTexCoord1"
              }
          };
          return ui.RegisterProgram(n, a),
          {
              name: n
          }
      }
      static h(t) {
          const e = {}
            , i = {
              texcoord1: function(t, e) {
                  t.INPUT_TEXCOORD1 = "aTexCoord" + e
              }
          };
          for (let s in t.options) {
              const r = t.options[s];
              i[s](e, r)
          }
          return {
              name: "Wow." + t.name,
              config: e
          }
      }
      static g(t) {
          var e = "";
          if (e += "lTexCoord1 = (uTextureMatrix1 * vec4(vTexCoord1, 0, 1)).st;\n",
          e += "lTexCoord2 = (uTextureMatrix2 * vec4(vTexCoord2, 0, 1)).st;\n",
          "VS" === t.slice(0, 2)) {
              let i = (t = t.slice(3)).split("_")
                , s = i[0];
              if ("Diffuse" === s || "Color" === s) {
                  e = "",
                  i.splice(0, 1);
                  let s = {
                      T1: ["uTextureMatrix1", "vTexCoord1"],
                      T2: ["uTextureMatrix2", "vTexCoord2"],
                      T3: ["", "aTexCoord2"],
                      Env: ["", "texEnv"]
                  }
                    , r = 1;
                  for (let n in i)
                      s[i[n]] ? (s[i[n]][0] && "texEnv" != s[i[n]][1] ? e += "lTexCoord" + r + " = (" + s[i[n]][0] + " * vec4(" + s[i[n]][1] + ", 0, 1)).st;\n" : "texEnv" == s[i[n]][1] ? e += "lTexCoord" + r + " = texEnv;\n" : e += "lTexCoord" + r + " = (uTextureMatrix" + r + " * vec4(" + s[i[n]][1] + ", 0, 1)).st;\n",
                      r++) : WH.debug("Missing vertex shader def?", t)
              }
          }
          return e
      }
      static c(t, e) {
          var i;
          return "attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord0;\nattribute vec2 aTexCoord1;\nattribute vec3 aColor;\n" + ((i = {
              SKINNING: e
          }).SKINNING ? "attribute vec4 aBoneWeights;\nattribute vec4 aBones;\n" : "") + "varying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vTexCoord1;\nvarying vec2 vTexCoord2;\nuniform mat4 uModelMatrix;\nuniform mat4 uPanningMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uInvTranspViewModelMat;\nuniform mat4 uProjMatrix;\nuniform vec3 uCameraPos;\n" + (i.SKINNING ? "uniform sampler2D uBoneMatricesTex;\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\nconst float numBones = 256.0;\nmat4 getBoneMatrix(float boneNdx) {\nfloat v = (boneNdx + 0.5) / numBones;\nreturn mat4(\ntexture2D(uBoneMatricesTex, vec2(ROW0_U, v)),\ntexture2D(uBoneMatricesTex, vec2(ROW1_U, v)),\ntexture2D(uBoneMatricesTex, vec2(ROW2_U, v)),\ntexture2D(uBoneMatricesTex, vec2(ROW3_U, v))\n);\n}\nhighp mat4 transpose(in highp mat4 inMatrix) {\nhighp vec4 i0 = inMatrix[0];\nhighp vec4 i1 = inMatrix[1];\nhighp vec4 i2 = inMatrix[2];\nhighp vec4 i3 = inMatrix[3];\nhighp mat4 outMatrix = mat4(\nvec4(i0.x, i1.x, i2.x, i3.x),\nvec4(i0.y, i1.y, i2.y, i3.y),\nvec4(i0.z, i1.z, i2.z, i3.z),\nvec4(i0.w, i1.w, i2.w, i3.w)\n);\nreturn outMatrix;\n}\nmat4 inverse(mat4 m) {\nfloat\na00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\na10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\na20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\na30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\nb00 = a00 * a11 - a01 * a10,\nb01 = a00 * a12 - a02 * a10,\nb02 = a00 * a13 - a03 * a10,\nb03 = a01 * a12 - a02 * a11,\nb04 = a01 * a13 - a03 * a11,\nb05 = a02 * a13 - a03 * a12,\nb06 = a20 * a31 - a21 * a30,\nb07 = a20 * a32 - a22 * a30,\nb08 = a20 * a33 - a23 * a30,\nb09 = a21 * a32 - a22 * a31,\nb10 = a21 * a33 - a23 * a31,\nb11 = a22 * a33 - a23 * a32,\ndet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\nreturn mat4(\na11 * b11 - a12 * b10 + a13 * b09,\na02 * b10 - a01 * b11 - a03 * b09,\na31 * b05 - a32 * b04 + a33 * b03,\na22 * b04 - a21 * b05 - a23 * b03,\na12 * b08 - a10 * b11 - a13 * b07,\na00 * b11 - a02 * b08 + a03 * b07,\na32 * b02 - a30 * b05 - a33 * b01,\na20 * b05 - a22 * b02 + a23 * b01,\na10 * b10 - a11 * b08 + a13 * b06,\na01 * b08 - a00 * b10 - a03 * b06,\na30 * b04 - a31 * b02 + a33 * b00,\na21 * b02 - a20 * b04 - a23 * b00,\na11 * b07 - a10 * b09 - a12 * b06,\na00 * b09 - a01 * b07 + a02 * b06,\na31 * b01 - a30 * b03 - a32 * b00,\na20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n" : "") + "void main(void) {\nmat4 boneTransformMat =  mat4(1.0);\n" + (i.SKINNING ? "if (length(aBoneWeights) > 0.0) {\nboneTransformMat =  mat4(0.0);\nfor (int i = 0; i < 4; i++) {\nboneTransformMat += getBoneMatrix(aBones[i]) * aBoneWeights[i];\n}\n}\nmat4 viewModelMat = uViewMatrix * uModelMatrix * boneTransformMat;\nmat4 invTranspViewModelMat = transpose(inverse(viewModelMat));\n" : "mat4 viewModelMat = uViewMatrix * uModelMatrix;\nmat4 invTranspViewModelMat = uInvTranspViewModelMat;\n") + "vec4 pos = viewModelMat * vec4(aPosition, 1);\nvPosition = pos.rgb;\ngl_Position = uProjMatrix * pos;\nvTexCoord1 = aTexCoord0;\nvTexCoord2 = aTexCoord1;\nvNormal = normalize((invTranspViewModelMat * vec4(aNormal, 0.0)).xyz);\n}\n"
      }
      static b(t, e, i) {
          let s = ms[e];
          s || (WH.debug("Missing pixel shader def", e),
          s = ms[e = "PS_Combiners_Opaque_Mod"]);
          let r = "\t\t" + s.slice(1, s.length).join("\n\t\t");
          for (let t = 0; t < s[0]; t++) {
              let e = t + 1;
              r = "vec4 tex" + t + " = texture2D(uTexture" + e + ", lTexCoord" + e + ".st);\n" + r
          }
          let n = this.g(t);
          var a;
          return "precision mediump float;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vTexCoord1;\nvarying vec2 vTexCoord2;\nvarying vec2 vTexCoord3;\nvarying vec2 vTexCoord4;\nuniform bool uHasAlpha;\nuniform bool uHasSpecEmiss;\nuniform bool uHasEmissiveGlowing;\nuniform int uBlendMode;\nuniform bool uUnlit;\nuniform vec4 uColor;\nuniform vec4 uAmbientColor;\nuniform vec4 uDiffuseColor;\nuniform vec4 uPrimaryColor;\nuniform vec4 uSecondaryColor;\nuniform vec3 uLightDir1;\nuniform vec3 uLightDir2;\nuniform vec3 uLightDir3;\nuniform mat4 uTextureMatrix1;\nuniform mat4 uTextureMatrix2;\nuniform mat4 uTextureMatrix3;\nuniform mat4 uTextureMatrix4;\nuniform sampler2D uTexture1;\nuniform sampler2D uTexture2;\nuniform sampler2D uTexture3;\nuniform sampler2D uTexture4;\nuniform sampler2D uAlpha;\nuniform vec4 uTexSampleAlpha;\n" + ((a = {
              EXCERPT_TEX_COORD: n,
              EXCERPT_BASE: r,
              GRADIENT: i
          }).GRADIENT ? "uniform vec4 u_gradGradientColors_0;\nuniform vec4 u_gradGradientColors_1;\nuniform vec4 u_gradGradientColors_2;\nuniform vec4 u_gradEdgeColor;\nuniform vec4 u_gradBoundingBox;\nuniform vec4 u_gradUpVec;\nuniform vec4 u_gradFlags;\nuniform vec4 u_mulLum_OpaqMat;\n" : "") + "vec2 sphereMap(vec3 vertex, vec3 normal) {\nvec3 normPos = (normalize(vertex.xyz));\nvec3 reflection = reflect(normPos, normalize(normal));\nreflection = vec3(reflection.x, reflection.y, reflection.z + 1.0);\nvec2 texCoord = ((normalize(reflection).xy * 0.5) + vec2(0.5));\nreturn texCoord;\n}\nvoid main(void) {\nvec2 lTexCoord1 = vec2(0.0);\nvec2 lTexCoord2 = vec2(0.0);\nvec2 lTexCoord3 = vec2(0.0);\nvec4 _output = vec4(1.0);\nvec4 _input = uColor;\nvec3 _specular = vec3(0.0);\nvec2 texEnv = sphereMap(vPosition.xyz,normalize(vNormal.xyz));\n" + (a.EXCERPT_TEX_COORD ? a.EXCERPT_TEX_COORD : "") + (a.EXCERPT_BASE ? a.EXCERPT_BASE : "") + "_output.a = _output.a * uDiffuseColor.a;\nif (uBlendMode == 13) {\n_output.a = _output.a * _input.a;\n} else if (uBlendMode == 1) {\nif (_output.a < (128.0/255.0))\ndiscard;\n_output.a = _input.a;\n} else if (uBlendMode == 0) {\n_output.a = _input.a;\n} else {\n_output.a = _output.a * _input.a;\n}\nif (!uUnlit) {\nvec4 litColor = uAmbientColor;\nvec3 normal = normalize(vNormal);\nfloat dp = max(0.0, dot(normal, uLightDir1));\nlitColor += uPrimaryColor * dp;\ndp = max(0.0, dot(normal, uLightDir2));\nlitColor += uSecondaryColor * dp;\ndp = max(0.0, dot(normal, uLightDir3));\nlitColor += uSecondaryColor * dp;\nlitColor = clamp(litColor, vec4(0,0,0,0), vec4(1,1,1,1));\n_output.rgb *= (litColor * uDiffuseColor).rgb;\n}\n_output += vec4(_specular, 0.0);\n" + (a.GRADIENT ? "float power = u_gradEdgeColor.w;\nfloat midValue = u_gradGradientColors_2.w;\nfloat opaqueMaterial = u_mulLum_OpaqMat.y;\nfloat lum = clamp(dot(_output.xyz, vec3(0.212599993, 0.715200007, 0.0722000003)), 0.0, 1.0);\nfloat val0 = 0.0;\nfloat val1 = midValue;\nif (lum > midValue) {\nval0 = midValue;\nval1 = 1.0;\n}\nfloat lerpValue = clamp(((lum - val0) / (val1 - val0)), 0.0, 1.0);\nvec3 gradColor0 = u_gradGradientColors_0.xyz;\nvec3 gradColor1 = u_gradGradientColors_1.xyz;\nif (lum > midValue) {\ngradColor0 = u_gradGradientColors_1.xyz;\ngradColor1 = u_gradGradientColors_2.xyz;\n}\nvec3 gradientColor = mix(gradColor0, gradColor1, vec3(lerpValue));\nbool flipNormal = ((u_gradGradientColors_0.w > 0.0) && (vNormal.z > 0.0));\nvec3 normal = flipNormal ? -vNormal.xyz : vNormal.xyz;\nvec2 term = vec2(dot(-(vPosition.xyz), normal), dot(normalize(-(vPosition.xyz)), (normal * vec3(0.05, 0.05, 1.0))));\nvec2 invTerm = (vec2(1.0) - clamp(term, 0.0, 1.0));\nvec2 f = (invTerm * invTerm);\nfloat fresnel_rim = pow((f.x + f.y), power);\nbool disableHeightFade = bool(u_gradFlags.x);\nfloat visMod = 0.0;\nvec4 res = _output;\nvec3 distVecTest = vec3(0,0,0);\nif (!(disableHeightFade))\n{\nvec3 distVec = (vPosition - u_gradBoundingBox.xyz);\nfloat _dot = dot(distVec, u_gradUpVec.xyz);\nfloat relHeight = (_dot * u_gradBoundingBox.w);\nbool invertHeightFade = bool(u_gradFlags.w);\ndistVecTest = vec3(relHeight);\nrelHeight = invertHeightFade ? clamp((1.0 - relHeight), 0.0, 1.0) : relHeight;\nfloat visMod = clamp((relHeight * 1.66666663), 0.0, 0.899999976);\nvisMod = (visMod * visMod);\nres = vec4(_output.r, _output.g, _output.b, (_output.w * visMod));\n}\nvec3 lerp = mix(gradientColor, u_gradEdgeColor.xyz, vec3(fresnel_rim));\nfloat multiplyLum = u_mulLum_OpaqMat.x;\nif (bool(multiplyLum))\n{\nres = vec4(lerp.xyz, (res.w * lum));\n}\nelse\n{\nres = vec4(lerp.xyz, res.w);\n}\n_output = mix(_output, res, vec4(u_gradFlags.y));\n_output = vec4(_output.xyz, res.a * _output.a);\n" : "") + "gl_FragColor = _output;\n}\n"
      }
  }
  const ps = [["PS_Combiners_Opaque_Mod2xNA_Alpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_AddAlpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_AddAlpha_Alpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_Mod2xNA_Alpha_Add", "VS_Diffuse_T1_Env_T1", "HS_T1_T2_T3", "DS_T1_T2_T3"], ["PS_Combiners_Mod_AddAlpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_AddAlpha", "VS_Diffuse_T1_T1", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_AddAlpha", "VS_Diffuse_T1_T1", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_AddAlpha_Alpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_Alpha_Alpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_Mod2xNA_Alpha_3s", "VS_Diffuse_T1_Env_T1", "HS_T1_T2_T3", "DS_T1_T2_T3"], ["PS_Combiners_Opaque_AddAlpha_Wgt", "VS_Diffuse_T1_T1", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_Add_Alpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_ModNA_Alpha", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_AddAlpha_Wgt", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_AddAlpha_Wgt", "VS_Diffuse_T1_T1", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_AddAlpha_Wgt", "VS_Diffuse_T1_T2", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_Mod_Add_Wgt", "VS_Diffuse_T1_Env", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_Mod2xNA_Alpha_UnshAlpha", "VS_Diffuse_T1_Env_T1", "HS_T1_T2_T3", "DS_T1_T2_T3"], ["PS_Combiners_Mod_Dual_Crossfade", "VS_Diffuse_T1", "HS_T1", "DS_T1"], ["PS_Combiners_Mod_Depth", "VS_Diffuse_EdgeFade_T1", "HS_T1", "DS_T1"], ["PS_Combiners_Opaque_Mod2xNA_Alpha_Alpha", "VS_Diffuse_T1_Env_T2", "HS_T1_T2_T3", "DS_T1_T2_T3"], ["PS_Combiners_Mod_Mod", "VS_Diffuse_EdgeFade_T1_T2", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_Masked_Dual_Crossfade", "VS_Diffuse_T1_T2", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_Alpha", "VS_Diffuse_T1_T1", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Opaque_Mod2xNA_Alpha_UnshAlpha", "VS_Diffuse_T1_Env_T2", "HS_T1_T2_T3", "DS_T1_T2_T3"], ["PS_Combiners_Mod_Depth", "VS_Diffuse_EdgeFade_Env", "HS_T1", "DS_T1"], ["PS_Guild", "VS_Diffuse_T1_T2_T1", "HS_T1_T2_T3", "DS_T1_T2"], ["PS_Guild_NoBorder", "VS_Diffuse_T1_T2", "HS_T1_T2", "DS_T1_T2_T3"], ["PS_Guild_Opaque", "VS_Diffuse_T1_T2_T1", "HS_T1_T2_T3", "DS_T1_T2"], ["PS_Illum", "VS_Diffuse_T1_T1", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_Mod_Mod_Const", "VS_Diffuse_T1_T2_T3", "HS_T1_T2_T3", "DS_T1_T2_T3"], ["PS_Combiners_Mod_Mod_Mod_Const", "VS_Color_T1_T2_T3", "HS_T1_T2_T3", "DS_T1_T2_T3"], ["PS_Combiners_Opaque", "VS_Diffuse_T1", "HS_T1", "DS_T1"], ["PS_Combiners_Mod_Mod2x", "VS_Diffuse_EdgeFade_T1_T2", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod", "VS_Diffuse_EdgeFade_T1", "HS_T1_T2", "DS_T1_T2"], ["PS_Combiners_Mod_Mod_Depth", "VS_Diffuse_EdgeFade_T1_T2", "HS_T1_T2", "DS_T1_T2"]]
    , ms = {
      PS_Combiners_Add: [1, "_output.rgb = _input.rgb + tex0.rgb;", "_output.a = _input.a + tex0.a;"],
      PS_Combiners_Decal: [1, "_output.rgb = mix(_input.rgb, tex0.rgb, _input.a);", "_output.a = _input.a;"],
      PS_Combiners_Fade: [1, "_output.rgb = mix(tex0.rgb, _input.rgb, _input.a);", "_output.a = _input.a;"],
      PS_Combiners_Mod: [1, "_output.rgb = _input.rgb * tex0.rgb;", "_output.a = tex0.a;"],
      PS_Combiners_Mod2x: [1, "_output.rgb = _input.rgb * tex0.rgb * 2.0;", "_output.a = tex0.a * 2.0;"],
      PS_Combiners_Opaque: [1, "_output.rgb = _input.rgb * tex0.rgb;", "_output.a = 1.0;"],
      PS_Combiners_Add_Add: [2, "_output.rgb = (_input.rgb + tex0.rgb) + tex1.rgb;", "_output.a = (_input.a + tex0.a) + tex1.a;"],
      PS_Combiners_Add_Mod: [2, "_output.rgb = (_input.rgb + tex0.rgb) * tex1.rgb;", "_output.a = (_input.a + tex0.a) * tex1.a;"],
      PS_Combiners_Add_Mod2x: [2, "_output.rgb = (_input.rgb + tex0.rgb) * tex1.rgb * 2.0;", "_output.a = (_input.a + tex0.a) * tex1.a * 2.0;"],
      PS_Combiners_Add_Opaque: [2, "_output.rgb = (_input.rgb + tex0.rgb) * tex1.rgb;", "_output.a = _input.a + tex0.a;"],
      PS_Combiners_Mod_AddNA: [2, "_output.rgb = (_input.rgb * tex0.rgb);", "_output.a = tex0.a;", "_specular = tex1.rgb;"],
      PS_Combiners_Mod_Mod: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb;", "_output.a = tex0.a * tex1.a;"],
      PS_Combiners_Mod_Mod2x: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb * 2.0;", "_output.a = tex0.a * tex1.a * 2.0;"],
      PS_Combiners_Mod_Add: [2, "_output.rgb = (_input.rgb * tex0.rgb);", "_output.a = tex0.a + tex1.a;", "_specular = tex1.rgb;"],
      PS_Combiners_Mod_Mod2xNA: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb * 2.0;", "_output.a = tex0.a;"],
      PS_Combiners_Mod_Opaque: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb;", "_output.a = tex0.a;"],
      PS_Combiners_Mod2x_Add: [2, "_output.rgb = (_input.rgb * tex0.rgb) * 2.0 + tex1.rgb;", "_output.a = (tex0.a) * 2.0 + tex1.a;"],
      PS_Combiners_Mod2x_Mod2x: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb * 4.0;", "_output.a = (tex0.a) * tex1.a * 4.0;"],
      PS_Combiners_Mod2x_Opaque: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb * 2.0;", "_output.a = tex0.a * 2.0;"],
      PS_Combiners_Opaque_Add: [2, "_output.rgb = (_input.rgb * tex0.rgb) + tex1.rgb;", "_output.a = _input.a + tex1.a;"],
      PS_Combiners_Opaque_AddAlpha: [2, "_output.rgb = (_input.rgb * tex0.rgb);", "_specular = (tex1.rgb * tex1.a);"],
      PS_Combiners_Opaque_AddAlpha_Wgt: [2, "_output.rgb = (_input.rgb * tex0.rgb);", "_specular = (tex1.rgb * tex1.a) * uTexSampleAlpha.g;"],
      PS_Combiners_Opaque_AddAlpha_Alpha: [2, "_output.rgb = (_input.rgb * tex0.rgb);", "_specular = (tex1.rgb * tex1.a * (1.0 - tex0.a));"],
      PS_Combiners_Opaque_AddNA: [2, "_output.rgb = (_input.rgb * tex0.rgb) + tex1.rgb;", "_output.a = _input.a;"],
      PS_Combiners_Opaque_Mod: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb;", "_output.a = tex1.a;"],
      PS_Combiners_Opaque_Mod2x: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb * 2.0;", "_output.a = tex1.a * 2.0;"],
      PS_Combiners_Opaque_Mod2xNA: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb * 2.0;", ""],
      PS_Combiners_Opaque_Mod2xNA_Alpha: [2, "_output.rgb = _input.rgb * mix(tex0.rgb * tex1.rgb * 2.0, tex0.rgb, vec3(tex0.a));", ""],
      PS_Combiners_Opaque_Opaque: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb;", ""],
      PS_Combiners_Opaque_Mod2xNA_Alpha_Add: [3, "_output.rgb = _input.rgb * mix(tex0.rgb * tex1.rgb * 2.0, tex0.rgb, vec3(tex0.a));", "_specular = tex2.rgb * tex2.a * uTexSampleAlpha.b;"],
      PS_Combiners_Mod_Mod_Mod_Const: [3, "_output.rgb = _input.rgb * (tex0 * tex1 * tex2).rgb;", "_output.a = (tex0 * tex1 * tex2).a;"],
      PS_Combiners_Mod_AddAlpha: [2, "_output.rgb = (_input.rgb * tex0.rgb);", "_output.a = tex0.a;", "_specular = tex1.rgb * tex1.a;"],
      PS_Combiners_Mod_AddAlpha_Wgt: [2, "_output.rgb = (_input.rgb * tex0.rgb);", "_output.a = tex0.a;", "_specular = tex1.rgb * tex1.a * uTexSampleAlpha.g;"],
      PS_Combiners_Mod_AddAlpha_Alpha: [2, "_output.rgb = _input.rgb * tex0.rgb;", "_output.a = (tex0.a + tex1.a * (0.3 * tex1.r + 0.59 * tex1.g + 0.11 * tex1.b));", "_specular = tex1.rgb * tex1.a * (1.0 - tex0.a);"],
      PS_Combiners_Opaque_Mod_Add_Wgt: [2, "_output.rgb = _input.rgb * mix(tex0.rgb, tex1.rgb, vec3(tex1.a));", "_specular = (tex0.rgb * tex0.a) * uTexSampleAlpha.r;"],
      PS_Guild: [3, "_output.rgb = _input.rgb * mix(tex0.rgb * mix(vec3(1.0, 1.0, 1.0), tex1.rgb * vec3(1.0, 1.0, 1.0), vec3(tex1.a)), tex2.rgb * vec3(1.0, 1.0, 1.0), vec3(tex2.a));", "_output.a = tex0.a;"],
      PS_Guild_Opaque: [3, "_output.rgb = _input.rgb * mix(tex0.rgb * mix(vec3(1.0, 1.0, 1.0), tex1.rgb * vec3(1.0, 1.0, 1.0), vec3(tex1.a)), tex2.rgb * vec3(1.0, 1.0, 1.0), vec3(tex2.a));", ""],
      PS_Guild_NoBorder: [2, "_output.rgb = _input.rgb * tex0.rgb * mix(vec3(1.0, 1.0, 1.0), tex1.rgb * vec3(1.0, 1.0, 1.0), vec3(tex1.a));", "_output.a = tex0.a;"],
      PS_Combiners_Opaque_Alpha_Alpha: [2, "_output.rgb = _input.rgb * mix(mix(tex0.rgb, tex1.rgb, vec3(tex1.a)), tex0.rgb, vec3(tex0.a));", ""],
      PS_Combiners_Opaque_Mod2xNA_Alpha_3s: [3, "_output.rgb = _input.rgb * mix(tex0.rgb * tex1.rgb * 2.0, tex2.rgb, vec3(tex2.a));"],
      PS_Combiners_Mod_Add_Alpha: [2, "_output.rgb = _input.rgb * tex0.rgb;", "_output.a = (tex0.a + tex1.a);", "_specular = tex1.rgb * (1.0 - tex0.a);"],
      PS_Combiners_Opaque_ModNA_Alpha: [2, "_output.rgb = _input.rgb * mix(tex0.rgb * tex1.rgb, tex0.rgb, vec3(tex0.a));", ""],
      PS_Combiners_Opaque_Mod2xNA_Alpha_UnshAlpha: [3, "float glowOpacity = clamp((tex2.a * vec4(1.0, 1.0, 1.0, 1.0).z), 0.0, 1.0); _output.rgb = _input.rgb * mix(tex0.rgb * tex1.rgb * 2.000000, tex0.rgb, vec3(tex0.a)) * (1.0 - glowOpacity);", "_specular = tex2.rgb * glowOpacity;"],
      PS_Combiners_Opaque_Mod2xNA_Alpha_Alpha: [3, "_output.rgb = _input.rgb * mix(mix(tex0.rgb * tex1.rgb * 2.000000, tex2.rgb, vec3(tex2.a)), tex0.rgb, vec3(tex0.a));", ""],
      PS_Combiners_Mod_Depth: [1, "_output.rgb = _input.rgb * tex0.rgb;", "_output.a = tex0.a;"],
      PS_Combiners_Opaque_Alpha: [2, "_output.rgb = _input.rgb * mix(tex0.rgb, tex1.rgb, vec3(tex1.a));", ""],
      Skin: [3, "//Fresnel Rim\r\nif (uHasSpecEmiss) {\r\n    vec3 emissiveColor = tex2.rgb;\r\n    vec3 emissiveTerm = tex2.rgb;\r\n    if (uHasEmissiveGlowing) {\r\n        vec3 eyeVec_120 = vPosition.xyz;\r\n        vec3 t121 = -(eyeVec_120);\r\n        vec2 term_126 = vec2(dot(t121, vNormal), dot(normalize(t121), (vNormal * vec3(0.0500000007, 0.0500000007, 1.0))));\r\n        vec2 invTerm_128 = (vec2(1.0) - clamp(term_126, 0.0, 1.0));\r\n        vec2 f_129 = (invTerm_128 * invTerm_128);\r\n        float fresnel_rim_133 = pow((f_129.x + f_129.y), 0.600000024);\r\n        vec3 t136 = (tex2.rgb /*+ ((vec3(0.0500000007, 0.0, 0.400000006) * 1.0) * fresnel_rim_133)*/);\r\n        emissiveColor = vec3(t136.r, tex2.g, t136.b);\r\n\r\n        float t267 = dot(normalize(vNormal),  normalize(-(vPosition.xyz)));\r\n        emissiveTerm = mix(vec3(0.0), 2.0*emissiveColor, vec3(pow(clamp(t267, 0.0, 1.0), (( 128.0 * (tex2.a)) + 9.99999975e-006))));\r\n    }\r\n\r\n    _output.rgb = _input.rgb * tex0.rgb + tex1.rgb + emissiveTerm.rgb;\r\n} else {\r\n    _output.rgb = _input.rgb * tex0.rgb;\r\n}\r\n_output.a = tex0.a; //\r\n"],
      PS_Combiners_Mod_Dual_Crossfade: [3, "_output.rgb = _input.rgb * mix(mix(tex0, texture2D(uTexture2,vTexCoord1), vec4(clamp(uTexSampleAlpha.g, 0.000000, 1.000000))), texture2D(uTexture3,vTexCoord1), vec4(clamp(uTexSampleAlpha.b, 0.000000, 1.000000))).rgb;", "_output.a = mix(mix(tex0, texture2D(uTexture2,vTexCoord1), vec4(clamp(uTexSampleAlpha.g, 0.000000, 1.000000))), texture2D(uTexture3,vTexCoord1), vec4(clamp(uTexSampleAlpha.b, 0.000000, 1.000000))).a;"],
      PS_Combiners_Mod_Masked_Dual_Crossfade: [4, "_output.rgb = _input.rgb * mix(mix(tex0, texture2D(uTexture2,texCoord), vec4(clamp(uTexSampleAlpha.g, 0.000000, 1.000000))), texture2D(uTexture3,texCoord), vec4(clamp(uTexSampleAlpha.b, 0.000000, 1.000000))).rgb;", "_output.a = mix(mix(tex0, texture2D(uTexture2,texCoord), vec4(clamp(uTexSampleAlpha.g, 0.000000, 1.000000))), texture2D(uTexture3,texCoord), vec4(clamp(uTexSampleAlpha.b, 0.000000, 1.000000))).a * texture(uTexture4,texCoord2).a;"],
      PS_Combiners_Mod_Mod_Depth: [2, "_output.rgb = (_input.rgb * tex0.rgb) * tex1.rgb;", "_output.a = tex0.a * tex1.a;"]
  }
    , vs = _s;
  const xs = class {
      constructor(t) {
          this.c = t,
          this.d = new Set
      }
      e() {
          const t = this.d;
          return this.d = new Set,
          t
      }
      a(t) {
          this.d.has(t) || (this.c.enableVertexAttribArray(t),
          this.d.add(t))
      }
      b(t) {
          const e = this.c;
          [...t].filter((t => !this.d.has(t))).forEach((t => e.disableVertexAttribArray(t)))
      }
  }
  ;
  const Ts = class {
  }
  ;
  const ws = class {
  }
  ;
  const ys = class extends ws {
  }
  ;
  function As() {
      var t = new fi(4);
      return fi != Float32Array && (t[0] = 0,
      t[1] = 0,
      t[2] = 0,
      t[3] = 0),
      t
  }
  function Es(t, e, i, s) {
      var r = new fi(4);
      return r[0] = t,
      r[1] = e,
      r[2] = i,
      r[3] = s,
      r
  }
  function Cs(t, e) {
      return t[0] = e[0],
      t[1] = e[1],
      t[2] = e[2],
      t[3] = e[3],
      t
  }
  function Ms(t, e, i, s, r) {
      return t[0] = e,
      t[1] = i,
      t[2] = s,
      t[3] = r,
      t
  }
  function ks(t, e, i) {
      return t[0] = e[0] + i[0],
      t[1] = e[1] + i[1],
      t[2] = e[2] + i[2],
      t[3] = e[3] + i[3],
      t
  }
  function Fs(t, e, i) {
      return t[0] = e[0] - i[0],
      t[1] = e[1] - i[1],
      t[2] = e[2] - i[2],
      t[3] = e[3] - i[3],
      t
  }
  function Ss(t, e, i) {
      return t[0] = e[0] * i,
      t[1] = e[1] * i,
      t[2] = e[2] * i,
      t[3] = e[3] * i,
      t
  }
  function Ds(t) {
      var e = t[0]
        , i = t[1]
        , s = t[2]
        , r = t[3];
      return Math.hypot(e, i, s, r)
  }
  function Is(t, e) {
      var i = e[0]
        , s = e[1]
        , r = e[2]
        , n = e[3]
        , a = i * i + s * s + r * r + n * n;
      return a > 0 && (a = 1 / Math.sqrt(a)),
      t[0] = i * a,
      t[1] = s * a,
      t[2] = r * a,
      t[3] = n * a,
      t
  }
  function Rs(t, e, i) {
      var s = e[0]
        , r = e[1]
        , n = e[2]
        , a = e[3];
      return t[0] = i[0] * s + i[4] * r + i[8] * n + i[12] * a,
      t[1] = i[1] * s + i[5] * r + i[9] * n + i[13] * a,
      t[2] = i[2] * s + i[6] * r + i[10] * n + i[14] * a,
      t[3] = i[3] * s + i[7] * r + i[11] * n + i[15] * a,
      t
  }
  var Us = Ds;
  !function() {
      var t = As()
  }();
  const Os = class extends ys {
      constructor(t, e) {
          super(),
          this.ed = e,
          this.j = gi(),
          this.f = _i(0, 0, 0),
          this.i = As(),
          this.g = Es(0, 0, 0, 0),
          this.cba = new ss(t,40 * e.length / 4,!0),
          this.dc(e)
      }
      ba(t, e) {
          const i = this.h;
          let s = this.ed.length;
          for (let r = 0; r < s; ++r) {
              if (!e.has(r))
                  continue;
              mi(this.f, 0, 0, 0),
              Ms(this.g, 0, 0, 0, 0);
              const s = this.ed[r];
              let n = !1;
              for (let e = 0; e < 4; ++e) {
                  const i = s.d[e] / 255;
                  if (i > 0) {
                      const r = t[s.f[e]];
                      Ii(this.j, s.e, r.i),
                      Rs(this.i, s.c, r.y),
                      this.f[0] = this.f[0] + this.j[0] * i,
                      this.f[1] = this.f[1] + this.j[1] * i,
                      this.f[2] = this.f[2] + this.j[2] * i,
                      this.g[0] = this.g[0] + this.i[0] * i,
                      this.g[1] = this.g[1] + this.i[1] * i,
                      this.g[2] = this.g[2] + this.i[2] * i,
                      n = !0
                  }
              }
              if (n) {
                  let t = 10 * r;
                  i[t++] = this.f[0],
                  i[t++] = this.f[1],
                  i[t++] = this.f[2],
                  i[t++] = this.g[0],
                  i[t++] = this.g[1],
                  i[t++] = this.g[2]
              }
          }
          this.cba.b(this.h)
      }
      dc(t) {
          const e = 40 * t.length / 4;
          this.h = new Float32Array(e);
          const i = this.h
            , s = t;
          let r = 0;
          for (let t = 0; t < s.length; ++t)
              i[r++] = s[t].e[0],
              i[r++] = s[t].e[1],
              i[r++] = s[t].e[2],
              i[r++] = s[t].c[0],
              i[r++] = s[t].c[1],
              i[r++] = s[t].c[2],
              i[r++] = s[t].i,
              i[r++] = s[t].b,
              i[r++] = s[t].a,
              i[r++] = s[t].h;
          this.cba.b(this.h)
      }
      b(t) {
          this.cba.b(t)
      }
      a() {
          return this.cba.a()
      }
      d() {
          this.cba.d()
      }
      c() {
          this.cba.c()
      }
  }
  ;
  const Ps = class extends ys {
      constructor(t, e) {
          super(),
          this.f = e,
          this.ed = new ss(t,48 * e.length,!0),
          this.dc(e)
      }
      ba(t, e) {}
      dc(t) {
          const e = 48 * t.length;
          this.cba = new Uint8Array(e);
          let i = new DataView(this.cba.buffer);
          const s = t;
          let r = 0;
          for (let t = 0; t < s.length; ++t)
              i.setFloat32(r, s[t].e[0], !0),
              r += 4,
              i.setFloat32(r, s[t].e[1], !0),
              r += 4,
              i.setFloat32(r, s[t].e[2], !0),
              r += 4,
              i.setFloat32(r, s[t].c[0], !0),
              r += 4,
              i.setFloat32(r, s[t].c[1], !0),
              r += 4,
              i.setFloat32(r, s[t].c[2], !0),
              r += 4,
              i.setUint8(r, s[t].f[0]),
              r += 1,
              i.setUint8(r, s[t].f[1]),
              r += 1,
              i.setUint8(r, s[t].f[2]),
              r += 1,
              i.setUint8(r, s[t].f[3]),
              r += 1,
              i.setUint8(r, s[t].d[0]),
              r += 1,
              i.setUint8(r, s[t].d[1]),
              r += 1,
              i.setUint8(r, s[t].d[2]),
              r += 1,
              i.setUint8(r, s[t].d[3]),
              r += 1,
              i.setFloat32(r, s[t].i, !0),
              r += 4,
              i.setFloat32(r, s[t].b, !0),
              r += 4,
              i.setFloat32(r, s[t].a, !0),
              r += 4,
              i.setFloat32(r, s[t].h, !0),
              r += 4;
          this.ed.b(this.cba)
      }
      b(t) {
          this.ed.b(t)
      }
      a() {
          return this.ed.a()
      }
      d() {
          this.ed.d()
      }
      c() {
          this.ed.c()
      }
  }
  ;
  const Bs = class {
      a() {
          return {}
      }
      b(t) {}
  }
  ;
  const zs = class {
      constructor(t, e) {
          this.c = t,
          this.ba = e,
          this.ba = 256,
          this.d = new Float32Array(16 * this.ba),
          this.e = t.createTexture(),
          t.bindTexture(t.TEXTURE_2D, this.e),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
          t.bindTexture(t.TEXTURE_2D, null)
      }
      a() {
          return {
              uBoneMatricesTex: this.e
          }
      }
      b(t) {
          const e = Math.min(256, t.length);
          for (let i = 0; i < e; i++)
              this.d.set(t[i].i, 16 * i);
          const i = this.c;
          i.bindTexture(i.TEXTURE_2D, this.e),
          i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, 4, this.ba, 0, i.RGBA, i.FLOAT, this.d),
          i.bindTexture(i.TEXTURE_2D, null)
      }
  }
  ;
  var Ns;
  !function(t) {
      t[t.aPosition = 0] = "aPosition",
      t[t.aNormal = 1] = "aNormal",
      t[t.aTexCoord0 = 2] = "aTexCoord0",
      t[t.aTexCoord1 = 3] = "aTexCoord1"
  }(Ns || (Ns = {}));
  const Gs = {
      aPosition: Ns.aPosition,
      aNormal: Ns.aNormal,
      aTexCoord0: Ns.aTexCoord0,
      aTexCoord1: Ns.aTexCoord1
  }
    , js = [new ns(Ns.aPosition,3,rs.GFLOAT,!1,40,0), new ns(Ns.aNormal,3,rs.GFLOAT,!1,40,12), new ns(Ns.aTexCoord0,2,rs.GFLOAT,!1,40,24), new ns(Ns.aTexCoord1,2,rs.GFLOAT,!1,40,32)];
  var Ls;
  !function(t) {
      t[t.aPosition = 0] = "aPosition",
      t[t.aNormal = 1] = "aNormal",
      t[t.aBones = 2] = "aBones",
      t[t.aBoneWeights = 3] = "aBoneWeights",
      t[t.aTexCoord0 = 4] = "aTexCoord0",
      t[t.aTexCoord1 = 5] = "aTexCoord1"
  }(Ls || (Ls = {}));
  const Hs = {
      aPosition: Ls.aPosition,
      aNormal: Ls.aNormal,
      aBones: Ls.aBones,
      aBoneWeights: Ls.aBoneWeights,
      aTexCoord0: Ls.aTexCoord0,
      aTexCoord1: Ls.aTexCoord1
  }
    , Vs = [new ns(Ls.aPosition,3,rs.GFLOAT,!1,48,0), new ns(Ls.aNormal,3,rs.GFLOAT,!1,48,12), new ns(Ls.aBones,4,rs.GUNSIGNED_BYTE,!1,48,24), new ns(Ls.aBoneWeights,4,rs.GUNSIGNED_BYTE,!0,48,28), new ns(Ls.aTexCoord0,2,rs.GFLOAT,!1,48,32), new ns(Ls.aTexCoord1,2,rs.GFLOAT,!1,48,40)];
  var qs;
  !function(t) {
      t[t.aPosition = 0] = "aPosition",
      t[t.aColor = 1] = "aColor",
      t[t.aTexcoord0 = 2] = "aTexcoord0",
      t[t.aTexcoord1 = 3] = "aTexcoord1",
      t[t.aTexcoord2 = 4] = "aTexcoord2",
      t[t.aAlphaCutoff = 5] = "aAlphaCutoff"
  }(qs || (qs = {}));
  const Xs = {
      [qs.aPosition]: qs.aPosition,
      [qs.aColor]: qs.aColor,
      [qs.aTexcoord0]: qs.aTexcoord0,
      [qs.aTexcoord1]: qs.aTexcoord1,
      [qs.aTexcoord2]: qs.aTexcoord2,
      [qs.aAlphaCutoff]: qs.aAlphaCutoff
  }
    , Ws = [new ns(qs.aPosition,3,rs.GFLOAT,!1,56,0), new ns(qs.aColor,4,rs.GFLOAT,!1,56,12), new ns(qs.aTexcoord0,2,rs.GFLOAT,!1,56,28), new ns(qs.aTexcoord1,2,rs.GFLOAT,!1,56,36), new ns(qs.aTexcoord2,2,rs.GFLOAT,!1,56,44), new ns(qs.aAlphaCutoff,1,rs.GFLOAT,!1,56,52)];
  var Zs;
  !function(t) {
      t[t.aPosition = 0] = "aPosition",
      t[t.aColor = 1] = "aColor",
      t[t.aTexcoord0 = 2] = "aTexcoord0"
  }(Zs || (Zs = {}));
  const Ks = {
      [Zs.aPosition]: Zs.aPosition,
      [Zs.aColor]: Zs.aColor,
      [Zs.aTexcoord0]: Zs.aTexcoord0
  }
    , Ys = [new ns(Zs.aPosition,3,rs.GFLOAT,!1,36,0), new ns(Zs.aColor,4,rs.GFLOAT,!1,36,12), new ns(Zs.aTexcoord0,2,rs.GFLOAT,!1,36,28)];
  const Js = class {
      constructor(t, e) {
          this.ji = t,
          this.hg = e,
          this.lk = new Map,
          this.fe = new xs(t.o());
          const i = t.o();
          this.ba = i.createTexture(),
          i.bindTexture(i.TEXTURE_2D, this.ba),
          i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0])),
          i.bindTexture(i.TEXTURE_2D, null)
      }
      dc() {
          throw new Error("Method not implemented.")
      }
      i() {
          return this.ji
      }
      e(t) {
          return new is(this.ji.o(),t,!1)
      }
      f(t) {
          return this.ji.l ? new Ps(this.ji.o(),t) : new Os(this.ji.o(),t)
      }
      c(t) {
          return new ss(this.ji.o(),t,!0)
      }
      h(t) {
          return new ss(this.ji.o(),t,!0)
      }
      a(t, e) {
          const i = this.ji.dc()
            , s = i ? new os(this.ji.o(),i) : new hs(this.ji.o(),this.fe)
            , r = this.ji.l ? Vs : js;
          return s.d(t, r),
          s.c(e),
          s
      }
      g(t, e) {
          const i = this.ji.dc()
            , s = i ? new os(this.ji.o(),i) : new hs(this.ji.o(),this.fe);
          return s.c(e),
          s.d(t, Ws),
          s
      }
      m(t, e) {
          const i = this.ji.dc()
            , s = i ? new os(this.ji.o(),i) : new hs(this.ji.o(),this.fe);
          return s.c(e),
          s.d(t, Ys),
          s
      }
      l(t, e, i, s) {
          return this.ji.l ? new zs(this.ji.o(),t) : new Bs
      }
      o(t, e, i) {
          const s = vs.a(i.b, i.d.length)
            , r = vs.f(i.b, i.d.length)
            , n = "Wow." + r + "_" + s + (i.a ? "_gradient" : "");
          let a;
          this.lk.has(n) ? a = this.lk.get(n) : (a = new bs(this.ji.o(),this.ji.l ? Hs : Gs,vs.c(r, this.ji.l),vs.b(r, s, i.a)),
          this.lk.set(n, a));
          const o = Object.assign(Object.assign(Object.assign({}, this.hg), t.a()), i.c);
          for (let t = 0; t < Math.max(i.d.length, 4); t++) {
              let e = t < i.d.length ? i.d[t].d : this.ba;
              o["uTexture" + (t + 1).toString()] = e
          }
          return new gs(this.ji.o(),a,e,o)
      }
      b(t, e, i) {
          const s = Object.assign(Object.assign(Object.assign({}, this.hg), t.a()), i.a);
          let r;
          const n = "ParticleShader";
          this.lk.has(n) ? r = this.lk.get(n) : (r = new bs(this.ji.o(),Xs,"attribute vec3 aPosition;\r\nattribute vec4 aColor;\r\nattribute vec2 aTexcoord0;\r\nattribute vec2 aTexcoord1;\r\nattribute vec2 aTexcoord2;\r\nattribute float aAlphaCutoff;\r\n\r\nvarying vec4 vColor;\r\nvarying vec2 vTexcoord0;\r\nvarying vec2 vTexcoord1;\r\nvarying vec2 vTexcoord2;\r\nvarying float vAlphaCutoff;\r\n\r\nuniform mat4 uModelMatrix;\r\nuniform mat4 uViewMatrix;\r\nuniform mat4 uProjMatrix;\r\n\r\nvoid main(void) {\r\n    vec4 pos = vec4(aPosition, 1);\r\n\r\n    gl_Position = uProjMatrix * pos;\r\n\r\n    vColor = aColor;\r\n    vTexcoord0 = aTexcoord0;\r\n    vTexcoord1 = aTexcoord1;\r\n    vTexcoord2 = aTexcoord2;\r\n    vAlphaCutoff = aAlphaCutoff;\r\n}","precision mediump float;\r\n\r\nvarying vec4 vColor;\r\nvarying vec2 vTexcoord0;\r\nvarying vec2 vTexcoord1;\r\nvarying vec2 vTexcoord2;\r\nvarying float vAlphaCutoff;\r\n\r\nuniform bool uHasTexture;\r\nuniform bool uHasTexture2;\r\nuniform bool uHasTexture3;\r\nuniform bool uHasAlpha;\r\nuniform int uBlendMode;\r\nuniform int uPixelShader;\r\nuniform sampler2D uTexture0;\r\nuniform sampler2D uTexture1;\r\nuniform sampler2D uTexture2;\r\nuniform float uAlphaTreshold;\r\n\r\nuniform float alphaMult;\r\nuniform float colorMult;\r\n\r\nvoid main(void) {\r\n    float lo_thresh = 0.01;\r\n    vec4 color = vec4(1, 1, 1, 1);\r\n    vec4 tex = vec4(1, 1, 1, 1);\r\n    vec4 tex2 = vec4(1, 1, 1, 1);\r\n    vec4 tex3 = vec4(1, 1, 1, 1);\r\n    if (uHasTexture) {\r\n        tex = texture2D(uTexture0, vTexcoord0).rgba;\r\n    }\r\n    if (uHasTexture2) {\r\n        tex2 = texture2D(uTexture1, vTexcoord1).rgba;\r\n    }\r\n    if (uHasTexture3) {\r\n        tex3 = texture2D(uTexture2, vTexcoord2).rgba;\r\n    }\r\n    vec4 finalColor = vec4((tex * vColor ).rgb, tex.a*vColor.a );\r\n    vec3 matDiffuse = vec3(1.0);\r\n    float opacity = 1.0;\r\n    if (uPixelShader == 0) {\r\n        matDiffuse = vColor.xyz * tex.rgb;\r\n        opacity = tex.a*vColor.a;\r\n    } else if (uPixelShader == 1) {\r\n        vec4 textureMod = tex*tex2;\r\n        float texAlpha = (textureMod.w * tex3.w);\r\n        opacity = texAlpha*vColor.a;\r\n        matDiffuse = vColor.xyz * 4.0 * textureMod.rgb;\r\n    } else if (uPixelShader == 2) {\r\n        vec4 textureMod = tex*tex2*tex3;\r\n        float texAlpha = (textureMod.w);\r\n        opacity = texAlpha*vColor.a;\r\n        matDiffuse = vColor.xyz * textureMod.rgb;\r\n    } else if (uPixelShader == 3) {\r\n        vec4 textureMod = tex*tex2*tex3;\r\n        float texAlpha = (textureMod.w);\r\n        opacity = texAlpha*vColor.a;\r\n\r\n        matDiffuse = vColor.xyz * textureMod.rgb;\r\n    } else if (uPixelShader == 4) {\r\n        discard;\r\n    }\r\n\r\n    finalColor = vec4(matDiffuse.rgb * colorMult, opacity * alphaMult);\r\n\r\n    if (finalColor.a < vAlphaCutoff ) discard;\r\n    if (finalColor.a < uAlphaTreshold ) discard;\r\n    gl_FragColor = finalColor;\r\n}\r\n"),
          this.lk.set(n, r));
          for (let t = 0; t < i.b.length; t++)
              i.b[t] && (s["uTexture" + t.toString()] = i.b[t].d);
          return new gs(this.ji.o(),r,e,s)
      }
      n(t, e, i) {
          const s = Object.assign(Object.assign(Object.assign({}, this.hg), t.a()), i.a);
          let r;
          const n = "RibbonShader";
          return this.lk.has(n) ? r = this.lk.get(n) : (r = new bs(this.ji.o(),Ks,"attribute vec3 aPosition;\r\nattribute vec4 aColor;\r\nattribute vec2 aTexcoord0;\r\n\r\nuniform mat4 uViewMatrix;\r\nuniform mat4 uProjMatrix;\r\n\r\nvarying vec4 vColor;\r\nvarying vec2 vTexcoord0;\r\n\r\nvoid main() {\r\n    vec4 aPositionVec4 = vec4(aPosition, 1);\r\n    vColor = aColor;\r\n    vTexcoord0 = aTexcoord0;\r\n\r\n    gl_Position = uProjMatrix * uViewMatrix * aPositionVec4;\r\n}\r\n\r\n\r\n","precision mediump float;\r\n\r\nvarying vec4 vColor;\r\nvarying vec2 vTexcoord0;\r\nuniform sampler2D uTexture;\r\n\r\nvoid main() {\r\n    vec4 tex = texture2D(uTexture, vTexcoord0).rgba;\r\n    gl_FragColor = vec4((vColor.rgb*tex.rgb), tex.a * vColor.a );\r\n}\r\n"),
          this.lk.set(n, r)),
          s["uTexture".toString()] = i.b[0].d,
          new gs(this.ji.o(),r,e,s)
      }
      k(t, e, i, s) {
          const r = this.ji.o();
          let n = new Ts;
          return n.g = e,
          n.d = t.a,
          n.f = r.TRIANGLES,
          n.a = t.b,
          n.e = t.c,
          n.h = s,
          n.b = i,
          n
      }
      d(t, e, i, s) {
          const r = this.ji.o();
          let n = new Ts;
          return n.g = e,
          n.d = t.a,
          n.f = r.TRIANGLE_STRIP,
          n.a = t.b,
          n.e = t.c,
          n.h = s,
          n.b = i,
          n
      }
      j(t) {
          const e = this.ji.o()
            , i = e.createTexture();
          function s(t) {
              return !(t & t - 1)
          }
          e.bindTexture(e.TEXTURE_2D, i),
          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
          e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t),
          s(t.width) && s(t.height) ? e.generateMipmap(e.TEXTURE_2D) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR));
          const r = this.ji.g;
          return r && e.texParameteri(e.TEXTURE_2D, r.TEXTURE_MAX_ANISOTROPY_EXT, this.ji.ba),
          i
      }
  }
  ;
  var Qs;
  !function(t) {
      t[t.GxBlend_UNDEFINED = -1] = "GxBlend_UNDEFINED",
      t[t.GxBlend_Opaque = 0] = "GxBlend_Opaque",
      t[t.GxBlend_AlphaKey = 1] = "GxBlend_AlphaKey",
      t[t.GxBlend_Alpha = 2] = "GxBlend_Alpha",
      t[t.GxBlend_Add = 3] = "GxBlend_Add",
      t[t.GxBlend_Mod = 4] = "GxBlend_Mod",
      t[t.GxBlend_Mod2x = 5] = "GxBlend_Mod2x",
      t[t.GxBlend_ModAdd = 6] = "GxBlend_ModAdd",
      t[t.GxBlend_InvSrcAlphaAdd = 7] = "GxBlend_InvSrcAlphaAdd",
      t[t.GxBlend_InvSrcAlphaOpaque = 8] = "GxBlend_InvSrcAlphaOpaque",
      t[t.GxBlend_SrcAlphaOpaque = 9] = "GxBlend_SrcAlphaOpaque",
      t[t.GxBlend_NoAlphaAdd = 10] = "GxBlend_NoAlphaAdd",
      t[t.GxBlend_ConstantAlpha = 11] = "GxBlend_ConstantAlpha",
      t[t.GxBlend_Screen = 12] = "GxBlend_Screen",
      t[t.GxBlend_BlendAdd = 13] = "GxBlend_BlendAdd",
      t[t.GxBlend_MAX = 14] = "GxBlend_MAX"
  }(Qs || (Qs = {}));
  const $s = Qs;
  const tr = class {
      constructor(t) {
          this.r = t,
          this.fe = -1,
          this.n = -1,
          this.k = -1,
          this.o = -1,
          this.dc = -1,
          this.t = $s.GxBlend_UNDEFINED,
          this.s = null,
          this.ba = null,
          this.q = null,
          this.m = null,
          this.ji = null
      }
      p() {
          this.fe = -1,
          this.n = -1,
          this.k = -1,
          this.o = -1,
          this.dc = -1,
          this.t = $s.GxBlend_UNDEFINED,
          this.s = null,
          this.ba = null,
          this.q = null,
          this.m = null,
          this.ji = null
      }
      h(t) {
          this.t != t && (this.hg(t),
          this.t = t)
      }
      d(t) {
          const e = t ? 1 : 0;
          e != this.fe && (this.r.depthMask(t),
          this.fe = e)
      }
      a(t) {
          const e = t ? 1 : 0;
          e != this.n && (t ? this.r.enable(this.r.DEPTH_TEST) : this.r.disable(this.r.DEPTH_TEST),
          this.n = e)
      }
      f(t) {
          const e = t ? 1 : 0;
          e != this.k && (t ? this.r.enable(this.r.CULL_FACE) : this.r.disable(this.r.CULL_FACE),
          this.k = e)
      }
      e(t) {
          const e = t ? 1 : 0;
          e != this.o && (t ? this.r.frontFace(this.r.CCW) : this.r.frontFace(this.r.CW),
          this.o = e)
      }
      b(t) {
          this.dc != t && (this.r.colorMask((1 & t) > 0, (2 & t) > 0, (4 & t) > 0, (8 & t) > 0),
          this.dc = t)
      }
      j(t) {
          this.ba != t && (t ? t.d() : t.c(),
          this.ba = t)
      }
      i(t) {
          this.s != t && (t ? t.d() : t.c(),
          this.s = t)
      }
      g(t) {
          this.q != t && (t ? t.a() : this.q.b(),
          this.q = t,
          this.s = null,
          this.ba = null)
      }
      c(t) {
          t != this.m && (t && t.a(),
          this.m = t)
      }
      hg(t) {
          const e = this.r;
          switch (0 == t ? e.disable(e.BLEND) : (e.enable(e.BLEND),
          e.blendEquation(e.FUNC_ADD)),
          t) {
          case 0:
              break;
          case 1:
              e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ONE);
              break;
          case 2:
              e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE);
              break;
          case 3:
              e.blendFuncSeparate(e.SRC_ALPHA, e.ONE, e.ONE, e.ONE);
              break;
          case 4:
              e.blendFuncSeparate(e.DST_COLOR, e.ZERO, e.ONE, e.ONE);
              break;
          case 5:
              e.blendFuncSeparate(e.DST_COLOR, e.SRC_COLOR, e.ONE, e.ONE);
              break;
          case 6:
              e.blendFuncSeparate(e.DST_COLOR, e.ONE, e.ONE, e.ONE);
              break;
          case 10:
              e.blendFunc(e.ONE, e.ONE);
              break;
          case 7:
              e.blendFuncSeparate(e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE, e.ONE);
              break;
          case 8:
              e.blendFuncSeparate(e.ONE_MINUS_SRC_ALPHA, e.ZERO, e.ONE, e.ONE);
              break;
          case 13:
              e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE);
              break;
          default:
              throw 3735927486
          }
      }
      l(t) {
          this.ji != t && (t.a(this),
          this.ji = t)
      }
  }
  ;
  const er = class {
      constructor(t, e) {
          this.m = t,
          this.j = e,
          this.n = !1,
          this.l = !1,
          this.h = t.getExtension("OES_vertex_array_object"),
          this.g = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
          this.g ? (this.ba = t.getParameter(this.g.MAX_TEXTURE_MAX_ANISOTROPY_EXT),
          WH.debug("Texture anisotropy enabled", this.ba)) : WH.debug("Texture anisotropy disabled (not supported)"),
          this.n = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0,
          this.i = t.getExtension("OES_texture_float"),
          this.l = this.n && null != this.i,
          this.l ? WH.debug("(float texture) Skinning in shader is supported") : WH.debug("(float texture) Skinning in shader is (not supported) "),
          this.fe = new Js(this,e),
          this.k = new tr(t)
      }
      o() {
          return this.m
      }
      dc() {
          return this.h
      }
      d() {
          return this.fe
      }
      e(t) {
          const e = this.k
            , i = this.o();
          e.g(t.d),
          e.l(t.g),
          i.drawElements(t.f, t.e, i.UNSIGNED_SHORT, t.a)
      }
      a() {
          this.k.p()
      }
      b() {
          this.k.g(null)
      }
      c(t) {
          this.a(),
          t.forEach((t => {
              this.e(t)
          }
          )),
          this.b()
      }
  }
  ;
  const ir = class {
      constructor(t, e) {
          this.a = t,
          this.h = e,
          this.d = null,
          this.l = !1,
          this.k = 0,
          this.e = 0,
          0 != e && (this.g = t.options.contentPath + "textures/" + e + WH.WebP.getImageExtension(),
          this.j = new Image,
          this.j.onload = () => {
              this.f()
          }
          ,
          this.j.onerror = () => {
              this.j = null
          }
          ,
          this.i(this.j, this.g))
      }
      i(t, e) {
          var i = new XMLHttpRequest;
          i.open("GET", e, !0),
          i.responseType = "arraybuffer",
          i.onload = e => {
              var s = new Blob([i.response]);
              t.src = window.URL.createObjectURL(s)
          }
          ,
          i.addEventListener("progress", (t => {
              const i = this.a;
              i && t.lengthComputable && (i.downloads[e] ? i.downloads[e].loaded = t.loaded : i.downloads[e] = {
                  loaded: t.loaded,
                  total: t.total
              },
              i.updateProgress())
          }
          )),
          i.addEventListener("load", ( () => {
              const t = this.a;
              t && (delete t.downloads[e],
              t.updateProgress())
          }
          )),
          i.send()
      }
      c() {
          return this.l
      }
      b() {
          this.d = null
      }
      f() {
          this.k = this.j.width,
          this.e = this.j.height,
          this.d = this.a.renderer.j(this.j),
          this.l = !0,
          this.j = null
      }
  }
    , sr = {
      147259: !0
  }
    , rr = [1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 2, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    , nr = {
      2: {
          GeosetType: 15,
          Original: 2,
          Override: 11
      },
      3: {
          GeosetType: 15,
          Original: 3,
          Override: 12
      },
      4: {
          GeosetType: 15,
          Original: 4,
          Override: 13
      },
      5: {
          GeosetType: 15,
          Original: 5,
          Override: 14
      },
      6: {
          GeosetType: 15,
          Original: 6,
          Override: 15
      },
      7: {
          GeosetType: 15,
          Original: 7,
          Override: 16
      },
      8: {
          GeosetType: 15,
          Original: 8,
          Override: 17
      },
      9: {
          GeosetType: 15,
          Original: 9,
          Override: 18
      },
      10: {
          GeosetType: 15,
          Original: 10,
          Override: 19
      },
      11: {
          GeosetType: 12,
          Original: 2,
          Override: 0
      },
      12: {
          GeosetType: 12,
          Original: 3,
          Override: 0
      },
      13: {
          GeosetType: 12,
          Original: 1,
          Override: 5
      },
      14: {
          GeosetType: 12,
          Original: 2,
          Override: 3
      },
      15: {
          GeosetType: 12,
          Original: 2,
          Override: 2
      },
      16: {
          GeosetType: 22,
          Original: 2,
          Override: 1
      },
      17: {
          GeosetType: 22,
          Original: 1,
          Override: 2
      },
      18: {
          GeosetType: 22,
          Original: 1,
          Override: 3
      },
      19: {
          GeosetType: 22,
          Original: 2,
          Override: 3
      },
      20: {
          GeosetType: 12,
          Original: 1,
          Override: 1
      },
      21: {
          GeosetType: 12,
          Original: 1,
          Override: 9
      },
      22: {
          GeosetType: 12,
          Original: 2,
          Override: 10
      },
      23: {
          GeosetType: 12,
          Original: 2,
          Override: 6
      },
      24: {
          GeosetType: 12,
          Original: 1,
          Override: 5
      },
      25: {
          GeosetType: 27,
          Original: 0,
          Override: 1
      },
      26: {
          GeosetType: 27,
          Original: 0,
          Override: 1
      },
      27: {
          GeosetType: 27,
          Original: 0,
          Override: 1
      },
      28: {
          GeosetType: 13,
          Original: 1,
          Override: 0
      },
      31: {
          GeosetType: 12,
          Original: 1,
          Override: 13
      },
      32: {
          GeosetType: 12,
          Original: 2,
          Override: 14
      },
      33: {
          GeosetType: 42,
          Original: 11,
          Override: 1
      },
      38: {
          GeosetType: 20,
          Original: 1,
          Override: 9
      }
  }
    , ar = {
      ITEM: 1,
      HELM: 2,
      SHOULDER: 4,
      NPC: 8,
      CHARACTER: 16,
      HUMANOIDNPC: 32,
      OBJECT: 64,
      ARMOR: 128,
      PATH: 256,
      ITEMVISUAL: 512,
      COLLECTION: 1024
  }
    , or = [0, 1, 0, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 21, 22, 22, 16, 21, 0, 19, 5, 21, 22, 22, 0, 21, 21, 27]
    , hr = [0, 16, 0, 15, 1, 7, 10, 5, 6, 6, 8, 0, 0, 17, 18, 19, 14, 20, 0, 9, 7, 21, 22, 23, 0, 24, 25, 0]
    , lr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    , ur = [0, 2, 0, 4, 128, 128, 128, 128, 128, 128, 128, 0, 0, 1, 1, 1, 128, 1, 0, 128, 128, 1, 1, 1, 0, 1, 1, 2]
    , cr = [13, 14, 15, 16, 17, 88, 89]
    , dr = [8, 9, 10, 11, 12, 86, 87]
    , fr = {
      86: [4, 0, 4, 1, 4, 0, 4, 1],
      85: [84, 0, 84, 1, 84, 0, 84, 1],
      84: [3, 0, 3, 1, 3, 0, 3, 1],
      77: [5, 1, 0, -1, 5, 0, 0, -1],
      76: [10, 0, 1, 1, 10, 0, 1, 1],
      75: [10, 0, 1, 1, 10, 0, 1, 1],
      74: [5, 1, 0, -1, 5, 0, 0, -1],
      73: [5, 1, 0, -1, 5, 0, 0, -1],
      72: [5, 1, 0, -1, 5, 0, 0, -1],
      71: [5, 1, 0, -1, 5, 0, 0, -1],
      37: [7, 0, 7, 1, 7, 0, 7, 1],
      36: [2, 0, 2, 1, 2, 0, 2, 1],
      34: [3, 0, 3, 1, 3, 0, 3, 1],
      33: [5, 1, 0, -1, 5, 0, 0, -1],
      31: [0, -1, 8, 1, 0, -1, 8, 1],
      30: [11, 0, 11, 1, 11, 0, 11, 1],
      29: [10, 0, 10, 1, 10, 0, 10, 1],
      28: [6, 0, 6, 1, 6, 0, 6, 1],
      27: [4, 0, 4, 1, 4, 0, 4, 1],
      26: [24, 0, 24, 1, 24, 0, 24, 1],
      25: [24, 0, 24, 1, 24, 0, 24, 1],
      23: [1, 0, 1, 1, 1, 0, 1, 1],
      15: [5, 0, 5, 1, 5, 0, 5, 1],
      1: [0, -1, 0, -1, 0, -1, 0, 3]
  }
    , gr = {
      21: 26,
      22: 27,
      15: 28,
      17: 26,
      25: 32,
      13: 32,
      23: 33,
      14: 28,
      26: 26
  }
    , br = {
      0: {
          21: 26,
          22: 27
      },
      1: {
          21: 26,
          22: 27
      },
      2: {
          21: 30,
          22: 31
      },
      3: {
          21: 32,
          22: 33
      },
      4: {
          21: 26,
          22: 27,
          15: 28
      },
      5: {
          21: 26
      },
      6: {
          21: 26,
          22: 27
      },
      7: {
          21: 26,
          22: 27
      },
      8: {
          21: 26,
          22: 27
      },
      9: {
          21: 33,
          22: 28
      }
  }
    , _r = 5300
    , pr = "precision mediump float;\r\n\r\nuniform float x;\r\nuniform float y;\r\nuniform float width;\r\nuniform float height;\r\n\r\nattribute vec2 aTextCoord;\r\nvarying vec2 vTextCoords;\r\nvoid main() {\r\n    vTextCoords = aTextCoord;\r\n\r\n    vec2 pos = vec2(\r\n        (x + aTextCoord.x*width)* 2.0 - 1.0,\r\n        (y + aTextCoord.y*height)* 2.0 - 1.0\r\n    );\r\n\r\n    gl_Position = vec4(pos.x, pos.y, 0, 1);\r\n}";
  class mr {
      constructor() {
          this.b = null,
          this.e = null,
          this.d = null
      }
      a() {
          null != this.b && this.b.b(),
          null != this.e && this.e.b(),
          null != this.d && this.d.b()
      }
      c() {
          return !(this.b && !this.b.c()) && (!(this.e && !this.e.c()) && !(this.d && !this.d.c()))
      }
  }
  class vr {
      constructor() {
          this.a = null,
          this.k = null,
          this.j = null,
          this.c = {},
          this.d = new li,
          this.e = null,
          this.f = null
      }
  }
  const xr = {
      uDiffuseTexture: null,
      uSpecularTexture: null,
      uEmissiveTexture: null
  };
  class Tr {
      constructor(t, e, i) {
          this.a = e,
          this.m = i,
          this.d = null,
          this.p = null,
          this.b = null,
          this.j = null,
          this.h = null,
          this.e = !1,
          this.g = t,
          this.h = function(t) {
              let e = t.createTexture();
              t.bindTexture(t.TEXTURE_2D, e),
              t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0])),
              t.bindTexture(t.TEXTURE_2D, null);
              let i = t.createTexture();
              t.bindTexture(t.TEXTURE_2D, i),
              t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255])),
              t.bindTexture(t.TEXTURE_2D, null);
              let s = new vr;
              return s.e = e,
              s.f = i,
              s.a = Qe(t, [pr, "precision mediump float;\r\n\r\nvarying vec2 vTextCoords;\r\nuniform sampler2D uDiffuseTexture;\r\nuniform sampler2D uSpecularTexture;\r\nuniform sampler2D uEmissiveTexture;\r\nuniform sampler2D renderResultTexture;\r\nuniform int uBlendMode;\r\nuniform vec2 screenResolution;\r\nuniform int layer;\r\n\r\nuniform float diffuseTexWidth;\r\nuniform float diffuseTexHeight;\r\n\r\nfloat overlayBlend(float a, float b) {\r\n    if (b > 0.5) {\r\n        return (1.0 - (1.0 - 2.0 * (a - 0.5)) * (1.0 - b));\r\n    } else {\r\n        return ((2.0 * a) * b);\r\n    }\r\n}\r\n\r\nfloat alphaStraightBlend(float a, float b, float alpha) {\r\n    return (a * alpha) + (b * (1.0 - alpha));\r\n}\r\n\r\nvoid main() {\r\n    vec2 l_texCoord = vTextCoords.xy;\r\n\r\n\r\n    l_texCoord.x = max(min(l_texCoord.x, (diffuseTexWidth-0.5)/diffuseTexWidth), 0.5/diffuseTexWidth);\r\n    l_texCoord.y = max(min(l_texCoord.y, (diffuseTexHeight-0.5)/diffuseTexHeight), 0.5/diffuseTexHeight);\r\n\r\n    vec4 diffuse = texture2D( uDiffuseTexture, l_texCoord );\r\n    vec4 backGround = texture2D( renderResultTexture, gl_FragCoord.xy / screenResolution );\r\n\r\n    if (uBlendMode == 1) {\r\n        // Blit (we do nothing?)\r\n        //if (diffuse.a < 0.001) discard;\r\n\r\n        //vec4 finalColor = diffuse;\r\n\r\n        //diffuse = vec4(finalColor.rgb, finalColor.a);\r\n    } else if (uBlendMode == 2) {\r\n        // Multiply\r\n        if (diffuse.a < 0.001) discard;\r\n\r\n        vec4 multTexture = diffuse;\r\n        vec3 finalColor = (backGround.rgb * multTexture.rgb);\r\n\r\n        diffuse = vec4(finalColor.rgb, 1.0);\r\n    } else if (uBlendMode == 3) {\r\n        // Overlay\r\n        if (diffuse.a < 0.001) discard;\r\n\r\n        vec4 overlayTex = diffuse;\r\n\r\n        vec3 finalColor = vec3(\r\n            overlayBlend(overlayTex.r, backGround.r),\r\n            overlayBlend(overlayTex.g, backGround.g),\r\n            overlayBlend(overlayTex.b, backGround.b)\r\n        );\r\n\r\n        vec3 mainTexVisible = backGround.rgb * (1.0 - overlayTex.a);\r\n        vec3 overlayTexVisible = finalColor.rgb * (overlayTex.a);\r\n        finalColor = (mainTexVisible + overlayTexVisible);\r\n\r\n        diffuse = vec4(finalColor, backGround.a);\r\n    } else if (uBlendMode == 5) {\r\n        // AlphaStraight\r\n        vec4 overlayTex = diffuse;\r\n\r\n        //float alphaMult = 1.0;\r\n        //vec3 finalColor = vec3(\r\n        //    alphaStraightBlend(overlayTex.r, backGround.r, alphaMult*overlayTex.a),\r\n        //    alphaStraightBlend(overlayTex.g, backGround.g, alphaMult*overlayTex.a),\r\n        //    alphaStraightBlend(overlayTex.b, backGround.b, alphaMult*overlayTex.a)\r\n        //);\r\n        vec3 finalColor = overlayTex.rgb * overlayTex.a + backGround.rgb * (1.0 - overlayTex.a);\r\n\r\n        diffuse = vec4(finalColor.rgb, 1.0);\r\n    } else if (uBlendMode == 0 || uBlendMode == 4 || uBlendMode == 6 || uBlendMode == 7) {\r\n        // default, Screen, InferAlphaBlend, Unknown1\r\n        if (diffuse.a < 0.001) discard;\r\n\r\n        vec3 finalColor = mix(backGround.rgb, diffuse.rgb, diffuse.a);\r\n\r\n        diffuse = vec4(finalColor.rgb, 1.0);\r\n    }\r\n\r\n    gl_FragColor = diffuse;\r\n}"], null, null),
              s.k = Qe(t, [pr, "precision mediump float;\r\n\r\nvarying vec2 vTextCoords;\r\nuniform sampler2D uDiffuseTexture;\r\nuniform sampler2D uSpecularTexture;\r\nuniform sampler2D uEmissiveTexture;\r\nuniform sampler2D renderResultTexture;\r\nuniform int uBlendMode;\r\n\r\nvoid main() {\r\n    vec4 diffuse = texture2D( uDiffuseTexture, vTextCoords.xy );\r\n    vec4 specular = texture2D( uSpecularTexture, vTextCoords.xy );\r\n    if (diffuse.a < 0.001) discard;\r\n    gl_FragColor = vec4(specular.rgb, 1.0);\r\n}"], null, null),
              s.j = Qe(t, [pr, "precision mediump float;\r\n\r\nvarying vec2 vTextCoords;\r\nuniform sampler2D uDiffuseTexture;\r\nuniform sampler2D uSpecularTexture;\r\nuniform sampler2D uEmissiveTexture;\r\nuniform sampler2D renderResultTexture;\r\nuniform int uBlendMode;\r\nuniform vec2 screenResolution;\r\nuniform float emissiveAlphaOverride;\r\nuniform int layer;\r\n\r\nvoid main() {\r\n    vec4 diffuse = texture2D( uDiffuseTexture, vTextCoords.xy );\r\n    vec4 emissive = texture2D( uEmissiveTexture, vTextCoords.xy );\r\n    vec4 backGround = texture2D( renderResultTexture, gl_FragCoord.xy / screenResolution );\r\n\r\n    if (diffuse.a < 0.001) discard;\r\n//    if (emissive.a < 0.001) discard;\r\n\r\n    //TODO: This is a hack from what was observed in Nightborne texture customization with tatoos.\r\n    //TODO: But Maybe switch should be over layer or something else instead of blend\r\n    float alpha = 1.0;\r\n\r\n    if (emissiveAlphaOverride > -1.0) {\r\n        alpha = emissiveAlphaOverride;\r\n    } else if (layer <= 1) {\r\n        alpha = 0.0;\r\n    } else {\r\n        alpha = emissive.a;\r\n    }\r\n\r\n    gl_FragColor = vec4(emissive.rgb, alpha);\r\n}"], null, null),
              s.c = {},
              s.h = t.createBuffer(),
              t.bindBuffer(t.ARRAY_BUFFER, s.h),
              t.bufferData(t.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.STATIC_DRAW),
              t.bindBuffer(t.ARRAY_BUFFER, null),
              s.b = t.createBuffer(),
              t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s.b),
              t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Int16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW),
              t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null),
              s.i = t.createFramebuffer(),
              s.g = {
                  loc: t.getAttribLocation(s.a.program, "aTextCoord"),
                  type: t.FLOAT,
                  size: 2,
                  offset: 0,
                  stride: 0
              },
              s
          }(t)
      }
      k() {
          let t = this.g;
          this.j || (this.j = t.createTexture(),
          t.bindTexture(t.TEXTURE_2D, this.j),
          t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.a, this.m, 0, t.RGBA, t.UNSIGNED_BYTE, null),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR)),
          this.d || (this.d = t.createTexture(),
          t.bindTexture(t.TEXTURE_2D, this.d),
          t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.a, this.m, 0, t.RGBA, t.UNSIGNED_BYTE, null),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR)),
          this.p || (this.p = t.createTexture(),
          t.bindTexture(t.TEXTURE_2D, this.p),
          t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.a, this.m, 0, t.RGBA, t.UNSIGNED_BYTE, null),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR)),
          this.b || (this.b = t.createTexture(),
          t.bindTexture(t.TEXTURE_2D, this.b),
          t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.a, this.m, 0, t.RGBA, t.UNSIGNED_BYTE, null),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR),
          t.bindTexture(t.TEXTURE_2D, null)),
          t.bindFramebuffer(t.FRAMEBUFFER, this.h.i),
          t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.d, 0),
          t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT),
          t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.p, 0),
          t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT),
          t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.b, 0),
          t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT),
          t.useProgram(this.h.k.program),
          t.bindBuffer(t.ARRAY_BUFFER, this.h.h),
          t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.h.b),
          this.h.d.disableAll(),
          this.h.d.enable(t, [this.h.g]),
          t.viewport(0, 0, this.a, this.m)
      }
      c(t, e, i, s, r, n, a, o) {
          let h = this.g;
          this.h.c.x = e,
          this.h.c.y = i,
          this.h.c.width = s,
          this.h.c.height = r,
          this.h.c.diffuseTexWidth = t.b.k,
          this.h.c.diffuseTexHeight = t.b.e,
          null == t.e && null == t.d || (this.e = !0);
          let l = 0;
          1 == n ? l = 1 : 4 == n ? l = 2 : 6 == n ? l = 3 : 7 == n ? l = 4 : 9 == n ? l = 5 : 15 == n ? l = 6 : 16 == n && (l = 7),
          this.h.c.uBlendMode = l,
          this.h.c.screenResolution = new Float32Array([this.a, this.m]),
          this.h.c.uDiffuseTexture = null != t.b ? t.b.d : this.h.e,
          this.h.c.uSpecularTexture = null != t.e ? t.e.d : this.h.e,
          this.h.c.uEmissiveTexture = null != t.d ? t.d.d : this.h.f,
          this.h.c.renderResultTexture = null != this.j ? this.j : this.h.e,
          this.h.c.layer = a,
          this.h.c.emissiveAlphaOverride = o,
          h.disable(h.CULL_FACE),
          h.disable(h.DEPTH_TEST),
          h.disable(h.BLEND),
          h.useProgram(this.h.a.program),
          h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, this.d, 0),
          h.bindTexture(h.TEXTURE_2D, this.j),
          h.copyTexImage2D(h.TEXTURE_2D, 0, h.RGBA, 0, 0, this.a, this.m, 0),
          h.bindTexture(h.TEXTURE_2D, null),
          Ze(this.h.a, this.h.c),
          h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0),
          Ze(this.h.a, xr),
          h.useProgram(this.h.k.program),
          h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, this.p, 0),
          h.bindTexture(h.TEXTURE_2D, this.j),
          h.copyTexImage2D(h.TEXTURE_2D, 0, h.RGBA, 0, 0, this.a, this.m, 0),
          h.bindTexture(h.TEXTURE_2D, null),
          Ze(this.h.k, this.h.c),
          h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0),
          Ze(this.h.k, xr),
          h.useProgram(this.h.j.program),
          h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, this.b, 0),
          h.bindTexture(h.TEXTURE_2D, this.j),
          h.copyTexImage2D(h.TEXTURE_2D, 0, h.RGBA, 0, 0, this.a, this.m, 0),
          h.bindTexture(h.TEXTURE_2D, null),
          Ze(this.h.j, this.h.c),
          h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0),
          Ze(this.h.j, xr),
          h.useProgram(null)
      }
      l() {
          let t = this.g;
          t.bindFramebuffer(t.FRAMEBUFFER, null),
          t.bindTexture(t.TEXTURE_2D, null),
          t.enable(t.CULL_FACE),
          t.enable(t.DEPTH_TEST)
      }
      f(t) {
          if (0 == t)
              return this.d;
          if (1 == t)
              return this.p;
          if (2 == t)
              return this.b;
          throw new Error("unknown usage " + t)
      }
      i(t) {
          let e = null;
          return e = {
              d: t,
              k: this.a,
              e: this.m,
              l: !0
          },
          e
      }
      o() {
          let t = this.g;
          this.j && t.deleteTexture(this.j),
          this.d && t.deleteTexture(this.d),
          this.p && t.deleteTexture(this.p),
          this.b && t.deleteTexture(this.b),
          this.d = null,
          this.p = null,
          this.b = null,
          this.j = null,
          this.h = null,
          this.g = null
      }
      n(t) {
          switch (t) {
          case 0:
              return this.i(this.d);
          case 1:
              return this.i(this.p);
          case 2:
              return this.i(this.b);
          default:
              return null
          }
      }
  }
  function wr() {
      var t = new fi(2);
      return fi != Float32Array && (t[0] = 0,
      t[1] = 0),
      t
  }
  function yr(t, e) {
      var i = new fi(2);
      return i[0] = t,
      i[1] = e,
      i
  }
  function Ar(t, e, i) {
      return t[0] = e,
      t[1] = i,
      t
  }
  function Er(t, e, i) {
      return t[0] = e[0] * i[0],
      t[1] = e[1] * i[1],
      t
  }
  function Cr(t, e, i) {
      return t[0] = e[0] * i,
      t[1] = e[1] * i,
      t
  }
  !function() {
      var t = wr()
  }();
  function Mr() {
      var t = new fi(9);
      return fi != Float32Array && (t[1] = 0,
      t[2] = 0,
      t[3] = 0,
      t[5] = 0,
      t[6] = 0,
      t[7] = 0),
      t[0] = 1,
      t[4] = 1,
      t[8] = 1,
      t
  }
  function kr(t, e) {
      return t[0] = e[0],
      t[1] = e[1],
      t[2] = e[2],
      t[3] = e[4],
      t[4] = e[5],
      t[5] = e[6],
      t[6] = e[8],
      t[7] = e[9],
      t[8] = e[10],
      t
  }
  function Fr(t, e, i) {
      var s = e[0]
        , r = e[1]
        , n = e[2]
        , a = e[3]
        , o = e[4]
        , h = e[5]
        , l = e[6]
        , u = e[7]
        , c = e[8]
        , d = i[0]
        , f = i[1]
        , g = i[2]
        , b = i[3]
        , _ = i[4]
        , p = i[5]
        , m = i[6]
        , v = i[7]
        , x = i[8];
      return t[0] = d * s + f * a + g * l,
      t[1] = d * r + f * o + g * u,
      t[2] = d * n + f * h + g * c,
      t[3] = b * s + _ * a + p * l,
      t[4] = b * r + _ * o + p * u,
      t[5] = b * n + _ * h + p * c,
      t[6] = m * s + v * a + x * l,
      t[7] = m * r + v * o + x * u,
      t[8] = m * n + v * h + x * c,
      t
  }
  function Sr() {
      var t = new fi(4);
      return fi != Float32Array && (t[0] = 0,
      t[1] = 0,
      t[2] = 0),
      t[3] = 1,
      t
  }
  function Dr(t, e, i) {
      i *= .5;
      var s = Math.sin(i);
      return t[0] = s * e[0],
      t[1] = s * e[1],
      t[2] = s * e[2],
      t[3] = Math.cos(i),
      t
  }
  function Ir(t, e, i, s) {
      var r, n, a, o, h, l = e[0], u = e[1], c = e[2], d = e[3], f = i[0], g = i[1], b = i[2], _ = i[3];
      return (n = l * f + u * g + c * b + d * _) < 0 && (n = -n,
      f = -f,
      g = -g,
      b = -b,
      _ = -_),
      1 - n > di ? (r = Math.acos(n),
      a = Math.sin(r),
      o = Math.sin((1 - s) * r) / a,
      h = Math.sin(s * r) / a) : (o = 1 - s,
      h = s),
      t[0] = o * l + h * f,
      t[1] = o * u + h * g,
      t[2] = o * c + h * b,
      t[3] = o * d + h * _,
      t
  }
  var Rr, Ur, Or, Pr, Br, zr, Nr = Cs, Gr = Ms, jr = Is;
  Rr = gi(),
  Ur = _i(1, 0, 0),
  Or = _i(0, 1, 0),
  Pr = Sr(),
  Br = Sr(),
  zr = Mr();
  class Lr {
      constructor() {
          this.e = -1,
          this.c = null,
          this.b = 0,
          this.d = -1,
          this.a = !1
      }
  }
  class Hr {
      constructor() {
          this.c = new Lr,
          this.e = new Lr,
          this.d = new Lr,
          this.f = 0,
          this.b = 1,
          this.a = !1
      }
  }
  class Vr {
      i() {
          var t = this;
          if (t.l)
              for (var e = 0; e < t.l.length; ++e)
                  t.l[e] = null;
          return t.d = null,
          t.l = null,
          null
      }
      g(t, e, i, s) {
          let r = this;
          if (null == s && (s = this.k()),
          this.j >= 0 && (t = this.j < e.length ? e[this.j] : e[0]),
          0 != r.b || r.l.length > 1) {
              if (r.d.length > 1) {
                  for (var n = -1, a = r.d.length - 1, o = 0; o < a; ++o)
                      if (t >= r.d[o] && t <= r.d[o + 1]) {
                          n = o;
                          break
                      }
                  if (-1 == n && (n = r.d.length - 1),
                  1 == r.b) {
                      var h = r.d[n]
                        , l = r.d[n + 1]
                        , u = 0;
                      return t > l ? (u = 1,
                      console.log("time > t2")) : h != l && (u = (t - h) / (l - h)),
                      u = Math.max(0, Math.min(1, u)),
                      r.f(r.l[n], r.l[n + 1], u, s)
                  }
                  return s = r.a(s, r.l[n])
              }
              return r.l.length > 0 ? s = r.a(s, r.l[0]) : i
          }
          return 0 == r.l.length ? s : s = r.a(s, r.l[0])
      }
      h(t) {
          var e, i = this;
          i.b = t.getInt16(),
          i.j = t.getInt16(),
          i.e = t.getBool();
          var s = t.getInt32();
          for (i.d = new Array(s),
          e = 0; e < s; ++e)
              i.d[e] = t.getInt32();
          var r = t.getInt32();
          for (i.l = new Array(r),
          e = 0; e < r; ++e)
              i.l[e] = i.c(t)
      }
  }
  class qr extends Vr {
      constructor(t) {
          super();
          this.ba = gi(),
          this.h(t)
      }
      k() {
          return gi()
      }
      f(t, e, i, s) {
          return Di(s, t, e, i)
      }
      a(t, e) {
          return pi(t, e),
          t
      }
      c(t) {
          return mi(gi(), t.getFloat(), t.getFloat(), t.getFloat())
      }
  }
  class Xr extends Vr {
      constructor(t) {
          super();
          this.h(t),
          this.ba = Sr()
      }
      k() {
          return Sr()
      }
      f(t, e, i, s) {
          return Ir(s, t, e, i)
      }
      a(t, e) {
          return Nr(t, e),
          t
      }
      c(t) {
          let e = t.getFloat()
            , i = t.getFloat()
            , s = t.getFloat()
            , r = t.getFloat();
          const n = Gr(Sr(), -e, -i, -s, r);
          return jr(n, n),
          n
      }
  }
  class Wr extends Vr {
      constructor(t) {
          super();
          this.h(t)
      }
      c(t) {
          return t.getUint16()
      }
      k() {
          return 0
      }
      f(t, e, i, s) {
          return t + (e - t) * i
      }
      a(t, e) {
          return e
      }
  }
  class Zr extends Wr {
      c(t) {
          return t.getFloat()
      }
  }
  class Kr extends Wr {
      c(t) {
          return t.getUint8()
      }
  }
  class Yr {
      d() {
          for (var t = this, e = 0; e < t.a.length; ++e)
              t.a[e] = null;
          return t.f = null,
          t.a = null,
          t.h = null,
          null
      }
      c(t, e, i, s) {
          let r = this;
          i || (i = this.g());
          let n = s || r.a;
          if (r.a.length > 1 && r.f.length > 1) {
              for (var a = -1, o = r.f.length, h = 0; h < o - 1; ++h)
                  if (t >= r.f[h] && t <= r.f[h + 1]) {
                      a = h;
                      break
                  }
              -1 == a && (a = r.f.length - 1);
              var l = r.f[a]
                , u = r.f[a + 1]
                , c = 0;
              return l != u && (c = (t - l) / (u - l)),
              r.i(n[a], n[a + 1], c, i)
          }
          return n.length > 0 ? i = r.j(i, n[0]) : e
      }
      e(t) {
          var e, i = this, s = t.getInt32();
          for (i.f = new Array(s),
          e = 0; e < s; ++e)
              i.f[e] = t.getInt16() / 32767;
          var r = t.getInt32();
          for (i.a = new Array(r),
          e = 0; e < r; ++e)
              i.a[e] = i.b(t)
      }
  }
  class Jr extends Yr {
      constructor(t) {
          super();
          this.ba = wr(),
          this.e(t)
      }
      g() {
          return wr()
      }
      i(t, e, i, s) {
          return r = s,
          a = e,
          o = i,
          h = (n = t)[0],
          l = n[1],
          r[0] = h + o * (a[0] - h),
          r[1] = l + o * (a[1] - l),
          r;
          var r, n, a, o, h, l
      }
      j(t, e) {
          var i, s;
          return s = e,
          (i = t)[0] = s[0],
          i[1] = s[1],
          t
      }
      b(t) {
          return Ar(wr(), t.getFloat(), t.getFloat())
      }
  }
  class Qr extends Yr {
      constructor(t) {
          super();
          this.e(t)
      }
      g() {
          return gi()
      }
      i(t, e, i, s) {
          return Di(s, t, e, i)
      }
      j(t, e) {
          return pi(t, e),
          t
      }
      b(t) {
          return mi(gi(), t.getFloat(), t.getFloat(), t.getFloat())
      }
  }
  class $r extends Yr {
      constructor(t) {
          super();
          this.e(t)
      }
      g() {
          return 0
      }
      i(t, e, i, s) {
          return t + (e - t) * i
      }
      j(t, e) {
          return t
      }
      b(t) {
          return t.getUint16()
      }
  }
  class tn {
      constructor(t, e) {
          this.e(t, e)
      }
      e(t, e) {
          var i = t.getInt32();
          this.c = new Array(i);
          for (let s = 0; s < i; ++s)
              this.c[s] = new e(t)
      }
      d(t) {
          return !(!this.c || 0 == this.c.length) && (t >= this.c.length && (t = 0),
          this.c[t].e)
      }
      b(t, e, i, s) {
          if (!this.c || 0 == this.c.length)
              return i;
          let r = t.e.e;
          r >= this.c.length && (r = 0);
          let n = this.c[r].g(t.e.b, e, i, s);
          if (t.f > 0 && t.f < 1) {
              let s = this.c[0].k()
                , r = t.d.e;
              r >= this.c.length && (r = 0);
              let a = this.c[r].g(t.d.b, e, i, s);
              a || (a = s),
              s = this.c[0].k(),
              n = a
          }
          return n
      }
      a() {
          if (this.c && 0 != this.c.length) {
              for (var t = 0; t < this.c.length; ++t)
                  this.c[t].i(),
                  this.c[t] = null;
              return null
          }
      }
  }
  function en(t, e) {
      return Es(t[4 * e + 0], t[4 * e + 1], t[4 * e + 2], 0)
  }
  function sn(t, e, i) {
      for (let s = 0; s < 4; s++)
          t[4 * e + s] = i[s]
  }
  const rn = class {
      constructor(t, e, i) {
          this.e = t,
          this.q = i,
          this.j = null,
          this.l = null,
          this.A = null,
          this.b = Bi(),
          this.v = Bi(),
          this.o = Bi();
          const s = this;
          s.s = e,
          s.u = gi(),
          s.i = Bi(),
          s.z = Bi(),
          s.y = Bi(),
          s.x = gi(),
          s.m = Sr(),
          s.d = Bi(),
          s.w = !1,
          s.k = !1,
          s.a = !1
      }
      r() {
          var t = this;
          t.u = null,
          t.i = null,
          t.x = null,
          t.m = null,
          t.d = null
      }
      c() {
          this.w = !0;
          for (var t = 0; t < 16; ++t)
              this.i[t] = 0
      }
      p(t) {
          t ? (null == this.j && (this.j = new Hr),
          this.e.V(t, this.j)) : this.j = null;
          let e = this.e.I[this.s];
          for (let i = 0; i < e.length; i++)
              this.e.K[e[i]].p(t)
      }
      f(t) {
          t ? (null == this.l && (this.l = new Hr),
          this.e.V(t, this.l)) : this.l = null;
          let e = this.e.I[this.s];
          for (let i = 0; i < e.length; i++)
              this.e.K[e[i]].f(t)
      }
      t(t) {
          const e = this.q;
          var i = this;
          if (i.w)
              return void i.c();
          if (null != this.j && this.e.aK(this.j, t),
          i.k || i.a)
              return;
          if (i.k = !0,
          !i.e)
              return;
          Gi(i.i);
          var s = i.e.ab;
          if (!s)
              return;
          let r = this.v;
          if (Gi(r),
          Hi(r, r, this.e.Q.viewMatrix),
          Hi(r, r, this.e.X),
          Hi(i.i, i.i, r),
          e.f > -1) {
              i.e.K[e.f].t(t);
              let s = this.o;
              if (zi(s, i.e.K[e.f].i),
              Hi(s, r, s),
              1 & e.g || 2 & e.g || 4 & e.g) {
                  if (4 & e.g && 2 & e.g)
                      sn(s, 0, en(r, 0)),
                      sn(s, 1, en(r, 1)),
                      sn(s, 2, en(r, 2));
                  else if (4 & e.g) {
                      {
                          let t = en(r, 0)
                            , e = Ds(t);
                          Ss(t, t, Ds(en(s, 0)) / e),
                          sn(s, 0, t)
                      }
                      {
                          let t = en(r, 1)
                            , e = Ds(t);
                          Ss(t, t, Ds(en(s, 1)) / e),
                          sn(s, 1, t)
                      }
                      {
                          let t = en(r, 2)
                            , e = Ds(t);
                          Ss(t, t, Ds(en(s, 2)) / e),
                          sn(s, 2, t)
                      }
                  } else if (2 & e.g) {
                      {
                          let t = en(r, 0);
                          Ss(t, t, 1 / Ds(en(s, 0))),
                          Ss(t, t, Ds(en(r, 0))),
                          sn(s, 0, t)
                      }
                      {
                          let t = en(r, 1);
                          Ss(t, t, 1 / Ds(en(s, 1))),
                          Ss(t, t, Ds(en(r, 1))),
                          sn(s, 1, t)
                      }
                      {
                          let t = en(r, 2);
                          Ss(t, t, 1 / Ds(en(s, 2))),
                          Ss(t, t, Ds(en(r, 2))),
                          sn(s, 2, t)
                      }
                  }
                  if (1 & e.g)
                      sn(s, 3, en(r, 3));
                  else {
                      let t = Es(e.h[0], e.h[1], e.h[2], 1)
                        , n = As();
                      Cs(n, t),
                      n[3] = 0;
                      let a = As()
                        , o = As();
                      Rs(a, t, i.e.K[i.q.f].i),
                      Rs(a, a, r),
                      Rs(o, n, s),
                      Fs(a, a, o),
                      a[3] = 1,
                      sn(s, 3, a)
                  }
              }
              let n = this.b;
              Li(n, r),
              Hi(s, n, s),
              Hi(i.i, i.i, s)
          }
          let n = null;
          if (null != this.j) {
              let t = this.n(this.j);
              this.e.aE || (this.g = t),
              this.e.aA || (n = this.e.aE ? this.g : t)
          } else {
              let t = this.n(s);
              this.e.aE || (this.g = t),
              this.e.aA || (n = this.e.aE ? this.g : t)
          }
          let a = null;
          if (null != this.l) {
              let t = this.n(this.l);
              this.e.aE || (this.h = t),
              a = this.e.aE ? this.h : t
          }
          let o = null != n || null != a
            , h = Bi();
          o && (null != n && Hi(h, h, n),
          null != a && Hi(h, h, a)),
          null != this.A && (Vi(h, h, this.q.h),
          Hi(h, h, this.A),
          Vi(h, h, Mi(this.x, this.q.h))),
          Hi(i.i, i.i, h);
          let l = 120 & e.g;
          if (l) {
              let t = Bi();
              zi(t, i.i);
              let e = i.i
                , s = gi();
              Yi(s, i.i);
              let r = As();
              if (16 == l) {
                  let t = en(i.i, 0);
                  Ss(t, t, 1 / bi(t)),
                  sn(i.i, 0, t);
                  let s = Es(e[4], -e[0], 0, 0);
                  sn(e, 1, Is(s, s)),
                  Si(r, s, t),
                  r[3] = 0,
                  sn(e, 2, r)
              } else if (l > 16) {
                  if (32 == l) {
                      let t = en(e, 1);
                      Ss(t, t, 1 / Ds(t)),
                      sn(i.i, 1, t);
                      let s = Es(-e[5], e[1], 0, 0);
                      sn(e, 0, Is(s, s)),
                      r[3] = 0,
                      sn(e, 2, r)
                  } else if (64 == l) {
                      let t = en(e, 2);
                      Is(t, t),
                      sn(e, 2, t);
                      let i = Es(t[1], -t[0], 0, 0);
                      Is(i, i),
                      sn(e, 1, i),
                      Si(r, t, i),
                      r[3] = 0,
                      sn(e, 0, r)
                  }
              } else if (8 == l) {
                  let t = this.e.isMirrored;
                  if (o) {
                      let i = en(h, 0);
                      i = Es(i[1], i[2], -i[0], 0),
                      Is(i, i),
                      sn(e, 0, i);
                      let s = en(h, 1);
                      s = Es(t ? -s[1] : s[1], t ? -s[2] : s[2], t ? s[0] : -s[0], 0),
                      Is(s, s),
                      sn(e, 1, s);
                      let r = en(h, 2);
                      r = Es(r[1], r[2], -r[0], 0),
                      Is(r, r),
                      sn(e, 2, r)
                  } else {
                      sn(e, 0, Es(0, 0, -1, 0)),
                      sn(e, 1, Es(t ? -1 : 1, 0, 0, 0)),
                      sn(e, 2, Es(0, 1, 0, 0))
                  }
              }
              let n = Es(this.q.h[0], this.q.h[1], this.q.h[2], 1)
                , a = Es(this.q.h[0], this.q.h[1], this.q.h[2], 0)
                , u = en(e, 0)
                , c = en(e, 1)
                , d = en(e, 2);
              Ss(u, u, s[0]),
              Ss(c, c, s[1]),
              Ss(d, d, s[2]),
              sn(e, 0, u),
              sn(e, 1, c),
              sn(e, 2, d),
              Rs(n, n, t),
              Rs(a, a, e);
              let f = As();
              Fs(f, n, a),
              f[3] = 1,
              sn(e, 3, f)
          }
          Li(r, r),
          Hi(i.i, r, i.i),
          Li(i.z, i.i),
          ji(i.y, i.z),
          Ii(i.u, i.q.h, i.i)
      }
      n(t) {
          const e = this.q;
          var i = e.e.d(t.e.e)
            , s = e.d.d(t.e.e)
            , r = e.i.d(t.e.e);
          if (!!(640 & e.g)) {
              let y = Bi();
              return Gi(y),
              Vi(y, y, this.q.h),
              i && (this.x = e.e.b(t, this.e.O),
              Vi(y, y, this.x)),
              s && (this.m = e.d.b(t, this.e.O, Sr()),
              n = this.d,
              a = this.m,
              o = a[0],
              h = a[1],
              l = a[2],
              u = a[3],
              g = o * (c = o + o),
              b = h * c,
              _ = h * (d = h + h),
              p = l * c,
              m = l * d,
              v = l * (f = l + l),
              x = u * c,
              T = u * d,
              w = u * f,
              n[0] = 1 - _ - v,
              n[1] = b + w,
              n[2] = p - T,
              n[3] = 0,
              n[4] = b - w,
              n[5] = 1 - g - v,
              n[6] = m + x,
              n[7] = 0,
              n[8] = p + T,
              n[9] = m - x,
              n[10] = 1 - g - _,
              n[11] = 0,
              n[12] = 0,
              n[13] = 0,
              n[14] = 0,
              n[15] = 1,
              Hi(y, y, this.d)),
              r && (this.x = e.i.b(t, this.e.O),
              qi(y, y, this.x)),
              Vi(y, y, Mi(this.x, this.q.h)),
              y
          }
          var n, a, o, h, l, u, c, d, f, g, b, _, p, m, v, x, T, w;
          return null
      }
  }
  ;
  const nn = class {
      constructor(t) {
          this.c = t,
          this.d = 267320826 ^ t;
          let e = new ArrayBuffer(4);
          this.a = new DataView(e)
      }
      e() {
          let t = this.d;
          return t ^= t << 13,
          t ^= t >> 17,
          t ^= t << 5,
          this.d = t,
          t
      }
      b() {
          let t, e = this.e();
          return this.a.setInt32(0, 1065353216 | 8388607 & e),
          t = 2147483648 & e ? 2 - this.a.getFloat32(0) : this.a.getFloat32(0) - 2,
          t
      }
      f() {
          let t = this.e();
          return this.a.setInt32(0, 1065353216 | 8388607 & t),
          this.a.getFloat32(0) - 1
      }
  }
  ;
  const an = class {
      constructor() {
          this.d = 0,
          this.e = 0,
          this.g = 0,
          this.a = 0,
          this.h = gi(),
          this.j = 0,
          this.c = 0,
          this.i = 0,
          this.f = 0,
          this.b = 0
      }
  }
  ;
  const on = class {
      constructor(t, e) {
          this.j = t,
          this.b = e,
          this.e = new an
      }
      c() {
          return this.e.a + this.j.b() * this.b.aa
      }
      i() {
          return this.e.a + this.b.aa
      }
      h() {
          return this.e.g + this.b.w
      }
      g(t) {
          return this.e.g + 30518509e-12 * t * this.b.w
      }
      d() {
          let t = this.e.d;
          return t *= 1 + this.e.e * this.j.b(),
          t
      }
      k() {
          return this.e
      }
      a(t) {
          pi(t, this.e.h)
      }
  }
  ;
  const hn = class extends on {
      f(t, e) {
          let i, s = e * this.j.f(), r = this.j.b();
          i = r < 1 ? r > -1 ? Math.trunc(32767 * r + .5) : -32767 : 32767,
          t.a = i;
          let n = this.g(i);
          n < .001 && (n = .001),
          t.c = function(t, e) {
              let i = Math.abs(t)
                , s = Math.abs(e);
              return Number((i - Math.floor(i / s) * s).toPrecision(8)) * Math.sign(t)
          }(s, n),
          t.g = 65535 & this.j.e(),
          mi(t.e, this.j.b() * this.e.c * .5, this.j.b() * this.e.i * .5, 0);
          let a = this.d()
            , o = this.e.j;
          if (o < .001) {
              let e = this.e.f * this.j.b()
                , i = this.e.b * this.j.b()
                , s = Math.sin(e)
                , r = Math.sin(i)
                , n = Math.cos(e)
                , o = Math.cos(i);
              mi(t.b, o * s * a, r * s * a, n * a)
          } else {
              let e = gi();
              pi(e, t.e),
              e[2] = e[2] - o,
              bi(e) > 1e-4 && (ki(e, e),
              Ai(t.b, e, a))
          }
      }
  }
  ;
  const ln = class extends on {
      constructor(t, e, i) {
          super(t, e),
          this.ba = i
      }
      f(t, e) {
          let i, s = e * this.j.f(), r = this.j.b();
          i = r < 1 ? r > -1 ? Math.trunc(32767 * r + .5) : -32767 : 32767,
          t.a = i;
          let n = this.g(i);
          n < .001 && (n = .001),
          t.c = function(t, e) {
              let i = Math.abs(t)
                , s = Math.abs(e);
              return Number((i - Math.floor(i / s) * s).toPrecision(8)) * Math.sign(t)
          }(s, n),
          t.g = 65535 & this.j.e();
          let a = this.e.i - this.e.c
            , o = this.e.c + a * this.j.f()
            , h = this.e.f * this.j.b()
            , l = this.e.b * this.j.b()
            , u = Math.cos(h)
            , c = _i(u * Math.cos(l), u * Math.sin(l), Math.sin(h));
          Ai(t.e, c, o);
          let d = this.d()
            , f = this.e.j
            , g = _i(.5, .5, .5);
          0 == f ? this.ba ? mi(g, 0, 0, 1) : mi(g, u * Math.cos(l), u * Math.sin(l), Math.sin(h)) : (mi(g, 0, 0, f),
          xi(g, t.e, g),
          bi(g) > 1e-4 && ki(g, g)),
          Ai(t.b, g, d)
      }
  }
  ;
  const un = class {
      constructor() {
          this.e = gi(),
          this.c = 0,
          this.b = gi(),
          this.a = 0,
          this.g = 2147483647 * Math.random() | 0,
          this.f = [wr(), wr()],
          this.d = [wr(), wr()]
      }
  }
  ;
  const cn = class {
      constructor(t, e, i, s, r, n) {
          this.e = t,
          this.d = e,
          this.b = i,
          this.f = s,
          this.a = r,
          this.c = n
      }
  }
  ;
  const dn = class {
      constructor(t, e, i) {
          this.a = t,
          this.b = e,
          this.c = i
      }
  }
  ;
  let fn = new Array(128);
  for (let t = 0; t < 128; t++)
      fn[t] = Math.random();
  const gn = Ni(0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    , bn = 1e3;
  class _n {
  }
  class pn {
      constructor() {
          this.a = gi(),
          this.b = 0,
          this.c = {
              b: wr(),
              a: gi(),
              e: 0,
              c: 0,
              f: 1,
              d: 0
          }
      }
  }
  function mn(t) {
      return Es((t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255, (t >> 24 & 255) / 255)
  }
  const vn = [0, 0, 1, 2, 3, 4];
  const xn = class {
      constructor(t, e) {
          this.i = t,
          this.D = e,
          this.Z = null,
          this.E = 0,
          this.am = !0,
          this.p = null,
          this.q = (new Date).getTime(),
          this.n = e,
          this.t = Bi(),
          this.aj = Bi(),
          this.au = Bi(),
          this.ar = Bi(),
          this.s = As(),
          this.ah = Mr(),
          this.ao = gi(),
          this.r = 1,
          this.w = gi(),
          this.j = 0,
          this.K = gi(),
          this.as = gi(),
          this.ap = [],
          this.ad = gi(),
          this.ab = 0,
          this.l = 0,
          this.o = 0,
          this.S = 0,
          this.m = gi(),
          this.F = gi(),
          this.V = 0,
          this.z = 0,
          this.H = 0,
          this.u = 0,
          this.aq = 0,
          this.e = 0,
          this.N = 0,
          this.h = [],
          this.W = [];
          for (let t = 0; t < bn; t++)
              this.W.push(4 * t + 0),
              this.W.push(4 * t + 1),
              this.W.push(4 * t + 2),
              this.W.push(4 * t + 3),
              this.W.push(4 * t + 2),
              this.W.push(4 * t + 1);
          switch (this.y = new nn(2147483647 * Math.random() | 0),
          this.n.A) {
          case 1:
              this.al = new hn(this.y,e);
              break;
          case 2:
              this.al = new ln(this.y,e,!!(256 & this.n.v));
              break;
          default:
              this.al = null,
              WH.debug("Found unimplemented generator ", this.n.A)
          }
          const i = this.n.F - this.n.c;
          0 != i ? (this.l = (this.n.Z - this.n.N) / i,
          this.o = this.n.N - this.n.c * this.l) : (this.l = 0,
          this.o = 0);
          let s = this.n.k;
          s <= 0 && (s = 1);
          let r = this.n.Q;
          r <= 0 && (r = 1),
          this.z = s * r - 1,
          this.H = 0;
          let n = s
            , a = -1;
          do {
              ++a,
              n >>= 1
          } while (n);
          if (this.u = a,
          this.aq = s - 1,
          this.H = 0,
          (32768 & this.n.v) > 0) {
              let t = (this.z + 1) * this.y.e();
              this.H = t / 4294967296 | 0
          }
          this.e = 1 / s,
          this.N = 1 / r;
          let o = !1;
          (269484032 & this.n.v) > 0 ? (o = !!(1 & this.n.v >> 28),
          this.ab = o ? 2 : 3) : this.ab = 0;
          let h = !1
            , l = !1;
          (268435456 & this.n.v) > 0 ? l = (1073741824 & this.n.v) > 0 : 1048576 & this.n.v || (h = !(1 & this.n.v)),
          2 == this.ab || 4 == this.ab && o ? this.M = l ? 3 : 2 : 3 == this.ab ? this.M = 5 : this.M = h ? 1 : 0,
          this.X = e.a > 1,
          this.B = this.i.q.c(224e3),
          this.aa = this.i.q.e(8e3),
          this.av = this.i.q.g(this.B, this.aa)
      }
      an() {
          var t = this;
          t.n.T = null,
          t.n.M = null,
          t.n.I = null,
          t.n.y = t.n.y.a(),
          t.n.D = t.n.D.a(),
          t.n.g = t.n.g.a(),
          t.n.L = t.n.L.a(),
          t.n.m = t.n.m.a(),
          t.n.d = t.n.d.a(),
          t.n.t = t.n.t.a(),
          t.n.Y = t.n.Y.a(),
          t.n.n = t.n.n.a(),
          t.n.e = t.n.e.a(),
          t.n.j = t.n.j.a(),
          t.n.l = t.n.l.d(),
          t.n.r = t.n.r.d(),
          t.n.V = t.n.V.d(),
          t.n.B = t.n.B.d(),
          t.n.C = t.n.C.d(),
          t.ap = null
      }
      c(t) {
          const e = this.D;
          e.z >= 11 && e.z <= 13 && t && (this.Q = [As(), As(), As()],
          Cs(this.Q[0], mn(t.Start[e.z - 11])),
          Cs(this.Q[1], mn(t.Mid[e.z - 11])),
          Cs(this.Q[2], mn(t.End[e.z - 11])))
      }
      ai(t) {
          this.Z = t
      }
      at() {
          if (this.p)
              return;
          this.i.Q.context;
          if (!this.I)
              if (this.I = [null, null, null],
              268435456 & this.n.v)
                  for (let t = 0; t < this.n.J.length; t++) {
                      const e = this.n.J[t];
                      e > -1 && e < this.i.u.length && (this.I[t] = this.i.u[e])
                  }
              else
                  this.n.P > -1 && this.n.P < this.i.u.length && (this.I[0] = this.i.u[this.n.P]);
          let t = !0;
          for (let e of this.I)
              t = t && (!e || e.e && e.e.l);
          if (!t)
              return;
          const e = this.i.q;
          let i = this.n.a;
          4 == i && (i = 3);
          let s = {};
          s.uViewMatrix = this.i.Q.viewMatrix,
          s.uProjMatrix = this.i.Q.projMatrix,
          s.uBlendMode = this.n.a,
          s.uPixelShader = vn[this.M],
          s.colorMult = this.Z ? this.Z.d : 1,
          s.alphaMult = this.Z ? this.Z.c : 1;
          let r = [this.I[0] && this.I[0].e && this.I[0].e.l, this.I[1] && this.I[1].e && this.I[1].e.l, this.I[2] && this.I[2].e && this.I[2].e.l];
          s.uTexture = this.I[0].e.d,
          s.uTexture2 = r[1] ? this.I[1].e.d : null,
          s.uTexture3 = r[2] ? this.I[2].e.d : null,
          s.uHasTexture = r[0] ? 1 : 0,
          s.uHasTexture2 = r[1] ? 1 : 0,
          s.uHasTexture3 = r[2] ? 1 : 0;
          let n = -1;
          1 == i ? n = .501960814 : i > 1 && (n = 1 / 255),
          s.uAlphaTreshold = n;
          const a = e.b(this.i.C, new cn(!1,!this.i.m,i,!0,!1,15), new cs(this.I.map((t => t && t.e)),s));
          this.p = e.k(new dn(this.av,0,0), a, 0, this.n.q)
      }
      U(t, e) {
          if (!this.al)
              return;
          let i = Bi()
            , s = this.al.k()
            , r = !0;
          this.n.j.d(t.e.e) && (r = this.n.j.b(t, this.i.O) > 0),
          this.ag = r;
          const n = _i(0, 0, 0);
          r && (s.d = this.n.y.b(t, this.i.O, 0),
          s.e = this.n.D.b(t, this.i.O, 0),
          s.f = this.n.g.b(t, this.i.O, 0),
          s.b = this.n.L.b(t, this.i.O, 0),
          this.n.m.b(t, this.i.O, n, s.h),
          s.g = this.n.d.b(t, this.i.O, 0),
          s.a = this.n.t.b(t, this.i.O, 0),
          s.i = this.n.n.b(t, this.i.O, 0),
          s.c = this.n.Y.b(t, this.i.O, 0),
          this.Z ? s.j = this.Z.a : s.j = this.n.e.b(t, this.i.O, 0)),
          Hi(i, i, this.i.X),
          Hi(i, i, this.i.K[this.n.G].i);
          let a = Bi();
          var o, h;
          o = a,
          h = _i(this.n.T[0], this.n.T[1], this.n.T[2]),
          o[0] = 1,
          o[1] = 0,
          o[2] = 0,
          o[3] = 0,
          o[4] = 0,
          o[5] = 1,
          o[6] = 0,
          o[7] = 0,
          o[8] = 0,
          o[9] = 0,
          o[10] = 1,
          o[11] = 0,
          o[12] = h[0],
          o[13] = h[1],
          o[14] = h[2],
          o[15] = 1,
          Hi(i, i, a),
          Hi(i, i, gn);
          let l = Bi()
            , u = gi();
          Li(l, this.i.Q.viewMatrix),
          Ki(u, l),
          this.ak(e, i, u, null, this.i.Q.viewMatrix),
          this.k(this.i.Q.viewMatrix),
          this.B.b(new Float32Array(this.h)),
          this.aa.b(new Uint16Array(this.W)),
          this.p && (this.p.e = 6 * this.E | 0,
          this.p.a = 0)
      }
      x(t) {
          if (this.ap.length <= 0)
              return;
          if (this.p || this.at(),
          !this.p)
              return;
          if (!t && this.p.g.b() > $s.GxBlend_AlphaKey)
              return;
          this.i.q.i().e(this.p)
      }
      J(t, e) {
          if (!(16 & this.n.v))
              for (let i = 0; i < this.ap.length; i++) {
                  const s = this.ap[i];
                  Ii(s.e, s.e, t),
                  Ri(s.b, s.b, e)
              }
      }
      ak(t, e, i, s, r) {
          if (null == this.al)
              return;
          if (this.i.aE)
              return;
          Ki(this.w, this.t);
          let n = As();
          Ki(n, e),
          n[3] = 1,
          Rs(n, n, r),
          this.j = n[2];
          let a = gi();
          if (Ki(a, r),
          this.ae(e, a, s),
          t > 0) {
              let e = gi();
              if (Ki(e, this.t),
              16384 & this.n.v) {
                  xi(this.as, e, this.w);
                  let i = this.l * (bi(this.as) / t) + this.o;
                  i >= 0 && (i = Math.min(i, 1)),
                  Ai(this.K, this.as, i)
              }
              if (64 & this.n.v) {
                  this.S += t;
                  let i = .03;
                  if (this.S > i)
                      if (this.S = 0,
                      0 == this.ap.length) {
                          let t = i / this.S
                            , s = gi();
                          xi(s, e, this.w);
                          let r = t * this.n.E;
                          Ti(this.m, s, _i(r, r, r))
                      } else
                          mi(this.m, 0, 0, 0)
              }
              this.R(t)
          }
      }
      ae(t, e, i) {
          if (pi(this.F, e),
          null == i || 16 & this.n.v)
              zi(this.t, t);
          else {
              let e = Bi();
              Li(e, i),
              Hi(this.t, e, t)
          }
          let s = gi();
          Yi(s, t),
          this.r = s[0]
      }
      R(t) {
          if ((t = Math.max(t, 0)) < .1)
              pi(this.K, this.as);
          else {
              let e = Math.floor(t / .1);
              t = -.1 * e + t;
              let i = Math.min(Math.floor(this.al.k().g / .1), e)
                , s = i + 1
                , r = 1;
              r = s < 0 ? (1 & s | s >> 1) + (1 & s | s >> 1) : s,
              Ai(this.K, this.as, 1 / r);
              for (let t = 0; t < i; t++)
                  this.g(.1)
          }
          this.g(t)
      }
      g(t) {
          let e = new _n;
          if (t < 0)
              return;
          this.n.v,
          this.A(e, t),
          this.G(t);
          let i = 0;
          for (; i < this.ap.length; ) {
              let s = this.ap[i];
              s.c = s.c + t,
              s.c > Math.max(this.al.g(s.g), .001) ? (this.T(i),
              i--) : this.ac(s, t, e) || (this.T(i),
              i--),
              i++
          }
      }
      A(t, e) {
          t.a = gi(),
          t.b = gi(),
          t.d = gi(),
          t.c = 0;
          let i = _i(e, e, e)
            , s = e * e * .5
            , r = _i(s, s, s);
          Ti(t.a, this.n.h, i);
          let n = gi();
          this.al.a(n),
          Ti(t.b, n, i),
          Ti(t.d, n, r),
          t.c = this.n.R * e
      }
      G(t) {
          if (!this.ag && this.am)
              return;
          let e = this.al.c();
          for (this.V = this.V + t * e; this.V > 1; )
              this.d(t),
              this.V -= 1
      }
      d(t) {
          let e = this.v();
          if (this.al.f(e, t),
          !(16 & this.n.v)) {
              let t = Es(e.e[0], e.e[1], e.e[2], 1)
                , i = Es(e.b[0], e.b[1], e.b[2], 0);
              Rs(t, t, this.t),
              Rs(i, i, this.t),
              pi(e.e, t),
              pi(e.b, i),
              8192 & this.n.v && (e.e[2] = 0)
          }
          if (64 & this.n.v) {
              let t = 1 + this.al.k().e * this.y.b()
                , i = gi();
              Ai(i, this.m, t),
              vi(e.b, e.b, i)
          }
          if (this.ab >= 2)
              for (let t = 0; t < 2; t++) {
                  e.f[t][0] = this.y.f(),
                  e.f[t][1] = this.y.f();
                  let n = wr();
                  Cr(n, this.n.u[t], this.y.b()),
                  i = e.d[t],
                  s = n,
                  r = this.n.f[t],
                  i[0] = s[0] + r[0],
                  i[1] = s[1] + r[1]
              }
          var i, s, r
      }
      v() {
          let t = new un;
          return this.ap.push(t),
          t
      }
      T(t) {
          this.ap.splice(t, 1)
      }
      ac(t, e, i) {
          if (this.ab >= 2)
              for (let i = 0; i < 2; i++) {
                  let s = t.f[i][0] + e * t.d[i][0];
                  t.f[i][0] = s - Math.floor(s),
                  s = t.f[i][1] + e * t.d[i][1],
                  t.f[i][1] = s - Math.floor(s)
              }
          vi(t.b, t.b, i.a),
          16384 & this.n.v && 2 * e < t.c && vi(t.e, t.e, this.K);
          let s = _i(e, e, e)
            , r = gi();
          if (Ti(r, t.b, s),
          vi(t.b, t.b, i.b),
          Ai(t.b, t.b, 1 - i.c),
          vi(t.e, t.e, r),
          vi(t.e, t.e, i.d),
          2 == this.n.A && 128 & this.n.v) {
              let e = gi();
              if (pi(e, t.e),
              16 & this.n.v) {
                  if (Fi(e, r) > 0)
                      return !1
              } else {
                  let i = gi();
                  if (Ki(i, this.t),
                  xi(e, t.e, i),
                  Fi(e, r) > 0)
                      return !1
              }
          }
          return !0
      }
      k(t) {
          if (this.h.length = 0,
          0 == this.ap.length && null != this.al)
              return;
          Li(this.au, t),
          kr(Mr(), t),
          this.O(null, t);
          let e = 0;
          for (let t = 0; t < this.ap.length; t++) {
              let i = this.ap[t]
                , s = new pn;
              if (this.b(i, s) && (131072 & this.n.v && (this.P(i, s),
              e++),
              262144 & this.n.v && (this.C(i, s),
              e++)),
              e >= bn)
                  break
          }
          this.E = e
      }
      O(t, e) {
          var i, s, r;
          16 & this.n.v ? Hi(this.ar, e, this.t) : null != t ? Hi(this.ar, e, t) : zi(this.ar, e),
          Ki(this.s, e),
          4096 & this.n.v && (kr(this.ah, this.ar),
          16 & this.n.v && Math.abs(this.r) > 0 && (i = this.ah,
          s = this.ah,
          r = 1 / this.r,
          i[0] = s[0] * r,
          i[1] = s[1] * r,
          i[2] = s[2] * r,
          i[3] = s[3] * r,
          i[4] = s[4] * r,
          i[5] = s[5] * r,
          i[6] = s[6] * r,
          i[7] = s[7] * r,
          i[8] = s[8] * r),
          mi(this.ao, this.ah[6], this.ah[7], this.ah[8]),
          Ci(this.ao) <= 2.3841858e-7 ? mi(this.ao, 0, 0, 1) : ki(this.ao, this.ao))
      }
      a(t) {
          let e = 0
            , i = 0;
          if (0 != this.n.O || 0 != this.n.U) {
              let s = new nn(t.g);
              e = 0 == this.n.K ? this.n.O : this.n.O + s.b() * this.n.K,
              i = 0 == this.n.U ? this.n.p : this.n.p + s.b() * this.n.U
          } else
              e = this.n.O,
              i = this.n.p;
          return {
              deltaSpin: i,
              baseSpin: e
          }
      }
      b(t, e) {
          let i = this.n.W
            , s = this.n.H
            , r = s[0]
            , n = s[1] - r
            , a = 0
            , o = t.g
            , h = t.c;
          if ((i < 1 || 0 != n) && (a = 127 & h * this.n.X + o),
          i < fn[a])
              return 0;
          this.f(t, e, o);
          let l = n * fn[a] + r;
          Cr(e.c.b, e.c.b, l),
          32 & this.n.v && Cr(e.c.b, e.c.b, this.r);
          let u = Es(t.e[0], t.e[1], t.e[2], 1);
          return Rs(u, u, this.ar),
          pi(e.a, u),
          e.b = 1,
          1
      }
      f(t, e, i) {
          let s = t.c / this.al.h()
            , r = new nn(i);
          Math.min(s, 1) <= 0 ? s = 0 : s >= 1 && (s = 1);
          let n = _i(255, 255, 255)
            , a = yr(1, 1)
            , o = 1
            , h = e.c;
          this.n.l.c(s, n, h.a, this.Q),
          this.Q || Ai(h.a, h.a, 1 / 255),
          this.n.V.c(s, a, h.b),
          h.f = this.n.r.c(s, 32767) / 32767,
          this.Z ? h.d = this.Z.b.c(s, 0) / 32767 : h.d = 0;
          let l = 0;
          this.n.B.f.length > 0 ? (o = 0,
          h.e = this.n.B.c(s, o),
          h.e = this.z & h.e + this.H) : 65536 & this.n.v ? (l = (this.z + 1) * r.e(),
          h.e = l / 4294967296 | 0) : h.e = 0,
          o = 0,
          h.c = this.n.C.c(s, o),
          h.c = h.c + this.H & this.z;
          let u = 1;
          524288 & this.n.v ? (u = Math.max(1 + r.b() * this.n.b[1], 99999997e-12),
          h.b[0] = Math.max(1 + r.b() * this.n.b[0], 99999997e-12) * h.b[0]) : (u = Math.max(1 + r.b() * this.n.b[0], 99999997e-12),
          h.b[0] = u * h.b[0]),
          h.b[1] = u * h.b[1]
      }
      P(t, e) {
          let i = yr((e.c.e & this.aq) * this.e, (e.c.e >> this.u) * this.N)
            , s = 0
            , r = 0
            , n = this.a(t);
          s = n.baseSpin,
          r = n.deltaSpin;
          let a = 0
            , o = _i(0, 0, 0)
            , h = _i(0, 0, 0)
            , l = !1
            , u = !1;
          if (4 & this.n.v && Ci(t.b) > 2.3841858e-7)
              if (a = 1,
              4096 & this.n.v)
                  l = !0;
              else {
                  let i = Es(-t.b[0], -t.b[1], -t.b[2], 0);
                  Rs(i, i, this.ar);
                  let s = gi();
                  pi(s, i);
                  let r = 0
                    , n = Ci(s);
                  r = n <= 2.3841858e-7 ? 0 : 1 / Math.sqrt(n);
                  let a = gi();
                  pi(a, s),
                  Ai(a, a, r),
                  pi(o, a),
                  Ai(o, o, e.c.b[0]),
                  h = _i(a[1], -a[0], 0),
                  Ai(h, h, e.c.b[1]),
                  u = !0,
                  l = !1
              }
          if ((4096 & this.n.v || l) && !u) {
              let i = Mr();
              c = i,
              d = this.ah,
              c[0] = d[0],
              c[1] = d[1],
              c[2] = d[2],
              c[3] = d[3],
              c[4] = d[4],
              c[5] = d[5],
              c[6] = d[6],
              c[7] = d[7],
              c[8] = d[8];
              let n = e.c.b[0];
              if (a) {
                  let s = 0
                    , r = _i(-t.b[0], -t.b[1], -t.b[2])
                    , a = Ci(r);
                  s = a <= 2.3841858e-7 ? 0 : 1 / Math.sqrt(a),
                  Fr(i, this.ah, function(t, e, i, s, r, n, a, o, h) {
                      var l = new fi(9);
                      return l[0] = t,
                      l[1] = e,
                      l[2] = i,
                      l[3] = s,
                      l[4] = r,
                      l[5] = n,
                      l[6] = a,
                      l[7] = o,
                      l[8] = h,
                      l
                  }(r[0] * s, r[1] * s, 0, -r[1] * s, r[0] * s, 0, 0, 0, 1)),
                  s > 2.3841858e-7 && (n = e.c.b[0] * (1 / Math.sqrt(Ci(t.b)) / s))
              }
              if (this.ab,
              mi(o, i[0], i[1], i[2]),
              Ai(o, o, n),
              mi(h, i[3], i[4], i[5]),
              Ai(h, h, e.c.b[1]),
              r = h[0],
              u = !0,
              0 != this.n.p || 0 != this.n.U) {
                  let e = s + r * t.c;
                  512 & this.n.v && 1 & t.g && (e = -e);
                  let i = gi();
                  pi(i, this.ao),
                  this.ab;
                  let n = Mr()
                    , a = Sr();
                  Dr(a, i, e),
                  function(t, e) {
                      var i = e[0]
                        , s = e[1]
                        , r = e[2]
                        , n = e[3]
                        , a = i + i
                        , o = s + s
                        , h = r + r
                        , l = i * a
                        , u = s * a
                        , c = s * o
                        , d = r * a
                        , f = r * o
                        , g = r * h
                        , b = n * a
                        , _ = n * o
                        , p = n * h;
                      t[0] = 1 - c - g,
                      t[3] = u - p,
                      t[6] = d + _,
                      t[1] = u + p,
                      t[4] = 1 - l - g,
                      t[7] = f - b,
                      t[2] = d - _,
                      t[5] = f + b,
                      t[8] = 1 - l - c
                  }(n, a),
                  Ri(o, o, n),
                  mi(h, r, h[1], h[2]),
                  Ri(h, h, n)
              }
          }
          var c, d;
          if (!u)
              if (0 != this.n.p || 0 != this.n.U) {
                  let i = s + r * t.c;
                  512 & this.n.v && 1 & t.g && (i = -i);
                  let n = Math.cos(i)
                    , a = Math.sin(i);
                  mi(o, n, a, 0),
                  Ai(o, o, e.c.b[0]),
                  mi(h, -a, n, 0),
                  Ai(h, h, e.c.b[1]),
                  134217728 & this.n.v && vi(e.a, e.a, _i(h[0], h[1], 0))
              } else
                  mi(o, e.c.b[0], 0, 0),
                  mi(h, 0, e.c.b[1], 0);
          return this.af(o, h, e.a, e.c.a, e.c.f, e.c.d, i[0], i[1], t.f),
          0
      }
      C(t, e) {
          let i = yr((e.c.c & this.aq) * this.e, (e.c.c >> this.u) * this.N)
            , s = _i(0, 0, 0)
            , r = _i(0, 0, 0)
            , n = this.n.x;
          1024 & this.n.v && (n = Math.min(t.c, n));
          let a = As();
          Ai(a, t.b, -1),
          a[3] = 0,
          Rs(a, a, this.ar),
          Ai(a, a, n);
          let o = _i(a[0], a[1], 0);
          if (Fi(o, o) > 1e-4) {
              let t = 1 / bi(o);
              Cr(e.c.b, e.c.b, t),
              Er(o, o, e.c.b),
              r = _i(-o[1], o[0], 0),
              Ai(s, a, .5),
              vi(e.a, e.a, s)
          } else
              s = _i(.05 * e.c.b[0], 0, 0),
              r = _i(0, .05 * e.c.b[1], 0);
          return this.af(s, r, e.a, e.c.a, e.c.f, e.c.d, i[0], i[1], t.f),
          1
      }
      af(t, e, i, s, r, n, a, o, h) {
          const l = [-1, -1, 1, 1]
            , u = [1, -1, 1, -1]
            , c = [0, 0, 1, 1]
            , d = [0, 1, 0, 1];
          let f = gi()
            , g = wr()
            , b = wr()
            , _ = wr();
          for (let p = 0; p < 4; p++)
              mi(f, 0, 0, 0),
              Ei(f, f, t, l[p]),
              Ei(f, f, e, u[p]),
              vi(f, f, i),
              Ar(g, c[p] * this.e + a, d[p] * this.N + o),
              Ar(b, c[p] * this.n.i[0] + h[0][0], d[p] * this.n.i[0] + h[0][1]),
              Ar(_, c[p] * this.n.i[1] + h[1][0], d[p] * this.n.i[1] + h[1][1]),
              this.h.push(f[0]),
              this.h.push(f[1]),
              this.h.push(f[2]),
              this.h.push(s[0]),
              this.h.push(s[1]),
              this.h.push(s[2]),
              this.h.push(r),
              this.h.push(g[0]),
              this.h.push(g[1]),
              this.h.push(b[0]),
              this.h.push(b[1]),
              this.h.push(_[0]),
              this.h.push(_[1]),
              this.h.push(n)
      }
  }
  ;
  class Tn {
      constructor() {
          this.b = gi(),
          this.c = As(),
          this.a = wr()
      }
  }
  class wn {
  }
  const yn = [0, 1, 2, 10, 3, 4, 5, 13];
  function An(t, e) {
      return _i(t[4 * e + 0], t[4 * e + 1], t[4 * e + 2])
  }
  const En = class {
      constructor(t, e) {
          this.am = t,
          this.T = e,
          this.m = gi(),
          this.at = gi(),
          this.t = new wn,
          this.ao = gi(),
          this.B = gi(),
          this.D = gi(),
          this.s = gi(),
          this.P = gi(),
          this.W = gi(),
          this.k = gi(),
          this.ag = gi(),
          this.x = gi(),
          this.b = gi(),
          this.an = gi(),
          this.al = gi(),
          this.av = gi(),
          this.au = t.Q.context,
          this.ah = new Array(e.a.length),
          this.v = new Array(e.a.length);
          for (let i = 0; i < e.a.length; i++)
              this.v[i] = t.P.h[e.a[i]];
          let i = Es(255, 255, 255, 255)
            , s = new wn;
          s.a = 0,
          s.b = 0,
          s.d = 1,
          s.c = 1,
          this.J(e.c, e.o, i, s, e.g, e.h),
          this.r(e.n),
          this.o(!1)
      }
      o(t) {
          this.u = t,
          this.u || (this.w = !1)
      }
      r(t) {
          this.I = t
      }
      ar() {
          return this.f == this.g
      }
      ad(t) {
          this.K = t
      }
      n(t) {
          this.a = t
      }
      S(t) {
          this.ap[3] = Math.max(t, 0)
      }
      y() {
          let t = gi();
          Oi(t, this.m, this.av);
          let e = Ci(t);
          Ai(t, this.ao, this.K),
          xi(this.k, this.m, t),
          Ai(t, this.B, this.K),
          xi(this.ag, this.av, t),
          Ai(t, this.ao, this.a),
          vi(this.x, this.m, t),
          Ai(t, this.B, this.a),
          vi(this.b, this.av, t),
          Ai(this.P, this.D, e),
          Ai(this.W, this.s, e)
      }
      Y(t, e, i) {
          let s;
          if (this.A && this.u) {
              s = t;
              let i = gi();
              Ki(i, s),
              vi(i, i, e),
              pi(this.at, e),
              this.w ? (pi(this.m, this.av),
              pi(this.D, this.s),
              pi(this.ao, this.B)) : (pi(this.m, i),
              this.D = An(s, 2),
              this.ao = An(s, 1),
              this.U = 0,
              this.w = !0),
              this.av = i,
              this.s = An(s, 2),
              this.B = An(s, 1)
          }
      }
      ae(t) {
          var e = Mr();
          kr(e, t),
          this.D = Ri(this.D, this.D, e),
          this.ao = Ri(this.ao, this.ao, e),
          this.s = Ri(this.s, this.s, e),
          this.B = Ri(this.B, this.B, e),
          this.m = Ii(this.m, this.m, t),
          this.av = Ii(this.av, this.av, t);
          for (var i = 0; i < this.af.length; i++)
              Ii(this.af[i].b, this.af[i].b, t)
      }
      c(t, e, i) {
          this.ap[2] = i,
          this.ap[1] = e,
          this.ap[0] = t
      }
      H(t) {
          if (this.L != t) {
              this.L = t;
              let e = t % this.p
                , i = e;
              2147483648 & e && (i = (1 & e | e >> 1) + (1 & e | e >> 1));
              let s = i * this.E + this.ab.b;
              this.t.b = s;
              let r = t / this.p
                , n = r;
              2147483648 & r && (r = 1 & r | r >> 1,
              n = r + r,
              s = this.t.b);
              let a = n * this.h + this.ab.a;
              this.t.a = a,
              this.t.c = s + this.E,
              this.t.d = a + this.h
          }
      }
      z(t, e, i) {
          let s, r = this.af[2 * this.g], n = this.af[2 * this.g + 1], a = gi();
          Ai(a, this.W, 1 - e),
          xi(a, this.ag, a),
          Ai(r.b, a, e),
          Ai(a, this.P, e),
          vi(a, this.k, a),
          Ai(a, a, 1 - e),
          vi(r.b, r.b, a),
          Ai(a, this.W, 1 - e),
          xi(a, this.b, a),
          Ai(n.b, a, e),
          Ai(a, this.P, e),
          vi(a, this.x, a),
          Ai(a, a, 1 - e),
          vi(n.b, n.b, a),
          this.M[this.g] = t,
          s = i,
          this.g = this.g + s,
          this.g >= this.M.length && (this.g -= this.M.length)
      }
      ac(t, e) {
          if (this.am.aE)
              return;
          let i = gi()
            , s = 1;
          i = this.T.d.b(t, this.am.O, i),
          s = this.T.p.b(t, this.am.O),
          this.c(i[0], i[1], i[2]),
          this.S(s / 32767);
          let r = this.T.m.b(t, this.am.O);
          this.n(r);
          let n = this.T.k.b(t, this.am.O);
          this.ad(n);
          let a = this.T.f.b(t, this.am.O);
          this.H(a);
          let o = this.T.r.b(t, this.am.O, 1);
          this.o(0 != o);
          let h = Bi();
          Qi(h, this.am.X, this.am.K[this.T.b].i),
          Vi(h, h, this.T.e);
          let l = gi();
          this.Y(h, l, null),
          this.Q(e, !1)
      }
      Q(t, e) {
          let i, s, r, n, a, o, h, l, u, c, d, f, g, b, _, p, m, v, x, T, w, y, A, E, C, M, k, F, S, D, I, R, U, O, P, B, z, N, G, j, L, H, V, q, X, W, Z, K;
          for (this.ak || this.F > 0 && (t = 1 / this.F + 99999997e-12),
          t >= 0 ? this.R <= t && (t = this.R) : t = 0,
          v = this.f; v != this.g && !(t + this.M[v] <= this.R); v = this.f)
              this.f = this.aj(this.f, 1);
          if (!e && this.A && this.u && this.w) {
              I = t * this.F + this.U,
              K = this.ap,
              this.y();
              let e = !1;
              if (O = 0,
              I < 1 ? e = !0 : (Z = this.U,
              U = 1 / (I - Z),
              m = Math.floor(I - 1),
              O = Math.ceil(Math.max(m, 0))),
              -1 == O || e)
                  ;
              else
                  for (R = 1,
                  v = 1; D = this.g,
                  N = this.af.length,
                  this.af[2 * D].c = K,
                  x = 2 * this.g + 1,
                  G = this.af.length,
                  this.af[x].c = K,
                  this.z((v - Z) * U * -t, (v - Z) * U, 1),
                  -1 != --O; v = R)
                      R += 1,
                      Z = this.U;
              T = Math.floor(I),
              this.U = I - T,
              this.z(0, 1, 0),
              S = this.g,
              j = this.af.length,
              w = this.af[2 * S],
              y = this.t.b,
              w.a[1] = this.t.a,
              w.a[0] = y,
              A = 2 * this.g + 1,
              L = this.af.length,
              E = this.af[A],
              C = this.t.b,
              E.a[1] = this.t.d,
              E.a[0] = C,
              F = this.g,
              H = this.af.length,
              this.af[2 * F].c = K,
              M = 2 * this.g + 1,
              V = this.af.length,
              this.af[M].c = K
          }
          this.an[2] = 34028235e31,
          this.an[1] = 34028235e31,
          this.an[0] = 34028235e31,
          this.al[2] = -34028235e31,
          this.al[1] = -34028235e31,
          this.al[0] = -34028235e31,
          P = this.f;
          for (let e = this.f; e != this.g; P = e)
              p = 2 * e,
              W = this.af.length,
              k = P,
              z = this.af[2 * e],
              i = p + 1,
              s = this.af[2 * e + 1],
              r = (this.I + this.I) * this.M[k] * t + t * this.I * t,
              z.b[2] = z.b[2] + r,
              s.b[2] = r + s.b[2],
              n = z.b[0],
              a = this.an[0],
              a > z.b[0] && (a = z.b[0],
              this.an[0] = n,
              n = z.b[0]),
              o = z.b[1],
              h = this.an[1],
              h > o && (h = z.b[1],
              this.an[1] = o,
              o = z.b[1]),
              l = z.b[2],
              u = this.an[2],
              u > l && (u = z.b[2],
              this.an[2] = l,
              l = z.b[2]),
              n > this.al[0] && (this.al[0] = n),
              o > this.al[1] && (this.al[1] = o),
              l > this.al[2] && (this.al[2] = l),
              c = s.b[0],
              a > s.b[0] && (this.an[0] = c,
              c = s.b[0]),
              d = s.b[1],
              h > d && (this.an[1] = d,
              d = s.b[1]),
              f = s.b[2],
              u > f && (this.an[2] = f,
              f = s.b[2]),
              c > this.al[0] && (this.al[0] = c),
              d > this.al[1] && (this.al[1] = d),
              f > this.al[2] && (this.al[2] = f),
              q = this.M.length,
              this.M[k] = t + this.M[k],
              g = this.E,
              X = this.M.length,
              b = g * this.M[k] * this.X + this.t.b,
              z.a[1] = this.t.a,
              z.a[0] = b,
              s.a[1] = this.t.d,
              s.a[0] = b,
              _ = this.M.length,
              B = P + 1,
              e = B - _,
              _ > B && (e = B);
          this.ak = !0
      }
      aj(t, e) {
          let i = e + t;
          t = i;
          let s = this.M.length;
          return i >= s && (t = i - s),
          t
      }
      J(t, e, i, s, r, n) {
          let a, o, h, l, u, c, d, f;
          d = Math.ceil(t),
          f = Math.max(.25, e),
          a = Math.ceil(f * d),
          o = Math.ceil(Math.max(a + 1 + 1, 0)),
          this.M = new Array(o),
          this.f = 0,
          this.g = 0,
          this.U = 0,
          this.w = !1,
          this.af = new Array(2 * o);
          for (let t = 0; t < this.af.length; t++) {
              this.af[t] = new Tn;
              let e = this.af[t];
              e.b[0] = 0,
              e.b[1] = 0,
              e.b[2] = 0,
              e.c = Es(0, 0, 0, 0),
              e.a[0] = 0,
              e.a[1] = 0
          }
          this.O = new Array(4 * o);
          for (let t = 0; t < this.O.length; t++)
              this.O[t] = t % (2 * o);
          this.X = 1 / f,
          h = n,
          2147483648 & n && (h = (1 & n | n >> 1) + (1 & n | n >> 1)),
          this.E = (s.c - s.b) / h,
          l = r,
          2147483648 & r && (l = (1 & r | r >> 1) + (1 & r | r >> 1)),
          this.h = (s.d - s.a) / l,
          this.d = 1 / this.E,
          this.q = 1 / this.h,
          this.F = d,
          this.R = f,
          Ss(i, i, 1 / 255),
          this.ap = i,
          this.ab = s,
          this.as = r,
          this.p = n,
          this.L = 0,
          u = 0 * this.E + this.ab.b,
          this.t.b = u,
          c = 0 * this.h + this.ab.a,
          this.t.a = c,
          this.t.c = u + this.E,
          this.t.d = c + this.h,
          this.a = 10,
          this.K = 10,
          this.I = 0,
          this.A = !0,
          this.u = !0,
          this.G = !0,
          this.e = this.am.q.h(0),
          this.Z = this.am.q.e(0),
          this.ai = this.am.q.m(this.e, this.Z)
      }
      j() {
          let t = new Array(this.af.length);
          for (let e = 0, i = 0; e < this.af.length; ++e)
              t[i++] = this.af[e].b[0],
              t[i++] = this.af[e].b[1],
              t[i++] = this.af[e].b[2],
              t[i++] = this.af[e].c[0],
              t[i++] = this.af[e].c[1],
              t[i++] = this.af[e].c[2],
              t[i++] = this.af[e].c[3],
              t[i++] = this.af[e].a[0],
              t[i++] = this.af[e].a[1];
          this.ar() || (this.e.b(new Float32Array(t)),
          this.Z.b(new Uint16Array(this.O)))
      }
      aa(t) {
          const e = this.am.q;
          var i = this.T.i[t];
          if (i <= -1 || i > this.am.u.length)
              return null;
          let s = this.am.u[i];
          if (!s.e || !s.e.l)
              return null;
          let r = t;
          r >= this.T.a.length && (r = 0);
          let n = this.am.P.h[this.T.a[r]]
            , a = Object.assign({}, this.am.au);
          const o = e.n(this.am.C, new cn(!1,!this.am.m,yn[n.c],!0,!1,15), new ds([s.e],a));
          return e.d(new dn(this.ai,0,0), o, 0, 0)
      }
      V(t) {
          if (this.ar())
              return;
          const e = this.am.q.i();
          for (let i = 0; i < this.T.i.length; i++) {
              if (this.ah[i] || (this.ah[i] = this.aa(i)),
              !this.ah[i])
                  continue;
              if (!t && this.ah[i].g.b() > $s.GxBlend_AlphaKey)
                  continue;
              let s = this.g > this.f ? 2 * (this.g - this.f) + 2 : 2 * (this.M.length + this.g - this.f) + 2;
              this.ah[i].e = s,
              this.ah[i].a = 2 * this.f * 2,
              e.e(this.ah[i])
          }
      }
  }
  ;
  const Cn = class {
      constructor(t) {
          var e = this;
          e.e = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          e.c = Es(t.getFloat(), t.getFloat(), t.getFloat(), 0),
          e.i = t.getFloat(),
          e.b = t.getFloat(),
          e.a = t.getFloat(),
          e.h = t.getFloat(),
          e.d = [t.getUint8(), t.getUint8(), t.getUint8(), t.getUint8()],
          e.f = [t.getUint8(), t.getUint8(), t.getUint8(), t.getUint8()]
      }
      g() {
          var t = this;
          t.e = null,
          t.c = null,
          t.d = null,
          t.f = null
      }
  }
  ;
  const Mn = class {
      constructor(t) {
          var e = this;
          e.g = t.getUint16(),
          e.j = t.getUint16(),
          e.k = t.getUint16(),
          e.e = t.getUint16(),
          e.b = t.getUint16() + 65536 * e.j,
          e.d = t.getUint16(),
          e.h = t.getUint16(),
          e.a = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          e.c = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          e.i = t.getFloat()
      }
      f() {
          this.a = null,
          this.c = null
      }
  }
  ;
  const kn = class {
      constructor(t) {
          this.a = t.getUint16(),
          this.c = t.getUint16()
      }
      static b(t) {
          const e = t.s.P
            , i = t.d;
          e.h && i.g < e.h.length ? t.y = e.h[i.g] : t.y = {
              a: 0,
              c: 0
          },
          t.l = !!(1 & t.y.a),
          t.u = !(4 & t.y.a),
          t.p = !!(16 & t.y.a)
      }
  }
  ;
  const Fn = class {
      constructor(t) {
          this.c = new tn(t,qr),
          this.d = new tn(t,Xr),
          this.a = new tn(t,qr)
      }
      b() {
          var t = this;
          t.c && (t.c.a(),
          t.c = null),
          t.d && (t.d.a(),
          t.d = null),
          t.a && (t.a.a(),
          t.a = null)
      }
  }
  ;
  const Sn = class {
      constructor(t) {
          var e = this;
          e.b = t.getInt32(),
          e.d = t.getInt32(),
          e.a = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          e.e = -1
      }
      c() {
          this.a = null
      }
  }
  ;
  const Dn = class {
      constructor(t) {
          this.g = new tn(t,qr),
          this.d = new tn(t,Wr)
      }
      f() {
          var t = this;
          t.g && t.g.a(),
          t.d && t.d.a()
      }
      a(t) {
          return !!this.g && this.g.d(t)
      }
      b(t) {
          return !!this.d && this.d.d(t)
      }
      c(t) {
          return this.a(t) || this.b(t)
      }
      e(t, e, i) {
          var s = this;
          i ? i[0] = i[1] = i[2] = i[3] = 1 : i = Es(1, 1, 1, 1);
          let r = _i(1, 1, 1);
          return s.a(t.e.e) && s.g.b(t, e, r, r),
          s.b(t.e.e) && (i[3] = s.d.b(t, e, 32767) / 32767),
          i[0] = r[0],
          i[1] = r[1],
          i[2] = r[2],
          i
      }
  }
  ;
  const In = class {
      constructor(t) {
          this.c = new tn(t,Wr)
      }
      a() {
          this.c.a(),
          this.c = null
      }
      b(t) {
          return this.c.d(t)
      }
      d(t, e) {
          var i = 1;
          this.b(t.e.e) && (i = this.c.b(t, e, i) / 32767);
          return i > 1 ? i = 1 : i < 0 && (i = 0),
          i
      }
  }
  ;
  const Rn = class {
      constructor(t) {
          var e = this;
          e.a = t.getFloat(),
          e.d = t.getFloat(),
          e.c = t.getFloat(),
          e.b = new $r(t)
      }
  }
  ;
  const Un = class {
      constructor(t) {
          this.S = t.getInt32(),
          this.v = t.getUint32(),
          this.T = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          this.G = t.getInt16(),
          this.P = t.getInt16(),
          268435456 & this.v && (this.J = [0, 0, 0],
          this.J[0] = 31 & this.P,
          this.J[1] = this.P >> 5 & 31,
          this.J[2] = this.P >> 10 & 31),
          this.a = t.getUint8(),
          this.A = t.getUint8(),
          this.z = t.getUint16(),
          this.q = t.getUint16(),
          this.Q = t.getUint16(),
          this.k = t.getUint16(),
          this.y = new tn(t,Zr),
          this.D = new tn(t,Zr),
          this.g = new tn(t,Zr),
          this.L = new tn(t,Zr),
          this.m = new tn(t,qr),
          this.d = new tn(t,Zr),
          this.w = t.getFloat(),
          this.t = new tn(t,Zr),
          this.aa = t.getFloat(),
          this.Y = new tn(t,Zr),
          this.n = new tn(t,Zr),
          this.e = new tn(t,Zr),
          this.l = new Qr(t),
          this.r = new $r(t),
          this.V = new Jr(t),
          this.b = [t.getFloat(), t.getFloat()],
          this.B = new $r(t),
          this.C = new $r(t),
          this.x = t.getFloat(),
          this.X = t.getFloat(),
          this.W = t.getFloat(),
          this.H = [t.getFloat(), t.getFloat()],
          this.E = t.getFloat(),
          this.R = t.getFloat(),
          this.O = t.getFloat(),
          this.K = t.getFloat(),
          this.p = t.getFloat(),
          this.U = t.getFloat(),
          this.M = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          this.I = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          this.h = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          this.o = t.getFloat(),
          this.c = t.getFloat(),
          this.N = t.getFloat(),
          this.F = t.getFloat(),
          this.Z = t.getFloat();
          var e = t.getInt32();
          this.s = new Array(e);
          for (var i = 0; i < e; i++)
              this.s[i] = _i(t.getFloat(), t.getFloat(), t.getFloat());
          this.j = new tn(t,Kr),
          this.i = yr(t.getFloat(), t.getFloat()),
          this.f = [yr(t.getFloat(), t.getFloat()), yr(t.getFloat(), t.getFloat())],
          this.u = [yr(t.getFloat(), t.getFloat()), yr(t.getFloat(), t.getFloat())]
      }
  }
  ;
  class On {
      constructor(t) {
          this.a = t.getInt32(),
          this.g = t.getUint32(),
          this.f = t.getInt16(),
          this.c = t.getUint16(),
          this.b = t.getUint32(),
          this.h = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          this.e = new tn(t,qr),
          this.d = new tn(t,Xr),
          this.i = new tn(t,qr)
      }
  }
  const Pn = class {
      constructor(t) {
          this.buffer = new DataView(t),
          this.position = 0
      }
      getBool() {
          var t = 0 != this.buffer.getUint8(this.position);
          return this.position += 1,
          t
      }
      getUint8() {
          var t = this.buffer.getUint8(this.position);
          return this.position += 1,
          t
      }
      getInt8() {
          var t = this.buffer.getInt8(this.position);
          return this.position += 1,
          t
      }
      getUint16() {
          var t = this.buffer.getUint16(this.position, !0);
          return this.position += 2,
          t
      }
      getInt16() {
          var t = this.buffer.getInt16(this.position, !0);
          return this.position += 2,
          t
      }
      getUint32() {
          var t = this.buffer.getUint32(this.position, !0);
          return this.position += 4,
          t
      }
      getInt32() {
          var t = this.buffer.getInt32(this.position, !0);
          return this.position += 4,
          t
      }
      getFloat() {
          var t = this.buffer.getFloat32(this.position, !0);
          return this.position += 4,
          t
      }
      getString(t) {
          void 0 === t && (t = this.getUint16());
          for (var e = "", i = 0; i < t; ++i)
              e += String.fromCharCode(this.getUint8());
          return e
      }
      setBool(t) {
          this.buffer.setUint8(this.position, t ? 1 : 0),
          this.position += 1
      }
      setUint8(t) {
          this.buffer.setUint8(this.position, t),
          this.position += 1
      }
      setInt8(t) {
          this.buffer.setInt8(this.position, t),
          this.position += 1
      }
      setUint16(t) {
          this.buffer.setUint16(this.position, t, !0),
          this.position += 2
      }
      setInt16(t) {
          this.buffer.setInt16(this.position, t, !0),
          this.position += 2
      }
      setUint32(t) {
          this.buffer.setUint32(this.position, t, !0),
          this.position += 4
      }
      setInt32(t) {
          this.buffer.setInt32(this.position, t, !0),
          this.position += 4
      }
      setFloat(t) {
          this.buffer.setFloat32(this.position, t, !0),
          this.position += 4
      }
  }
  ;
  function Bn(t) {
      let e = t.length;
      for (; --e >= 0; )
          t[e] = 0
  }
  const zn = 256
    , Nn = 286
    , Gn = 30
    , jn = 15
    , Ln = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    , Hn = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    , Vn = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    , qn = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
    , Xn = new Array(576);
  Bn(Xn);
  const Wn = new Array(60);
  Bn(Wn);
  const Zn = new Array(512);
  Bn(Zn);
  const Kn = new Array(256);
  Bn(Kn);
  const Yn = new Array(29);
  Bn(Yn);
  const Jn = new Array(Gn);
  function Qn(t, e, i, s, r) {
      this.static_tree = t,
      this.extra_bits = e,
      this.extra_base = i,
      this.elems = s,
      this.max_length = r,
      this.has_stree = t && t.length
  }
  let $n, ta, ea;
  function ia(t, e) {
      this.dyn_tree = t,
      this.max_code = 0,
      this.stat_desc = e
  }
  Bn(Jn);
  const sa = t => t < 256 ? Zn[t] : Zn[256 + (t >>> 7)]
    , ra = (t, e) => {
      t.pending_buf[t.pending++] = 255 & e,
      t.pending_buf[t.pending++] = e >>> 8 & 255
  }
    , na = (t, e, i) => {
      t.bi_valid > 16 - i ? (t.bi_buf |= e << t.bi_valid & 65535,
      ra(t, t.bi_buf),
      t.bi_buf = e >> 16 - t.bi_valid,
      t.bi_valid += i - 16) : (t.bi_buf |= e << t.bi_valid & 65535,
      t.bi_valid += i)
  }
    , aa = (t, e, i) => {
      na(t, i[2 * e], i[2 * e + 1])
  }
    , oa = (t, e) => {
      let i = 0;
      do {
          i |= 1 & t,
          t >>>= 1,
          i <<= 1
      } while (--e > 0);
      return i >>> 1
  }
    , ha = (t, e, i) => {
      const s = new Array(16);
      let r, n, a = 0;
      for (r = 1; r <= jn; r++)
          a = a + i[r - 1] << 1,
          s[r] = a;
      for (n = 0; n <= e; n++) {
          let e = t[2 * n + 1];
          0 !== e && (t[2 * n] = oa(s[e]++, e))
      }
  }
    , la = t => {
      let e;
      for (e = 0; e < Nn; e++)
          t.dyn_ltree[2 * e] = 0;
      for (e = 0; e < Gn; e++)
          t.dyn_dtree[2 * e] = 0;
      for (e = 0; e < 19; e++)
          t.bl_tree[2 * e] = 0;
      t.dyn_ltree[512] = 1,
      t.opt_len = t.static_len = 0,
      t.sym_next = t.matches = 0
  }
    , ua = t => {
      t.bi_valid > 8 ? ra(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf),
      t.bi_buf = 0,
      t.bi_valid = 0
  }
    , ca = (t, e, i, s) => {
      const r = 2 * e
        , n = 2 * i;
      return t[r] < t[n] || t[r] === t[n] && s[e] <= s[i]
  }
    , da = (t, e, i) => {
      const s = t.heap[i];
      let r = i << 1;
      for (; r <= t.heap_len && (r < t.heap_len && ca(e, t.heap[r + 1], t.heap[r], t.depth) && r++,
      !ca(e, s, t.heap[r], t.depth)); )
          t.heap[i] = t.heap[r],
          i = r,
          r <<= 1;
      t.heap[i] = s
  }
    , fa = (t, e, i) => {
      let s, r, n, a, o = 0;
      if (0 !== t.sym_next)
          do {
              s = 255 & t.pending_buf[t.sym_buf + o++],
              s += (255 & t.pending_buf[t.sym_buf + o++]) << 8,
              r = t.pending_buf[t.sym_buf + o++],
              0 === s ? aa(t, r, e) : (n = Kn[r],
              aa(t, n + zn + 1, e),
              a = Ln[n],
              0 !== a && (r -= Yn[n],
              na(t, r, a)),
              s--,
              n = sa(s),
              aa(t, n, i),
              a = Hn[n],
              0 !== a && (s -= Jn[n],
              na(t, s, a)))
          } while (o < t.sym_next);
      aa(t, 256, e)
  }
    , ga = (t, e) => {
      const i = e.dyn_tree
        , s = e.stat_desc.static_tree
        , r = e.stat_desc.has_stree
        , n = e.stat_desc.elems;
      let a, o, h, l = -1;
      for (t.heap_len = 0,
      t.heap_max = 573,
      a = 0; a < n; a++)
          0 !== i[2 * a] ? (t.heap[++t.heap_len] = l = a,
          t.depth[a] = 0) : i[2 * a + 1] = 0;
      for (; t.heap_len < 2; )
          h = t.heap[++t.heap_len] = l < 2 ? ++l : 0,
          i[2 * h] = 1,
          t.depth[h] = 0,
          t.opt_len--,
          r && (t.static_len -= s[2 * h + 1]);
      for (e.max_code = l,
      a = t.heap_len >> 1; a >= 1; a--)
          da(t, i, a);
      h = n;
      do {
          a = t.heap[1],
          t.heap[1] = t.heap[t.heap_len--],
          da(t, i, 1),
          o = t.heap[1],
          t.heap[--t.heap_max] = a,
          t.heap[--t.heap_max] = o,
          i[2 * h] = i[2 * a] + i[2 * o],
          t.depth[h] = (t.depth[a] >= t.depth[o] ? t.depth[a] : t.depth[o]) + 1,
          i[2 * a + 1] = i[2 * o + 1] = h,
          t.heap[1] = h++,
          da(t, i, 1)
      } while (t.heap_len >= 2);
      t.heap[--t.heap_max] = t.heap[1],
      ( (t, e) => {
          const i = e.dyn_tree
            , s = e.max_code
            , r = e.stat_desc.static_tree
            , n = e.stat_desc.has_stree
            , a = e.stat_desc.extra_bits
            , o = e.stat_desc.extra_base
            , h = e.stat_desc.max_length;
          let l, u, c, d, f, g, b = 0;
          for (d = 0; d <= jn; d++)
              t.bl_count[d] = 0;
          for (i[2 * t.heap[t.heap_max] + 1] = 0,
          l = t.heap_max + 1; l < 573; l++)
              u = t.heap[l],
              d = i[2 * i[2 * u + 1] + 1] + 1,
              d > h && (d = h,
              b++),
              i[2 * u + 1] = d,
              u > s || (t.bl_count[d]++,
              f = 0,
              u >= o && (f = a[u - o]),
              g = i[2 * u],
              t.opt_len += g * (d + f),
              n && (t.static_len += g * (r[2 * u + 1] + f)));
          if (0 !== b) {
              do {
                  for (d = h - 1; 0 === t.bl_count[d]; )
                      d--;
                  t.bl_count[d]--,
                  t.bl_count[d + 1] += 2,
                  t.bl_count[h]--,
                  b -= 2
              } while (b > 0);
              for (d = h; 0 !== d; d--)
                  for (u = t.bl_count[d]; 0 !== u; )
                      c = t.heap[--l],
                      c > s || (i[2 * c + 1] !== d && (t.opt_len += (d - i[2 * c + 1]) * i[2 * c],
                      i[2 * c + 1] = d),
                      u--)
          }
      }
      )(t, e),
      ha(i, l, t.bl_count)
  }
    , ba = (t, e, i) => {
      let s, r, n = -1, a = e[1], o = 0, h = 7, l = 4;
      for (0 === a && (h = 138,
      l = 3),
      e[2 * (i + 1) + 1] = 65535,
      s = 0; s <= i; s++)
          r = a,
          a = e[2 * (s + 1) + 1],
          ++o < h && r === a || (o < l ? t.bl_tree[2 * r] += o : 0 !== r ? (r !== n && t.bl_tree[2 * r]++,
          t.bl_tree[32]++) : o <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++,
          o = 0,
          n = r,
          0 === a ? (h = 138,
          l = 3) : r === a ? (h = 6,
          l = 3) : (h = 7,
          l = 4))
  }
    , _a = (t, e, i) => {
      let s, r, n = -1, a = e[1], o = 0, h = 7, l = 4;
      for (0 === a && (h = 138,
      l = 3),
      s = 0; s <= i; s++)
          if (r = a,
          a = e[2 * (s + 1) + 1],
          !(++o < h && r === a)) {
              if (o < l)
                  do {
                      aa(t, r, t.bl_tree)
                  } while (0 != --o);
              else
                  0 !== r ? (r !== n && (aa(t, r, t.bl_tree),
                  o--),
                  aa(t, 16, t.bl_tree),
                  na(t, o - 3, 2)) : o <= 10 ? (aa(t, 17, t.bl_tree),
                  na(t, o - 3, 3)) : (aa(t, 18, t.bl_tree),
                  na(t, o - 11, 7));
              o = 0,
              n = r,
              0 === a ? (h = 138,
              l = 3) : r === a ? (h = 6,
              l = 3) : (h = 7,
              l = 4)
          }
  }
  ;
  let pa = !1;
  const ma = (t, e, i, s) => {
      na(t, 0 + (s ? 1 : 0), 3),
      ua(t),
      ra(t, i),
      ra(t, ~i),
      i && t.pending_buf.set(t.window.subarray(e, e + i), t.pending),
      t.pending += i
  }
  ;
  var va = t => {
      pa || (( () => {
          let t, e, i, s, r;
          const n = new Array(16);
          for (i = 0,
          s = 0; s < 28; s++)
              for (Yn[s] = i,
              t = 0; t < 1 << Ln[s]; t++)
                  Kn[i++] = s;
          for (Kn[i - 1] = s,
          r = 0,
          s = 0; s < 16; s++)
              for (Jn[s] = r,
              t = 0; t < 1 << Hn[s]; t++)
                  Zn[r++] = s;
          for (r >>= 7; s < Gn; s++)
              for (Jn[s] = r << 7,
              t = 0; t < 1 << Hn[s] - 7; t++)
                  Zn[256 + r++] = s;
          for (e = 0; e <= jn; e++)
              n[e] = 0;
          for (t = 0; t <= 143; )
              Xn[2 * t + 1] = 8,
              t++,
              n[8]++;
          for (; t <= 255; )
              Xn[2 * t + 1] = 9,
              t++,
              n[9]++;
          for (; t <= 279; )
              Xn[2 * t + 1] = 7,
              t++,
              n[7]++;
          for (; t <= 287; )
              Xn[2 * t + 1] = 8,
              t++,
              n[8]++;
          for (ha(Xn, 287, n),
          t = 0; t < Gn; t++)
              Wn[2 * t + 1] = 5,
              Wn[2 * t] = oa(t, 5);
          $n = new Qn(Xn,Ln,257,Nn,jn),
          ta = new Qn(Wn,Hn,0,Gn,jn),
          ea = new Qn(new Array(0),Vn,0,19,7)
      }
      )(),
      pa = !0),
      t.l_desc = new ia(t.dyn_ltree,$n),
      t.d_desc = new ia(t.dyn_dtree,ta),
      t.bl_desc = new ia(t.bl_tree,ea),
      t.bi_buf = 0,
      t.bi_valid = 0,
      la(t)
  }
    , xa = (t, e, i, s) => {
      let r, n, a = 0;
      t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = (t => {
          let e, i = 4093624447;
          for (e = 0; e <= 31; e++,
          i >>>= 1)
              if (1 & i && 0 !== t.dyn_ltree[2 * e])
                  return 0;
          if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26])
              return 1;
          for (e = 32; e < zn; e++)
              if (0 !== t.dyn_ltree[2 * e])
                  return 1;
          return 0
      }
      )(t)),
      ga(t, t.l_desc),
      ga(t, t.d_desc),
      a = (t => {
          let e;
          for (ba(t, t.dyn_ltree, t.l_desc.max_code),
          ba(t, t.dyn_dtree, t.d_desc.max_code),
          ga(t, t.bl_desc),
          e = 18; e >= 3 && 0 === t.bl_tree[2 * qn[e] + 1]; e--)
              ;
          return t.opt_len += 3 * (e + 1) + 5 + 5 + 4,
          e
      }
      )(t),
      r = t.opt_len + 3 + 7 >>> 3,
      n = t.static_len + 3 + 7 >>> 3,
      n <= r && (r = n)) : r = n = i + 5,
      i + 4 <= r && -1 !== e ? ma(t, e, i, s) : 4 === t.strategy || n === r ? (na(t, 2 + (s ? 1 : 0), 3),
      fa(t, Xn, Wn)) : (na(t, 4 + (s ? 1 : 0), 3),
      ( (t, e, i, s) => {
          let r;
          for (na(t, e - 257, 5),
          na(t, i - 1, 5),
          na(t, s - 4, 4),
          r = 0; r < s; r++)
              na(t, t.bl_tree[2 * qn[r] + 1], 3);
          _a(t, t.dyn_ltree, e - 1),
          _a(t, t.dyn_dtree, i - 1)
      }
      )(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, a + 1),
      fa(t, t.dyn_ltree, t.dyn_dtree)),
      la(t),
      s && ua(t)
  }
    , Ta = (t, e, i) => (t.pending_buf[t.sym_buf + t.sym_next++] = e,
  t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8,
  t.pending_buf[t.sym_buf + t.sym_next++] = i,
  0 === e ? t.dyn_ltree[2 * i]++ : (t.matches++,
  e--,
  t.dyn_ltree[2 * (Kn[i] + zn + 1)]++,
  t.dyn_dtree[2 * sa(e)]++),
  t.sym_next === t.sym_end)
    , wa = {
      _tr_init: va,
      _tr_stored_block: ma,
      _tr_flush_block: xa,
      _tr_tally: Ta,
      _tr_align: t => {
          na(t, 2, 3),
          aa(t, 256, Xn),
          (t => {
              16 === t.bi_valid ? (ra(t, t.bi_buf),
              t.bi_buf = 0,
              t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf,
              t.bi_buf >>= 8,
              t.bi_valid -= 8)
          }
          )(t)
      }
  };
  var ya = (t, e, i, s) => {
      let r = 65535 & t
        , n = t >>> 16 & 65535
        , a = 0;
      for (; 0 !== i; ) {
          a = i > 2e3 ? 2e3 : i,
          i -= a;
          do {
              r = r + e[s++] | 0,
              n = n + r | 0
          } while (--a);
          r %= 65521,
          n %= 65521
      }
      return r | n << 16
  }
  ;
  const Aa = new Uint32Array(( () => {
      let t, e = [];
      for (var i = 0; i < 256; i++) {
          t = i;
          for (var s = 0; s < 8; s++)
              t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
          e[i] = t
      }
      return e
  }
  )());
  var Ea = (t, e, i, s) => {
      const r = Aa
        , n = s + i;
      t ^= -1;
      for (let i = s; i < n; i++)
          t = t >>> 8 ^ r[255 & (t ^ e[i])];
      return ~t
  }
    , Ca = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
  }
    , Ma = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
  };
  const {_tr_init: ka, _tr_stored_block: Fa, _tr_flush_block: Sa, _tr_tally: Da, _tr_align: Ia} = wa
    , {Z_NO_FLUSH: Ra, Z_PARTIAL_FLUSH: Ua, Z_FULL_FLUSH: Oa, Z_FINISH: Pa, Z_BLOCK: Ba, Z_OK: za, Z_STREAM_END: Na, Z_STREAM_ERROR: Ga, Z_DATA_ERROR: ja, Z_BUF_ERROR: La, Z_DEFAULT_COMPRESSION: Ha, Z_FILTERED: Va, Z_HUFFMAN_ONLY: qa, Z_RLE: Xa, Z_FIXED: Wa, Z_DEFAULT_STRATEGY: Za, Z_UNKNOWN: Ka, Z_DEFLATED: Ya} = Ma
    , Ja = 258
    , Qa = 262
    , $a = 42
    , to = 113
    , eo = 666
    , io = (t, e) => (t.msg = Ca[e],
  e)
    , so = t => 2 * t - (t > 4 ? 9 : 0)
    , ro = t => {
      let e = t.length;
      for (; --e >= 0; )
          t[e] = 0
  }
    , no = t => {
      let e, i, s, r = t.w_size;
      e = t.hash_size,
      s = e;
      do {
          i = t.head[--s],
          t.head[s] = i >= r ? i - r : 0
      } while (--e);
      e = r,
      s = e;
      do {
          i = t.prev[--s],
          t.prev[s] = i >= r ? i - r : 0
      } while (--e)
  }
  ;
  let ao = (t, e, i) => (e << t.hash_shift ^ i) & t.hash_mask;
  const oo = t => {
      const e = t.state;
      let i = e.pending;
      i > t.avail_out && (i = t.avail_out),
      0 !== i && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + i), t.next_out),
      t.next_out += i,
      e.pending_out += i,
      t.total_out += i,
      t.avail_out -= i,
      e.pending -= i,
      0 === e.pending && (e.pending_out = 0))
  }
    , ho = (t, e) => {
      Sa(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e),
      t.block_start = t.strstart,
      oo(t.strm)
  }
    , lo = (t, e) => {
      t.pending_buf[t.pending++] = e
  }
    , uo = (t, e) => {
      t.pending_buf[t.pending++] = e >>> 8 & 255,
      t.pending_buf[t.pending++] = 255 & e
  }
    , co = (t, e, i, s) => {
      let r = t.avail_in;
      return r > s && (r = s),
      0 === r ? 0 : (t.avail_in -= r,
      e.set(t.input.subarray(t.next_in, t.next_in + r), i),
      1 === t.state.wrap ? t.adler = ya(t.adler, e, r, i) : 2 === t.state.wrap && (t.adler = Ea(t.adler, e, r, i)),
      t.next_in += r,
      t.total_in += r,
      r)
  }
    , fo = (t, e) => {
      let i, s, r = t.max_chain_length, n = t.strstart, a = t.prev_length, o = t.nice_match;
      const h = t.strstart > t.w_size - Qa ? t.strstart - (t.w_size - Qa) : 0
        , l = t.window
        , u = t.w_mask
        , c = t.prev
        , d = t.strstart + Ja;
      let f = l[n + a - 1]
        , g = l[n + a];
      t.prev_length >= t.good_match && (r >>= 2),
      o > t.lookahead && (o = t.lookahead);
      do {
          if (i = e,
          l[i + a] === g && l[i + a - 1] === f && l[i] === l[n] && l[++i] === l[n + 1]) {
              n += 2,
              i++;
              do {} while (l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && n < d);
              if (s = Ja - (d - n),
              n = d - Ja,
              s > a) {
                  if (t.match_start = e,
                  a = s,
                  s >= o)
                      break;
                  f = l[n + a - 1],
                  g = l[n + a]
              }
          }
      } while ((e = c[e & u]) > h && 0 != --r);
      return a <= t.lookahead ? a : t.lookahead
  }
    , go = t => {
      const e = t.w_size;
      let i, s, r;
      do {
          if (s = t.window_size - t.lookahead - t.strstart,
          t.strstart >= e + (e - Qa) && (t.window.set(t.window.subarray(e, e + e - s), 0),
          t.match_start -= e,
          t.strstart -= e,
          t.block_start -= e,
          t.insert > t.strstart && (t.insert = t.strstart),
          no(t),
          s += e),
          0 === t.strm.avail_in)
              break;
          if (i = co(t.strm, t.window, t.strstart + t.lookahead, s),
          t.lookahead += i,
          t.lookahead + t.insert >= 3)
              for (r = t.strstart - t.insert,
              t.ins_h = t.window[r],
              t.ins_h = ao(t, t.ins_h, t.window[r + 1]); t.insert && (t.ins_h = ao(t, t.ins_h, t.window[r + 3 - 1]),
              t.prev[r & t.w_mask] = t.head[t.ins_h],
              t.head[t.ins_h] = r,
              r++,
              t.insert--,
              !(t.lookahead + t.insert < 3)); )
                  ;
      } while (t.lookahead < Qa && 0 !== t.strm.avail_in)
  }
    , bo = (t, e) => {
      let i, s, r, n = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5, a = 0, o = t.strm.avail_in;
      do {
          if (i = 65535,
          r = t.bi_valid + 42 >> 3,
          t.strm.avail_out < r)
              break;
          if (r = t.strm.avail_out - r,
          s = t.strstart - t.block_start,
          i > s + t.strm.avail_in && (i = s + t.strm.avail_in),
          i > r && (i = r),
          i < n && (0 === i && e !== Pa || e === Ra || i !== s + t.strm.avail_in))
              break;
          a = e === Pa && i === s + t.strm.avail_in ? 1 : 0,
          Fa(t, 0, 0, a),
          t.pending_buf[t.pending - 4] = i,
          t.pending_buf[t.pending - 3] = i >> 8,
          t.pending_buf[t.pending - 2] = ~i,
          t.pending_buf[t.pending - 1] = ~i >> 8,
          oo(t.strm),
          s && (s > i && (s = i),
          t.strm.output.set(t.window.subarray(t.block_start, t.block_start + s), t.strm.next_out),
          t.strm.next_out += s,
          t.strm.avail_out -= s,
          t.strm.total_out += s,
          t.block_start += s,
          i -= s),
          i && (co(t.strm, t.strm.output, t.strm.next_out, i),
          t.strm.next_out += i,
          t.strm.avail_out -= i,
          t.strm.total_out += i)
      } while (0 === a);
      return o -= t.strm.avail_in,
      o && (o >= t.w_size ? (t.matches = 2,
      t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0),
      t.strstart = t.w_size,
      t.insert = t.strstart) : (t.window_size - t.strstart <= o && (t.strstart -= t.w_size,
      t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0),
      t.matches < 2 && t.matches++,
      t.insert > t.strstart && (t.insert = t.strstart)),
      t.window.set(t.strm.input.subarray(t.strm.next_in - o, t.strm.next_in), t.strstart),
      t.strstart += o,
      t.insert += o > t.w_size - t.insert ? t.w_size - t.insert : o),
      t.block_start = t.strstart),
      t.high_water < t.strstart && (t.high_water = t.strstart),
      a ? 4 : e !== Ra && e !== Pa && 0 === t.strm.avail_in && t.strstart === t.block_start ? 2 : (r = t.window_size - t.strstart,
      t.strm.avail_in > r && t.block_start >= t.w_size && (t.block_start -= t.w_size,
      t.strstart -= t.w_size,
      t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0),
      t.matches < 2 && t.matches++,
      r += t.w_size,
      t.insert > t.strstart && (t.insert = t.strstart)),
      r > t.strm.avail_in && (r = t.strm.avail_in),
      r && (co(t.strm, t.window, t.strstart, r),
      t.strstart += r,
      t.insert += r > t.w_size - t.insert ? t.w_size - t.insert : r),
      t.high_water < t.strstart && (t.high_water = t.strstart),
      r = t.bi_valid + 42 >> 3,
      r = t.pending_buf_size - r > 65535 ? 65535 : t.pending_buf_size - r,
      n = r > t.w_size ? t.w_size : r,
      s = t.strstart - t.block_start,
      (s >= n || (s || e === Pa) && e !== Ra && 0 === t.strm.avail_in && s <= r) && (i = s > r ? r : s,
      a = e === Pa && 0 === t.strm.avail_in && i === s ? 1 : 0,
      Fa(t, t.block_start, i, a),
      t.block_start += i,
      oo(t.strm)),
      a ? 3 : 1)
  }
    , _o = (t, e) => {
      let i, s;
      for (; ; ) {
          if (t.lookahead < Qa) {
              if (go(t),
              t.lookahead < Qa && e === Ra)
                  return 1;
              if (0 === t.lookahead)
                  break
          }
          if (i = 0,
          t.lookahead >= 3 && (t.ins_h = ao(t, t.ins_h, t.window[t.strstart + 3 - 1]),
          i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
          t.head[t.ins_h] = t.strstart),
          0 !== i && t.strstart - i <= t.w_size - Qa && (t.match_length = fo(t, i)),
          t.match_length >= 3)
              if (s = Da(t, t.strstart - t.match_start, t.match_length - 3),
              t.lookahead -= t.match_length,
              t.match_length <= t.max_lazy_match && t.lookahead >= 3) {
                  t.match_length--;
                  do {
                      t.strstart++,
                      t.ins_h = ao(t, t.ins_h, t.window[t.strstart + 3 - 1]),
                      i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                      t.head[t.ins_h] = t.strstart
                  } while (0 != --t.match_length);
                  t.strstart++
              } else
                  t.strstart += t.match_length,
                  t.match_length = 0,
                  t.ins_h = t.window[t.strstart],
                  t.ins_h = ao(t, t.ins_h, t.window[t.strstart + 1]);
          else
              s = Da(t, 0, t.window[t.strstart]),
              t.lookahead--,
              t.strstart++;
          if (s && (ho(t, !1),
          0 === t.strm.avail_out))
              return 1
      }
      return t.insert = t.strstart < 2 ? t.strstart : 2,
      e === Pa ? (ho(t, !0),
      0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (ho(t, !1),
      0 === t.strm.avail_out) ? 1 : 2
  }
    , po = (t, e) => {
      let i, s, r;
      for (; ; ) {
          if (t.lookahead < Qa) {
              if (go(t),
              t.lookahead < Qa && e === Ra)
                  return 1;
              if (0 === t.lookahead)
                  break
          }
          if (i = 0,
          t.lookahead >= 3 && (t.ins_h = ao(t, t.ins_h, t.window[t.strstart + 3 - 1]),
          i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
          t.head[t.ins_h] = t.strstart),
          t.prev_length = t.match_length,
          t.prev_match = t.match_start,
          t.match_length = 2,
          0 !== i && t.prev_length < t.max_lazy_match && t.strstart - i <= t.w_size - Qa && (t.match_length = fo(t, i),
          t.match_length <= 5 && (t.strategy === Va || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)),
          t.prev_length >= 3 && t.match_length <= t.prev_length) {
              r = t.strstart + t.lookahead - 3,
              s = Da(t, t.strstart - 1 - t.prev_match, t.prev_length - 3),
              t.lookahead -= t.prev_length - 1,
              t.prev_length -= 2;
              do {
                  ++t.strstart <= r && (t.ins_h = ao(t, t.ins_h, t.window[t.strstart + 3 - 1]),
                  i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                  t.head[t.ins_h] = t.strstart)
              } while (0 != --t.prev_length);
              if (t.match_available = 0,
              t.match_length = 2,
              t.strstart++,
              s && (ho(t, !1),
              0 === t.strm.avail_out))
                  return 1
          } else if (t.match_available) {
              if (s = Da(t, 0, t.window[t.strstart - 1]),
              s && ho(t, !1),
              t.strstart++,
              t.lookahead--,
              0 === t.strm.avail_out)
                  return 1
          } else
              t.match_available = 1,
              t.strstart++,
              t.lookahead--
      }
      return t.match_available && (s = Da(t, 0, t.window[t.strstart - 1]),
      t.match_available = 0),
      t.insert = t.strstart < 2 ? t.strstart : 2,
      e === Pa ? (ho(t, !0),
      0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (ho(t, !1),
      0 === t.strm.avail_out) ? 1 : 2
  }
  ;
  function mo(t, e, i, s, r) {
      this.good_length = t,
      this.max_lazy = e,
      this.nice_length = i,
      this.max_chain = s,
      this.func = r
  }
  const vo = [new mo(0,0,0,0,bo), new mo(4,4,8,4,_o), new mo(4,5,16,8,_o), new mo(4,6,32,32,_o), new mo(4,4,16,16,po), new mo(8,16,32,32,po), new mo(8,16,128,128,po), new mo(8,32,128,256,po), new mo(32,128,258,1024,po), new mo(32,258,258,4096,po)];
  function xo() {
      this.strm = null,
      this.status = 0,
      this.pending_buf = null,
      this.pending_buf_size = 0,
      this.pending_out = 0,
      this.pending = 0,
      this.wrap = 0,
      this.gzhead = null,
      this.gzindex = 0,
      this.method = Ya,
      this.last_flush = -1,
      this.w_size = 0,
      this.w_bits = 0,
      this.w_mask = 0,
      this.window = null,
      this.window_size = 0,
      this.prev = null,
      this.head = null,
      this.ins_h = 0,
      this.hash_size = 0,
      this.hash_bits = 0,
      this.hash_mask = 0,
      this.hash_shift = 0,
      this.block_start = 0,
      this.match_length = 0,
      this.prev_match = 0,
      this.match_available = 0,
      this.strstart = 0,
      this.match_start = 0,
      this.lookahead = 0,
      this.prev_length = 0,
      this.max_chain_length = 0,
      this.max_lazy_match = 0,
      this.level = 0,
      this.strategy = 0,
      this.good_match = 0,
      this.nice_match = 0,
      this.dyn_ltree = new Uint16Array(1146),
      this.dyn_dtree = new Uint16Array(122),
      this.bl_tree = new Uint16Array(78),
      ro(this.dyn_ltree),
      ro(this.dyn_dtree),
      ro(this.bl_tree),
      this.l_desc = null,
      this.d_desc = null,
      this.bl_desc = null,
      this.bl_count = new Uint16Array(16),
      this.heap = new Uint16Array(573),
      ro(this.heap),
      this.heap_len = 0,
      this.heap_max = 0,
      this.depth = new Uint16Array(573),
      ro(this.depth),
      this.sym_buf = 0,
      this.lit_bufsize = 0,
      this.sym_next = 0,
      this.sym_end = 0,
      this.opt_len = 0,
      this.static_len = 0,
      this.matches = 0,
      this.insert = 0,
      this.bi_buf = 0,
      this.bi_valid = 0
  }
  const To = t => {
      if (!t)
          return 1;
      const e = t.state;
      return !e || e.strm !== t || e.status !== $a && 57 !== e.status && 69 !== e.status && 73 !== e.status && 91 !== e.status && 103 !== e.status && e.status !== to && e.status !== eo ? 1 : 0
  }
    , wo = t => {
      if (To(t))
          return io(t, Ga);
      t.total_in = t.total_out = 0,
      t.data_type = Ka;
      const e = t.state;
      return e.pending = 0,
      e.pending_out = 0,
      e.wrap < 0 && (e.wrap = -e.wrap),
      e.status = 2 === e.wrap ? 57 : e.wrap ? $a : to,
      t.adler = 2 === e.wrap ? 0 : 1,
      e.last_flush = -2,
      ka(e),
      za
  }
    , yo = t => {
      const e = wo(t);
      var i;
      return e === za && ((i = t.state).window_size = 2 * i.w_size,
      ro(i.head),
      i.max_lazy_match = vo[i.level].max_lazy,
      i.good_match = vo[i.level].good_length,
      i.nice_match = vo[i.level].nice_length,
      i.max_chain_length = vo[i.level].max_chain,
      i.strstart = 0,
      i.block_start = 0,
      i.lookahead = 0,
      i.insert = 0,
      i.match_length = i.prev_length = 2,
      i.match_available = 0,
      i.ins_h = 0),
      e
  }
    , Ao = (t, e, i, s, r, n) => {
      if (!t)
          return Ga;
      let a = 1;
      if (e === Ha && (e = 6),
      s < 0 ? (a = 0,
      s = -s) : s > 15 && (a = 2,
      s -= 16),
      r < 1 || r > 9 || i !== Ya || s < 8 || s > 15 || e < 0 || e > 9 || n < 0 || n > Wa || 8 === s && 1 !== a)
          return io(t, Ga);
      8 === s && (s = 9);
      const o = new xo;
      return t.state = o,
      o.strm = t,
      o.status = $a,
      o.wrap = a,
      o.gzhead = null,
      o.w_bits = s,
      o.w_size = 1 << o.w_bits,
      o.w_mask = o.w_size - 1,
      o.hash_bits = r + 7,
      o.hash_size = 1 << o.hash_bits,
      o.hash_mask = o.hash_size - 1,
      o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3),
      o.window = new Uint8Array(2 * o.w_size),
      o.head = new Uint16Array(o.hash_size),
      o.prev = new Uint16Array(o.w_size),
      o.lit_bufsize = 1 << r + 6,
      o.pending_buf_size = 4 * o.lit_bufsize,
      o.pending_buf = new Uint8Array(o.pending_buf_size),
      o.sym_buf = o.lit_bufsize,
      o.sym_end = 3 * (o.lit_bufsize - 1),
      o.level = e,
      o.strategy = n,
      o.method = i,
      yo(t)
  }
  ;
  var Eo = (t, e) => {
      if (To(t) || e > Ba || e < 0)
          return t ? io(t, Ga) : Ga;
      const i = t.state;
      if (!t.output || 0 !== t.avail_in && !t.input || i.status === eo && e !== Pa)
          return io(t, 0 === t.avail_out ? La : Ga);
      const s = i.last_flush;
      if (i.last_flush = e,
      0 !== i.pending) {
          if (oo(t),
          0 === t.avail_out)
              return i.last_flush = -1,
              za
      } else if (0 === t.avail_in && so(e) <= so(s) && e !== Pa)
          return io(t, La);
      if (i.status === eo && 0 !== t.avail_in)
          return io(t, La);
      if (i.status === $a && 0 === i.wrap && (i.status = to),
      i.status === $a) {
          let e = Ya + (i.w_bits - 8 << 4) << 8
            , s = -1;
          if (s = i.strategy >= qa || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3,
          e |= s << 6,
          0 !== i.strstart && (e |= 32),
          e += 31 - e % 31,
          uo(i, e),
          0 !== i.strstart && (uo(i, t.adler >>> 16),
          uo(i, 65535 & t.adler)),
          t.adler = 1,
          i.status = to,
          oo(t),
          0 !== i.pending)
              return i.last_flush = -1,
              za
      }
      if (57 === i.status)
          if (t.adler = 0,
          lo(i, 31),
          lo(i, 139),
          lo(i, 8),
          i.gzhead)
              lo(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)),
              lo(i, 255 & i.gzhead.time),
              lo(i, i.gzhead.time >> 8 & 255),
              lo(i, i.gzhead.time >> 16 & 255),
              lo(i, i.gzhead.time >> 24 & 255),
              lo(i, 9 === i.level ? 2 : i.strategy >= qa || i.level < 2 ? 4 : 0),
              lo(i, 255 & i.gzhead.os),
              i.gzhead.extra && i.gzhead.extra.length && (lo(i, 255 & i.gzhead.extra.length),
              lo(i, i.gzhead.extra.length >> 8 & 255)),
              i.gzhead.hcrc && (t.adler = Ea(t.adler, i.pending_buf, i.pending, 0)),
              i.gzindex = 0,
              i.status = 69;
          else if (lo(i, 0),
          lo(i, 0),
          lo(i, 0),
          lo(i, 0),
          lo(i, 0),
          lo(i, 9 === i.level ? 2 : i.strategy >= qa || i.level < 2 ? 4 : 0),
          lo(i, 3),
          i.status = to,
          oo(t),
          0 !== i.pending)
              return i.last_flush = -1,
              za;
      if (69 === i.status) {
          if (i.gzhead.extra) {
              let e = i.pending
                , s = (65535 & i.gzhead.extra.length) - i.gzindex;
              for (; i.pending + s > i.pending_buf_size; ) {
                  let r = i.pending_buf_size - i.pending;
                  if (i.pending_buf.set(i.gzhead.extra.subarray(i.gzindex, i.gzindex + r), i.pending),
                  i.pending = i.pending_buf_size,
                  i.gzhead.hcrc && i.pending > e && (t.adler = Ea(t.adler, i.pending_buf, i.pending - e, e)),
                  i.gzindex += r,
                  oo(t),
                  0 !== i.pending)
                      return i.last_flush = -1,
                      za;
                  e = 0,
                  s -= r
              }
              let r = new Uint8Array(i.gzhead.extra);
              i.pending_buf.set(r.subarray(i.gzindex, i.gzindex + s), i.pending),
              i.pending += s,
              i.gzhead.hcrc && i.pending > e && (t.adler = Ea(t.adler, i.pending_buf, i.pending - e, e)),
              i.gzindex = 0
          }
          i.status = 73
      }
      if (73 === i.status) {
          if (i.gzhead.name) {
              let e, s = i.pending;
              do {
                  if (i.pending === i.pending_buf_size) {
                      if (i.gzhead.hcrc && i.pending > s && (t.adler = Ea(t.adler, i.pending_buf, i.pending - s, s)),
                      oo(t),
                      0 !== i.pending)
                          return i.last_flush = -1,
                          za;
                      s = 0
                  }
                  e = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0,
                  lo(i, e)
              } while (0 !== e);
              i.gzhead.hcrc && i.pending > s && (t.adler = Ea(t.adler, i.pending_buf, i.pending - s, s)),
              i.gzindex = 0
          }
          i.status = 91
      }
      if (91 === i.status) {
          if (i.gzhead.comment) {
              let e, s = i.pending;
              do {
                  if (i.pending === i.pending_buf_size) {
                      if (i.gzhead.hcrc && i.pending > s && (t.adler = Ea(t.adler, i.pending_buf, i.pending - s, s)),
                      oo(t),
                      0 !== i.pending)
                          return i.last_flush = -1,
                          za;
                      s = 0
                  }
                  e = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0,
                  lo(i, e)
              } while (0 !== e);
              i.gzhead.hcrc && i.pending > s && (t.adler = Ea(t.adler, i.pending_buf, i.pending - s, s))
          }
          i.status = 103
      }
      if (103 === i.status) {
          if (i.gzhead.hcrc) {
              if (i.pending + 2 > i.pending_buf_size && (oo(t),
              0 !== i.pending))
                  return i.last_flush = -1,
                  za;
              lo(i, 255 & t.adler),
              lo(i, t.adler >> 8 & 255),
              t.adler = 0
          }
          if (i.status = to,
          oo(t),
          0 !== i.pending)
              return i.last_flush = -1,
              za
      }
      if (0 !== t.avail_in || 0 !== i.lookahead || e !== Ra && i.status !== eo) {
          let s = 0 === i.level ? bo(i, e) : i.strategy === qa ? ( (t, e) => {
              let i;
              for (; ; ) {
                  if (0 === t.lookahead && (go(t),
                  0 === t.lookahead)) {
                      if (e === Ra)
                          return 1;
                      break
                  }
                  if (t.match_length = 0,
                  i = Da(t, 0, t.window[t.strstart]),
                  t.lookahead--,
                  t.strstart++,
                  i && (ho(t, !1),
                  0 === t.strm.avail_out))
                      return 1
              }
              return t.insert = 0,
              e === Pa ? (ho(t, !0),
              0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (ho(t, !1),
              0 === t.strm.avail_out) ? 1 : 2
          }
          )(i, e) : i.strategy === Xa ? ( (t, e) => {
              let i, s, r, n;
              const a = t.window;
              for (; ; ) {
                  if (t.lookahead <= Ja) {
                      if (go(t),
                      t.lookahead <= Ja && e === Ra)
                          return 1;
                      if (0 === t.lookahead)
                          break
                  }
                  if (t.match_length = 0,
                  t.lookahead >= 3 && t.strstart > 0 && (r = t.strstart - 1,
                  s = a[r],
                  s === a[++r] && s === a[++r] && s === a[++r])) {
                      n = t.strstart + Ja;
                      do {} while (s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && s === a[++r] && r < n);
                      t.match_length = Ja - (n - r),
                      t.match_length > t.lookahead && (t.match_length = t.lookahead)
                  }
                  if (t.match_length >= 3 ? (i = Da(t, 1, t.match_length - 3),
                  t.lookahead -= t.match_length,
                  t.strstart += t.match_length,
                  t.match_length = 0) : (i = Da(t, 0, t.window[t.strstart]),
                  t.lookahead--,
                  t.strstart++),
                  i && (ho(t, !1),
                  0 === t.strm.avail_out))
                      return 1
              }
              return t.insert = 0,
              e === Pa ? (ho(t, !0),
              0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (ho(t, !1),
              0 === t.strm.avail_out) ? 1 : 2
          }
          )(i, e) : vo[i.level].func(i, e);
          if (3 !== s && 4 !== s || (i.status = eo),
          1 === s || 3 === s)
              return 0 === t.avail_out && (i.last_flush = -1),
              za;
          if (2 === s && (e === Ua ? Ia(i) : e !== Ba && (Fa(i, 0, 0, !1),
          e === Oa && (ro(i.head),
          0 === i.lookahead && (i.strstart = 0,
          i.block_start = 0,
          i.insert = 0))),
          oo(t),
          0 === t.avail_out))
              return i.last_flush = -1,
              za
      }
      return e !== Pa ? za : i.wrap <= 0 ? Na : (2 === i.wrap ? (lo(i, 255 & t.adler),
      lo(i, t.adler >> 8 & 255),
      lo(i, t.adler >> 16 & 255),
      lo(i, t.adler >> 24 & 255),
      lo(i, 255 & t.total_in),
      lo(i, t.total_in >> 8 & 255),
      lo(i, t.total_in >> 16 & 255),
      lo(i, t.total_in >> 24 & 255)) : (uo(i, t.adler >>> 16),
      uo(i, 65535 & t.adler)),
      oo(t),
      i.wrap > 0 && (i.wrap = -i.wrap),
      0 !== i.pending ? za : Na)
  }
    , Co = (t, e) => {
      let i = e.length;
      if (To(t))
          return Ga;
      const s = t.state
        , r = s.wrap;
      if (2 === r || 1 === r && s.status !== $a || s.lookahead)
          return Ga;
      if (1 === r && (t.adler = ya(t.adler, e, i, 0)),
      s.wrap = 0,
      i >= s.w_size) {
          0 === r && (ro(s.head),
          s.strstart = 0,
          s.block_start = 0,
          s.insert = 0);
          let t = new Uint8Array(s.w_size);
          t.set(e.subarray(i - s.w_size, i), 0),
          e = t,
          i = s.w_size
      }
      const n = t.avail_in
        , a = t.next_in
        , o = t.input;
      for (t.avail_in = i,
      t.next_in = 0,
      t.input = e,
      go(s); s.lookahead >= 3; ) {
          let t = s.strstart
            , e = s.lookahead - 2;
          do {
              s.ins_h = ao(s, s.ins_h, s.window[t + 3 - 1]),
              s.prev[t & s.w_mask] = s.head[s.ins_h],
              s.head[s.ins_h] = t,
              t++
          } while (--e);
          s.strstart = t,
          s.lookahead = 2,
          go(s)
      }
      return s.strstart += s.lookahead,
      s.block_start = s.strstart,
      s.insert = s.lookahead,
      s.lookahead = 0,
      s.match_length = s.prev_length = 2,
      s.match_available = 0,
      t.next_in = a,
      t.input = o,
      t.avail_in = n,
      s.wrap = r,
      za
  }
    , Mo = {
      deflateInit: (t, e) => Ao(t, e, Ya, 15, 8, Za),
      deflateInit2: Ao,
      deflateReset: yo,
      deflateResetKeep: wo,
      deflateSetHeader: (t, e) => To(t) || 2 !== t.state.wrap ? Ga : (t.state.gzhead = e,
      za),
      deflate: Eo,
      deflateEnd: t => {
          if (To(t))
              return Ga;
          const e = t.state.status;
          return t.state = null,
          e === to ? io(t, ja) : za
      }
      ,
      deflateSetDictionary: Co,
      deflateInfo: "pako deflate (from Nodeca project)"
  };
  const ko = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
  var Fo = {
      assign: function(t) {
          const e = Array.prototype.slice.call(arguments, 1);
          for (; e.length; ) {
              const i = e.shift();
              if (i) {
                  if ("object" != typeof i)
                      throw new TypeError(i + "must be non-object");
                  for (const e in i)
                      ko(i, e) && (t[e] = i[e])
              }
          }
          return t
      },
      flattenChunks: t => {
          let e = 0;
          for (let i = 0, s = t.length; i < s; i++)
              e += t[i].length;
          const i = new Uint8Array(e);
          for (let e = 0, s = 0, r = t.length; e < r; e++) {
              let r = t[e];
              i.set(r, s),
              s += r.length
          }
          return i
      }
  };
  let So = !0;
  try {
      String.fromCharCode.apply(null, new Uint8Array(1))
  } catch (t) {
      So = !1
  }
  const Do = new Uint8Array(256);
  for (let t = 0; t < 256; t++)
      Do[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
  Do[254] = Do[254] = 1;
  var Io = {
      string2buf: t => {
          if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
              return (new TextEncoder).encode(t);
          let e, i, s, r, n, a = t.length, o = 0;
          for (r = 0; r < a; r++)
              i = t.charCodeAt(r),
              55296 == (64512 & i) && r + 1 < a && (s = t.charCodeAt(r + 1),
              56320 == (64512 & s) && (i = 65536 + (i - 55296 << 10) + (s - 56320),
              r++)),
              o += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
          for (e = new Uint8Array(o),
          n = 0,
          r = 0; n < o; r++)
              i = t.charCodeAt(r),
              55296 == (64512 & i) && r + 1 < a && (s = t.charCodeAt(r + 1),
              56320 == (64512 & s) && (i = 65536 + (i - 55296 << 10) + (s - 56320),
              r++)),
              i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = 192 | i >>> 6,
              e[n++] = 128 | 63 & i) : i < 65536 ? (e[n++] = 224 | i >>> 12,
              e[n++] = 128 | i >>> 6 & 63,
              e[n++] = 128 | 63 & i) : (e[n++] = 240 | i >>> 18,
              e[n++] = 128 | i >>> 12 & 63,
              e[n++] = 128 | i >>> 6 & 63,
              e[n++] = 128 | 63 & i);
          return e
      }
      ,
      buf2string: (t, e) => {
          const i = e || t.length;
          if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
              return (new TextDecoder).decode(t.subarray(0, e));
          let s, r;
          const n = new Array(2 * i);
          for (r = 0,
          s = 0; s < i; ) {
              let e = t[s++];
              if (e < 128) {
                  n[r++] = e;
                  continue
              }
              let a = Do[e];
              if (a > 4)
                  n[r++] = 65533,
                  s += a - 1;
              else {
                  for (e &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && s < i; )
                      e = e << 6 | 63 & t[s++],
                      a--;
                  a > 1 ? n[r++] = 65533 : e < 65536 ? n[r++] = e : (e -= 65536,
                  n[r++] = 55296 | e >> 10 & 1023,
                  n[r++] = 56320 | 1023 & e)
              }
          }
          return ( (t, e) => {
              if (e < 65534 && t.subarray && So)
                  return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
              let i = "";
              for (let s = 0; s < e; s++)
                  i += String.fromCharCode(t[s]);
              return i
          }
          )(n, r)
      }
      ,
      utf8border: (t, e) => {
          (e = e || t.length) > t.length && (e = t.length);
          let i = e - 1;
          for (; i >= 0 && 128 == (192 & t[i]); )
              i--;
          return i < 0 || 0 === i ? e : i + Do[t[i]] > e ? i : e
      }
  };
  var Ro = function() {
      this.input = null,
      this.next_in = 0,
      this.avail_in = 0,
      this.total_in = 0,
      this.output = null,
      this.next_out = 0,
      this.avail_out = 0,
      this.total_out = 0,
      this.msg = "",
      this.state = null,
      this.data_type = 2,
      this.adler = 0
  };
  const Uo = Object.prototype.toString
    , {Z_NO_FLUSH: Oo, Z_SYNC_FLUSH: Po, Z_FULL_FLUSH: Bo, Z_FINISH: zo, Z_OK: No, Z_STREAM_END: Go, Z_DEFAULT_COMPRESSION: jo, Z_DEFAULT_STRATEGY: Lo, Z_DEFLATED: Ho} = Ma;
  function Vo(t) {
      this.options = Fo.assign({
          level: jo,
          method: Ho,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Lo
      }, t || {});
      let e = this.options;
      e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16),
      this.err = 0,
      this.msg = "",
      this.ended = !1,
      this.chunks = [],
      this.strm = new Ro,
      this.strm.avail_out = 0;
      let i = Mo.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
      if (i !== No)
          throw new Error(Ca[i]);
      if (e.header && Mo.deflateSetHeader(this.strm, e.header),
      e.dictionary) {
          let t;
          if (t = "string" == typeof e.dictionary ? Io.string2buf(e.dictionary) : "[object ArrayBuffer]" === Uo.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary,
          i = Mo.deflateSetDictionary(this.strm, t),
          i !== No)
              throw new Error(Ca[i]);
          this._dict_set = !0
      }
  }
  function qo(t, e) {
      const i = new Vo(e);
      if (i.push(t, !0),
      i.err)
          throw i.msg || Ca[i.err];
      return i.result
  }
  Vo.prototype.push = function(t, e) {
      const i = this.strm
        , s = this.options.chunkSize;
      let r, n;
      if (this.ended)
          return !1;
      for (n = e === ~~e ? e : !0 === e ? zo : Oo,
      "string" == typeof t ? i.input = Io.string2buf(t) : "[object ArrayBuffer]" === Uo.call(t) ? i.input = new Uint8Array(t) : i.input = t,
      i.next_in = 0,
      i.avail_in = i.input.length; ; )
          if (0 === i.avail_out && (i.output = new Uint8Array(s),
          i.next_out = 0,
          i.avail_out = s),
          (n === Po || n === Bo) && i.avail_out <= 6)
              this.onData(i.output.subarray(0, i.next_out)),
              i.avail_out = 0;
          else {
              if (r = Mo.deflate(i, n),
              r === Go)
                  return i.next_out > 0 && this.onData(i.output.subarray(0, i.next_out)),
                  r = Mo.deflateEnd(this.strm),
                  this.onEnd(r),
                  this.ended = !0,
                  r === No;
              if (0 !== i.avail_out) {
                  if (n > 0 && i.next_out > 0)
                      this.onData(i.output.subarray(0, i.next_out)),
                      i.avail_out = 0;
                  else if (0 === i.avail_in)
                      break
              } else
                  this.onData(i.output)
          }
      return !0
  }
  ,
  Vo.prototype.onData = function(t) {
      this.chunks.push(t)
  }
  ,
  Vo.prototype.onEnd = function(t) {
      t === No && (this.result = Fo.flattenChunks(this.chunks)),
      this.chunks = [],
      this.err = t,
      this.msg = this.strm.msg
  }
  ;
  var Xo = {
      Deflate: Vo,
      deflate: qo,
      deflateRaw: function(t, e) {
          return (e = e || {}).raw = !0,
          qo(t, e)
      },
      gzip: function(t, e) {
          return (e = e || {}).gzip = !0,
          qo(t, e)
      },
      constants: Ma
  };
  const Wo = 16209;
  var Zo = function(t, e) {
      let i, s, r, n, a, o, h, l, u, c, d, f, g, b, _, p, m, v, x, T, w, y, A, E;
      const C = t.state;
      i = t.next_in,
      A = t.input,
      s = i + (t.avail_in - 5),
      r = t.next_out,
      E = t.output,
      n = r - (e - t.avail_out),
      a = r + (t.avail_out - 257),
      o = C.dmax,
      h = C.wsize,
      l = C.whave,
      u = C.wnext,
      c = C.window,
      d = C.hold,
      f = C.bits,
      g = C.lencode,
      b = C.distcode,
      _ = (1 << C.lenbits) - 1,
      p = (1 << C.distbits) - 1;
      t: do {
          f < 15 && (d += A[i++] << f,
          f += 8,
          d += A[i++] << f,
          f += 8),
          m = g[d & _];
          e: for (; ; ) {
              if (v = m >>> 24,
              d >>>= v,
              f -= v,
              v = m >>> 16 & 255,
              0 === v)
                  E[r++] = 65535 & m;
              else {
                  if (!(16 & v)) {
                      if (64 & v) {
                          if (32 & v) {
                              C.mode = 16191;
                              break t
                          }
                          t.msg = "invalid literal/length code",
                          C.mode = Wo;
                          break t
                      }
                      m = g[(65535 & m) + (d & (1 << v) - 1)];
                      continue e
                  }
                  for (x = 65535 & m,
                  v &= 15,
                  v && (f < v && (d += A[i++] << f,
                  f += 8),
                  x += d & (1 << v) - 1,
                  d >>>= v,
                  f -= v),
                  f < 15 && (d += A[i++] << f,
                  f += 8,
                  d += A[i++] << f,
                  f += 8),
                  m = b[d & p]; ; ) {
                      if (v = m >>> 24,
                      d >>>= v,
                      f -= v,
                      v = m >>> 16 & 255,
                      16 & v) {
                          if (T = 65535 & m,
                          v &= 15,
                          f < v && (d += A[i++] << f,
                          f += 8,
                          f < v && (d += A[i++] << f,
                          f += 8)),
                          T += d & (1 << v) - 1,
                          T > o) {
                              t.msg = "invalid distance too far back",
                              C.mode = Wo;
                              break t
                          }
                          if (d >>>= v,
                          f -= v,
                          v = r - n,
                          T > v) {
                              if (v = T - v,
                              v > l && C.sane) {
                                  t.msg = "invalid distance too far back",
                                  C.mode = Wo;
                                  break t
                              }
                              if (w = 0,
                              y = c,
                              0 === u) {
                                  if (w += h - v,
                                  v < x) {
                                      x -= v;
                                      do {
                                          E[r++] = c[w++]
                                      } while (--v);
                                      w = r - T,
                                      y = E
                                  }
                              } else if (u < v) {
                                  if (w += h + u - v,
                                  v -= u,
                                  v < x) {
                                      x -= v;
                                      do {
                                          E[r++] = c[w++]
                                      } while (--v);
                                      if (w = 0,
                                      u < x) {
                                          v = u,
                                          x -= v;
                                          do {
                                              E[r++] = c[w++]
                                          } while (--v);
                                          w = r - T,
                                          y = E
                                      }
                                  }
                              } else if (w += u - v,
                              v < x) {
                                  x -= v;
                                  do {
                                      E[r++] = c[w++]
                                  } while (--v);
                                  w = r - T,
                                  y = E
                              }
                              for (; x > 2; )
                                  E[r++] = y[w++],
                                  E[r++] = y[w++],
                                  E[r++] = y[w++],
                                  x -= 3;
                              x && (E[r++] = y[w++],
                              x > 1 && (E[r++] = y[w++]))
                          } else {
                              w = r - T;
                              do {
                                  E[r++] = E[w++],
                                  E[r++] = E[w++],
                                  E[r++] = E[w++],
                                  x -= 3
                              } while (x > 2);
                              x && (E[r++] = E[w++],
                              x > 1 && (E[r++] = E[w++]))
                          }
                          break
                      }
                      if (64 & v) {
                          t.msg = "invalid distance code",
                          C.mode = Wo;
                          break t
                      }
                      m = b[(65535 & m) + (d & (1 << v) - 1)]
                  }
              }
              break
          }
      } while (i < s && r < a);
      x = f >> 3,
      i -= x,
      f -= x << 3,
      d &= (1 << f) - 1,
      t.next_in = i,
      t.next_out = r,
      t.avail_in = i < s ? s - i + 5 : 5 - (i - s),
      t.avail_out = r < a ? a - r + 257 : 257 - (r - a),
      C.hold = d,
      C.bits = f
  };
  const Ko = 15
    , Yo = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
    , Jo = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
    , Qo = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
    , $o = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
  var th = (t, e, i, s, r, n, a, o) => {
      const h = o.bits;
      let l, u, c, d, f, g, b = 0, _ = 0, p = 0, m = 0, v = 0, x = 0, T = 0, w = 0, y = 0, A = 0, E = null;
      const C = new Uint16Array(16)
        , M = new Uint16Array(16);
      let k, F, S, D = null;
      for (b = 0; b <= Ko; b++)
          C[b] = 0;
      for (_ = 0; _ < s; _++)
          C[e[i + _]]++;
      for (v = h,
      m = Ko; m >= 1 && 0 === C[m]; m--)
          ;
      if (v > m && (v = m),
      0 === m)
          return r[n++] = 20971520,
          r[n++] = 20971520,
          o.bits = 1,
          0;
      for (p = 1; p < m && 0 === C[p]; p++)
          ;
      for (v < p && (v = p),
      w = 1,
      b = 1; b <= Ko; b++)
          if (w <<= 1,
          w -= C[b],
          w < 0)
              return -1;
      if (w > 0 && (0 === t || 1 !== m))
          return -1;
      for (M[1] = 0,
      b = 1; b < Ko; b++)
          M[b + 1] = M[b] + C[b];
      for (_ = 0; _ < s; _++)
          0 !== e[i + _] && (a[M[e[i + _]]++] = _);
      if (0 === t ? (E = D = a,
      g = 20) : 1 === t ? (E = Yo,
      D = Jo,
      g = 257) : (E = Qo,
      D = $o,
      g = 0),
      A = 0,
      _ = 0,
      b = p,
      f = n,
      x = v,
      T = 0,
      c = -1,
      y = 1 << v,
      d = y - 1,
      1 === t && y > 852 || 2 === t && y > 592)
          return 1;
      for (; ; ) {
          k = b - T,
          a[_] + 1 < g ? (F = 0,
          S = a[_]) : a[_] >= g ? (F = D[a[_] - g],
          S = E[a[_] - g]) : (F = 96,
          S = 0),
          l = 1 << b - T,
          u = 1 << x,
          p = u;
          do {
              u -= l,
              r[f + (A >> T) + u] = k << 24 | F << 16 | S
          } while (0 !== u);
          for (l = 1 << b - 1; A & l; )
              l >>= 1;
          if (0 !== l ? (A &= l - 1,
          A += l) : A = 0,
          _++,
          0 == --C[b]) {
              if (b === m)
                  break;
              b = e[i + a[_]]
          }
          if (b > v && (A & d) !== c) {
              for (0 === T && (T = v),
              f += p,
              x = b - T,
              w = 1 << x; x + T < m && (w -= C[x + T],
              !(w <= 0)); )
                  x++,
                  w <<= 1;
              if (y += 1 << x,
              1 === t && y > 852 || 2 === t && y > 592)
                  return 1;
              c = A & d,
              r[c] = v << 24 | x << 16 | f - n
          }
      }
      return 0 !== A && (r[f + A] = b - T << 24 | 64 << 16),
      o.bits = v,
      0
  }
  ;
  const {Z_FINISH: eh, Z_BLOCK: ih, Z_TREES: sh, Z_OK: rh, Z_STREAM_END: nh, Z_NEED_DICT: ah, Z_STREAM_ERROR: oh, Z_DATA_ERROR: hh, Z_MEM_ERROR: lh, Z_BUF_ERROR: uh, Z_DEFLATED: ch} = Ma
    , dh = 16180
    , fh = 16190
    , gh = 16191
    , bh = 16192
    , _h = 16194
    , ph = 16199
    , mh = 16200
    , vh = 16206
    , xh = 16209
    , Th = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);
  function wh() {
      this.strm = null,
      this.mode = 0,
      this.last = !1,
      this.wrap = 0,
      this.havedict = !1,
      this.flags = 0,
      this.dmax = 0,
      this.check = 0,
      this.total = 0,
      this.head = null,
      this.wbits = 0,
      this.wsize = 0,
      this.whave = 0,
      this.wnext = 0,
      this.window = null,
      this.hold = 0,
      this.bits = 0,
      this.length = 0,
      this.offset = 0,
      this.extra = 0,
      this.lencode = null,
      this.distcode = null,
      this.lenbits = 0,
      this.distbits = 0,
      this.ncode = 0,
      this.nlen = 0,
      this.ndist = 0,
      this.have = 0,
      this.next = null,
      this.lens = new Uint16Array(320),
      this.work = new Uint16Array(288),
      this.lendyn = null,
      this.distdyn = null,
      this.sane = 0,
      this.back = 0,
      this.was = 0
  }
  const yh = t => {
      if (!t)
          return 1;
      const e = t.state;
      return !e || e.strm !== t || e.mode < dh || e.mode > 16211 ? 1 : 0
  }
    , Ah = t => {
      if (yh(t))
          return oh;
      const e = t.state;
      return t.total_in = t.total_out = e.total = 0,
      t.msg = "",
      e.wrap && (t.adler = 1 & e.wrap),
      e.mode = dh,
      e.last = 0,
      e.havedict = 0,
      e.flags = -1,
      e.dmax = 32768,
      e.head = null,
      e.hold = 0,
      e.bits = 0,
      e.lencode = e.lendyn = new Int32Array(852),
      e.distcode = e.distdyn = new Int32Array(592),
      e.sane = 1,
      e.back = -1,
      rh
  }
    , Eh = t => {
      if (yh(t))
          return oh;
      const e = t.state;
      return e.wsize = 0,
      e.whave = 0,
      e.wnext = 0,
      Ah(t)
  }
    , Ch = (t, e) => {
      let i;
      if (yh(t))
          return oh;
      const s = t.state;
      return e < 0 ? (i = 0,
      e = -e) : (i = 5 + (e >> 4),
      e < 48 && (e &= 15)),
      e && (e < 8 || e > 15) ? oh : (null !== s.window && s.wbits !== e && (s.window = null),
      s.wrap = i,
      s.wbits = e,
      Eh(t))
  }
    , Mh = (t, e) => {
      if (!t)
          return oh;
      const i = new wh;
      t.state = i,
      i.strm = t,
      i.window = null,
      i.mode = dh;
      const s = Ch(t, e);
      return s !== rh && (t.state = null),
      s
  }
  ;
  let kh, Fh, Sh = !0;
  const Dh = t => {
      if (Sh) {
          kh = new Int32Array(512),
          Fh = new Int32Array(32);
          let e = 0;
          for (; e < 144; )
              t.lens[e++] = 8;
          for (; e < 256; )
              t.lens[e++] = 9;
          for (; e < 280; )
              t.lens[e++] = 7;
          for (; e < 288; )
              t.lens[e++] = 8;
          for (th(1, t.lens, 0, 288, kh, 0, t.work, {
              bits: 9
          }),
          e = 0; e < 32; )
              t.lens[e++] = 5;
          th(2, t.lens, 0, 32, Fh, 0, t.work, {
              bits: 5
          }),
          Sh = !1
      }
      t.lencode = kh,
      t.lenbits = 9,
      t.distcode = Fh,
      t.distbits = 5
  }
    , Ih = (t, e, i, s) => {
      let r;
      const n = t.state;
      return null === n.window && (n.wsize = 1 << n.wbits,
      n.wnext = 0,
      n.whave = 0,
      n.window = new Uint8Array(n.wsize)),
      s >= n.wsize ? (n.window.set(e.subarray(i - n.wsize, i), 0),
      n.wnext = 0,
      n.whave = n.wsize) : (r = n.wsize - n.wnext,
      r > s && (r = s),
      n.window.set(e.subarray(i - s, i - s + r), n.wnext),
      (s -= r) ? (n.window.set(e.subarray(i - s, i), 0),
      n.wnext = s,
      n.whave = n.wsize) : (n.wnext += r,
      n.wnext === n.wsize && (n.wnext = 0),
      n.whave < n.wsize && (n.whave += r))),
      0
  }
  ;
  var Rh = (t, e) => {
      let i, s, r, n, a, o, h, l, u, c, d, f, g, b, _, p, m, v, x, T, w, y, A = 0;
      const E = new Uint8Array(4);
      let C, M;
      const k = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      if (yh(t) || !t.output || !t.input && 0 !== t.avail_in)
          return oh;
      i = t.state,
      i.mode === gh && (i.mode = bh),
      a = t.next_out,
      r = t.output,
      h = t.avail_out,
      n = t.next_in,
      s = t.input,
      o = t.avail_in,
      l = i.hold,
      u = i.bits,
      c = o,
      d = h,
      y = rh;
      t: for (; ; )
          switch (i.mode) {
          case dh:
              if (0 === i.wrap) {
                  i.mode = bh;
                  break
              }
              for (; u < 16; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              if (2 & i.wrap && 35615 === l) {
                  0 === i.wbits && (i.wbits = 15),
                  i.check = 0,
                  E[0] = 255 & l,
                  E[1] = l >>> 8 & 255,
                  i.check = Ea(i.check, E, 2, 0),
                  l = 0,
                  u = 0,
                  i.mode = 16181;
                  break
              }
              if (i.head && (i.head.done = !1),
              !(1 & i.wrap) || (((255 & l) << 8) + (l >> 8)) % 31) {
                  t.msg = "incorrect header check",
                  i.mode = xh;
                  break
              }
              if ((15 & l) !== ch) {
                  t.msg = "unknown compression method",
                  i.mode = xh;
                  break
              }
              if (l >>>= 4,
              u -= 4,
              w = 8 + (15 & l),
              0 === i.wbits && (i.wbits = w),
              w > 15 || w > i.wbits) {
                  t.msg = "invalid window size",
                  i.mode = xh;
                  break
              }
              i.dmax = 1 << i.wbits,
              i.flags = 0,
              t.adler = i.check = 1,
              i.mode = 512 & l ? 16189 : gh,
              l = 0,
              u = 0;
              break;
          case 16181:
              for (; u < 16; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              if (i.flags = l,
              (255 & i.flags) !== ch) {
                  t.msg = "unknown compression method",
                  i.mode = xh;
                  break
              }
              if (57344 & i.flags) {
                  t.msg = "unknown header flags set",
                  i.mode = xh;
                  break
              }
              i.head && (i.head.text = l >> 8 & 1),
              512 & i.flags && 4 & i.wrap && (E[0] = 255 & l,
              E[1] = l >>> 8 & 255,
              i.check = Ea(i.check, E, 2, 0)),
              l = 0,
              u = 0,
              i.mode = 16182;
          case 16182:
              for (; u < 32; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              i.head && (i.head.time = l),
              512 & i.flags && 4 & i.wrap && (E[0] = 255 & l,
              E[1] = l >>> 8 & 255,
              E[2] = l >>> 16 & 255,
              E[3] = l >>> 24 & 255,
              i.check = Ea(i.check, E, 4, 0)),
              l = 0,
              u = 0,
              i.mode = 16183;
          case 16183:
              for (; u < 16; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              i.head && (i.head.xflags = 255 & l,
              i.head.os = l >> 8),
              512 & i.flags && 4 & i.wrap && (E[0] = 255 & l,
              E[1] = l >>> 8 & 255,
              i.check = Ea(i.check, E, 2, 0)),
              l = 0,
              u = 0,
              i.mode = 16184;
          case 16184:
              if (1024 & i.flags) {
                  for (; u < 16; ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  i.length = l,
                  i.head && (i.head.extra_len = l),
                  512 & i.flags && 4 & i.wrap && (E[0] = 255 & l,
                  E[1] = l >>> 8 & 255,
                  i.check = Ea(i.check, E, 2, 0)),
                  l = 0,
                  u = 0
              } else
                  i.head && (i.head.extra = null);
              i.mode = 16185;
          case 16185:
              if (1024 & i.flags && (f = i.length,
              f > o && (f = o),
              f && (i.head && (w = i.head.extra_len - i.length,
              i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)),
              i.head.extra.set(s.subarray(n, n + f), w)),
              512 & i.flags && 4 & i.wrap && (i.check = Ea(i.check, s, f, n)),
              o -= f,
              n += f,
              i.length -= f),
              i.length))
                  break t;
              i.length = 0,
              i.mode = 16186;
          case 16186:
              if (2048 & i.flags) {
                  if (0 === o)
                      break t;
                  f = 0;
                  do {
                      w = s[n + f++],
                      i.head && w && i.length < 65536 && (i.head.name += String.fromCharCode(w))
                  } while (w && f < o);
                  if (512 & i.flags && 4 & i.wrap && (i.check = Ea(i.check, s, f, n)),
                  o -= f,
                  n += f,
                  w)
                      break t
              } else
                  i.head && (i.head.name = null);
              i.length = 0,
              i.mode = 16187;
          case 16187:
              if (4096 & i.flags) {
                  if (0 === o)
                      break t;
                  f = 0;
                  do {
                      w = s[n + f++],
                      i.head && w && i.length < 65536 && (i.head.comment += String.fromCharCode(w))
                  } while (w && f < o);
                  if (512 & i.flags && 4 & i.wrap && (i.check = Ea(i.check, s, f, n)),
                  o -= f,
                  n += f,
                  w)
                      break t
              } else
                  i.head && (i.head.comment = null);
              i.mode = 16188;
          case 16188:
              if (512 & i.flags) {
                  for (; u < 16; ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  if (4 & i.wrap && l !== (65535 & i.check)) {
                      t.msg = "header crc mismatch",
                      i.mode = xh;
                      break
                  }
                  l = 0,
                  u = 0
              }
              i.head && (i.head.hcrc = i.flags >> 9 & 1,
              i.head.done = !0),
              t.adler = i.check = 0,
              i.mode = gh;
              break;
          case 16189:
              for (; u < 32; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              t.adler = i.check = Th(l),
              l = 0,
              u = 0,
              i.mode = fh;
          case fh:
              if (0 === i.havedict)
                  return t.next_out = a,
                  t.avail_out = h,
                  t.next_in = n,
                  t.avail_in = o,
                  i.hold = l,
                  i.bits = u,
                  ah;
              t.adler = i.check = 1,
              i.mode = gh;
          case gh:
              if (e === ih || e === sh)
                  break t;
          case bh:
              if (i.last) {
                  l >>>= 7 & u,
                  u -= 7 & u,
                  i.mode = vh;
                  break
              }
              for (; u < 3; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              switch (i.last = 1 & l,
              l >>>= 1,
              u -= 1,
              3 & l) {
              case 0:
                  i.mode = 16193;
                  break;
              case 1:
                  if (Dh(i),
                  i.mode = ph,
                  e === sh) {
                      l >>>= 2,
                      u -= 2;
                      break t
                  }
                  break;
              case 2:
                  i.mode = 16196;
                  break;
              case 3:
                  t.msg = "invalid block type",
                  i.mode = xh
              }
              l >>>= 2,
              u -= 2;
              break;
          case 16193:
              for (l >>>= 7 & u,
              u -= 7 & u; u < 32; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              if ((65535 & l) != (l >>> 16 ^ 65535)) {
                  t.msg = "invalid stored block lengths",
                  i.mode = xh;
                  break
              }
              if (i.length = 65535 & l,
              l = 0,
              u = 0,
              i.mode = _h,
              e === sh)
                  break t;
          case _h:
              i.mode = 16195;
          case 16195:
              if (f = i.length,
              f) {
                  if (f > o && (f = o),
                  f > h && (f = h),
                  0 === f)
                      break t;
                  r.set(s.subarray(n, n + f), a),
                  o -= f,
                  n += f,
                  h -= f,
                  a += f,
                  i.length -= f;
                  break
              }
              i.mode = gh;
              break;
          case 16196:
              for (; u < 14; ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              if (i.nlen = 257 + (31 & l),
              l >>>= 5,
              u -= 5,
              i.ndist = 1 + (31 & l),
              l >>>= 5,
              u -= 5,
              i.ncode = 4 + (15 & l),
              l >>>= 4,
              u -= 4,
              i.nlen > 286 || i.ndist > 30) {
                  t.msg = "too many length or distance symbols",
                  i.mode = xh;
                  break
              }
              i.have = 0,
              i.mode = 16197;
          case 16197:
              for (; i.have < i.ncode; ) {
                  for (; u < 3; ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  i.lens[k[i.have++]] = 7 & l,
                  l >>>= 3,
                  u -= 3
              }
              for (; i.have < 19; )
                  i.lens[k[i.have++]] = 0;
              if (i.lencode = i.lendyn,
              i.lenbits = 7,
              C = {
                  bits: i.lenbits
              },
              y = th(0, i.lens, 0, 19, i.lencode, 0, i.work, C),
              i.lenbits = C.bits,
              y) {
                  t.msg = "invalid code lengths set",
                  i.mode = xh;
                  break
              }
              i.have = 0,
              i.mode = 16198;
          case 16198:
              for (; i.have < i.nlen + i.ndist; ) {
                  for (; A = i.lencode[l & (1 << i.lenbits) - 1],
                  _ = A >>> 24,
                  p = A >>> 16 & 255,
                  m = 65535 & A,
                  !(_ <= u); ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  if (m < 16)
                      l >>>= _,
                      u -= _,
                      i.lens[i.have++] = m;
                  else {
                      if (16 === m) {
                          for (M = _ + 2; u < M; ) {
                              if (0 === o)
                                  break t;
                              o--,
                              l += s[n++] << u,
                              u += 8
                          }
                          if (l >>>= _,
                          u -= _,
                          0 === i.have) {
                              t.msg = "invalid bit length repeat",
                              i.mode = xh;
                              break
                          }
                          w = i.lens[i.have - 1],
                          f = 3 + (3 & l),
                          l >>>= 2,
                          u -= 2
                      } else if (17 === m) {
                          for (M = _ + 3; u < M; ) {
                              if (0 === o)
                                  break t;
                              o--,
                              l += s[n++] << u,
                              u += 8
                          }
                          l >>>= _,
                          u -= _,
                          w = 0,
                          f = 3 + (7 & l),
                          l >>>= 3,
                          u -= 3
                      } else {
                          for (M = _ + 7; u < M; ) {
                              if (0 === o)
                                  break t;
                              o--,
                              l += s[n++] << u,
                              u += 8
                          }
                          l >>>= _,
                          u -= _,
                          w = 0,
                          f = 11 + (127 & l),
                          l >>>= 7,
                          u -= 7
                      }
                      if (i.have + f > i.nlen + i.ndist) {
                          t.msg = "invalid bit length repeat",
                          i.mode = xh;
                          break
                      }
                      for (; f--; )
                          i.lens[i.have++] = w
                  }
              }
              if (i.mode === xh)
                  break;
              if (0 === i.lens[256]) {
                  t.msg = "invalid code -- missing end-of-block",
                  i.mode = xh;
                  break
              }
              if (i.lenbits = 9,
              C = {
                  bits: i.lenbits
              },
              y = th(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, C),
              i.lenbits = C.bits,
              y) {
                  t.msg = "invalid literal/lengths set",
                  i.mode = xh;
                  break
              }
              if (i.distbits = 6,
              i.distcode = i.distdyn,
              C = {
                  bits: i.distbits
              },
              y = th(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, C),
              i.distbits = C.bits,
              y) {
                  t.msg = "invalid distances set",
                  i.mode = xh;
                  break
              }
              if (i.mode = ph,
              e === sh)
                  break t;
          case ph:
              i.mode = mh;
          case mh:
              if (o >= 6 && h >= 258) {
                  t.next_out = a,
                  t.avail_out = h,
                  t.next_in = n,
                  t.avail_in = o,
                  i.hold = l,
                  i.bits = u,
                  Zo(t, d),
                  a = t.next_out,
                  r = t.output,
                  h = t.avail_out,
                  n = t.next_in,
                  s = t.input,
                  o = t.avail_in,
                  l = i.hold,
                  u = i.bits,
                  i.mode === gh && (i.back = -1);
                  break
              }
              for (i.back = 0; A = i.lencode[l & (1 << i.lenbits) - 1],
              _ = A >>> 24,
              p = A >>> 16 & 255,
              m = 65535 & A,
              !(_ <= u); ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              if (p && !(240 & p)) {
                  for (v = _,
                  x = p,
                  T = m; A = i.lencode[T + ((l & (1 << v + x) - 1) >> v)],
                  _ = A >>> 24,
                  p = A >>> 16 & 255,
                  m = 65535 & A,
                  !(v + _ <= u); ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  l >>>= v,
                  u -= v,
                  i.back += v
              }
              if (l >>>= _,
              u -= _,
              i.back += _,
              i.length = m,
              0 === p) {
                  i.mode = 16205;
                  break
              }
              if (32 & p) {
                  i.back = -1,
                  i.mode = gh;
                  break
              }
              if (64 & p) {
                  t.msg = "invalid literal/length code",
                  i.mode = xh;
                  break
              }
              i.extra = 15 & p,
              i.mode = 16201;
          case 16201:
              if (i.extra) {
                  for (M = i.extra; u < M; ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  i.length += l & (1 << i.extra) - 1,
                  l >>>= i.extra,
                  u -= i.extra,
                  i.back += i.extra
              }
              i.was = i.length,
              i.mode = 16202;
          case 16202:
              for (; A = i.distcode[l & (1 << i.distbits) - 1],
              _ = A >>> 24,
              p = A >>> 16 & 255,
              m = 65535 & A,
              !(_ <= u); ) {
                  if (0 === o)
                      break t;
                  o--,
                  l += s[n++] << u,
                  u += 8
              }
              if (!(240 & p)) {
                  for (v = _,
                  x = p,
                  T = m; A = i.distcode[T + ((l & (1 << v + x) - 1) >> v)],
                  _ = A >>> 24,
                  p = A >>> 16 & 255,
                  m = 65535 & A,
                  !(v + _ <= u); ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  l >>>= v,
                  u -= v,
                  i.back += v
              }
              if (l >>>= _,
              u -= _,
              i.back += _,
              64 & p) {
                  t.msg = "invalid distance code",
                  i.mode = xh;
                  break
              }
              i.offset = m,
              i.extra = 15 & p,
              i.mode = 16203;
          case 16203:
              if (i.extra) {
                  for (M = i.extra; u < M; ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  i.offset += l & (1 << i.extra) - 1,
                  l >>>= i.extra,
                  u -= i.extra,
                  i.back += i.extra
              }
              if (i.offset > i.dmax) {
                  t.msg = "invalid distance too far back",
                  i.mode = xh;
                  break
              }
              i.mode = 16204;
          case 16204:
              if (0 === h)
                  break t;
              if (f = d - h,
              i.offset > f) {
                  if (f = i.offset - f,
                  f > i.whave && i.sane) {
                      t.msg = "invalid distance too far back",
                      i.mode = xh;
                      break
                  }
                  f > i.wnext ? (f -= i.wnext,
                  g = i.wsize - f) : g = i.wnext - f,
                  f > i.length && (f = i.length),
                  b = i.window
              } else
                  b = r,
                  g = a - i.offset,
                  f = i.length;
              f > h && (f = h),
              h -= f,
              i.length -= f;
              do {
                  r[a++] = b[g++]
              } while (--f);
              0 === i.length && (i.mode = mh);
              break;
          case 16205:
              if (0 === h)
                  break t;
              r[a++] = i.length,
              h--,
              i.mode = mh;
              break;
          case vh:
              if (i.wrap) {
                  for (; u < 32; ) {
                      if (0 === o)
                          break t;
                      o--,
                      l |= s[n++] << u,
                      u += 8
                  }
                  if (d -= h,
                  t.total_out += d,
                  i.total += d,
                  4 & i.wrap && d && (t.adler = i.check = i.flags ? Ea(i.check, r, d, a - d) : ya(i.check, r, d, a - d)),
                  d = h,
                  4 & i.wrap && (i.flags ? l : Th(l)) !== i.check) {
                      t.msg = "incorrect data check",
                      i.mode = xh;
                      break
                  }
                  l = 0,
                  u = 0
              }
              i.mode = 16207;
          case 16207:
              if (i.wrap && i.flags) {
                  for (; u < 32; ) {
                      if (0 === o)
                          break t;
                      o--,
                      l += s[n++] << u,
                      u += 8
                  }
                  if (4 & i.wrap && l !== (4294967295 & i.total)) {
                      t.msg = "incorrect length check",
                      i.mode = xh;
                      break
                  }
                  l = 0,
                  u = 0
              }
              i.mode = 16208;
          case 16208:
              y = nh;
              break t;
          case xh:
              y = hh;
              break t;
          case 16210:
              return lh;
          default:
              return oh
          }
      return t.next_out = a,
      t.avail_out = h,
      t.next_in = n,
      t.avail_in = o,
      i.hold = l,
      i.bits = u,
      (i.wsize || d !== t.avail_out && i.mode < xh && (i.mode < vh || e !== eh)) && Ih(t, t.output, t.next_out, d - t.avail_out),
      c -= t.avail_in,
      d -= t.avail_out,
      t.total_in += c,
      t.total_out += d,
      i.total += d,
      4 & i.wrap && d && (t.adler = i.check = i.flags ? Ea(i.check, r, d, t.next_out - d) : ya(i.check, r, d, t.next_out - d)),
      t.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === gh ? 128 : 0) + (i.mode === ph || i.mode === _h ? 256 : 0),
      (0 === c && 0 === d || e === eh) && y === rh && (y = uh),
      y
  }
    , Uh = {
      inflateReset: Eh,
      inflateReset2: Ch,
      inflateResetKeep: Ah,
      inflateInit: t => Mh(t, 15),
      inflateInit2: Mh,
      inflate: Rh,
      inflateEnd: t => {
          if (yh(t))
              return oh;
          let e = t.state;
          return e.window && (e.window = null),
          t.state = null,
          rh
      }
      ,
      inflateGetHeader: (t, e) => {
          if (yh(t))
              return oh;
          const i = t.state;
          return 2 & i.wrap ? (i.head = e,
          e.done = !1,
          rh) : oh
      }
      ,
      inflateSetDictionary: (t, e) => {
          const i = e.length;
          let s, r, n;
          return yh(t) ? oh : (s = t.state,
          0 !== s.wrap && s.mode !== fh ? oh : s.mode === fh && (r = 1,
          r = ya(r, e, i, 0),
          r !== s.check) ? hh : (n = Ih(t, e, i, i),
          n ? (s.mode = 16210,
          lh) : (s.havedict = 1,
          rh)))
      }
      ,
      inflateInfo: "pako inflate (from Nodeca project)"
  };
  var Oh = function() {
      this.text = 0,
      this.time = 0,
      this.xflags = 0,
      this.os = 0,
      this.extra = null,
      this.extra_len = 0,
      this.name = "",
      this.comment = "",
      this.hcrc = 0,
      this.done = !1
  };
  const Ph = Object.prototype.toString
    , {Z_NO_FLUSH: Bh, Z_FINISH: zh, Z_OK: Nh, Z_STREAM_END: Gh, Z_NEED_DICT: jh, Z_STREAM_ERROR: Lh, Z_DATA_ERROR: Hh, Z_MEM_ERROR: Vh} = Ma;
  function qh(t) {
      this.options = Fo.assign({
          chunkSize: 65536,
          windowBits: 15,
          to: ""
      }, t || {});
      const e = this.options;
      e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits,
      0 === e.windowBits && (e.windowBits = -15)),
      !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32),
      e.windowBits > 15 && e.windowBits < 48 && (15 & e.windowBits || (e.windowBits |= 15)),
      this.err = 0,
      this.msg = "",
      this.ended = !1,
      this.chunks = [],
      this.strm = new Ro,
      this.strm.avail_out = 0;
      let i = Uh.inflateInit2(this.strm, e.windowBits);
      if (i !== Nh)
          throw new Error(Ca[i]);
      if (this.header = new Oh,
      Uh.inflateGetHeader(this.strm, this.header),
      e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = Io.string2buf(e.dictionary) : "[object ArrayBuffer]" === Ph.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)),
      e.raw && (i = Uh.inflateSetDictionary(this.strm, e.dictionary),
      i !== Nh)))
          throw new Error(Ca[i])
  }
  function Xh(t, e) {
      const i = new qh(e);
      if (i.push(t),
      i.err)
          throw i.msg || Ca[i.err];
      return i.result
  }
  qh.prototype.push = function(t, e) {
      const i = this.strm
        , s = this.options.chunkSize
        , r = this.options.dictionary;
      let n, a, o;
      if (this.ended)
          return !1;
      for (a = e === ~~e ? e : !0 === e ? zh : Bh,
      "[object ArrayBuffer]" === Ph.call(t) ? i.input = new Uint8Array(t) : i.input = t,
      i.next_in = 0,
      i.avail_in = i.input.length; ; ) {
          for (0 === i.avail_out && (i.output = new Uint8Array(s),
          i.next_out = 0,
          i.avail_out = s),
          n = Uh.inflate(i, a),
          n === jh && r && (n = Uh.inflateSetDictionary(i, r),
          n === Nh ? n = Uh.inflate(i, a) : n === Hh && (n = jh)); i.avail_in > 0 && n === Gh && i.state.wrap > 0 && 0 !== t[i.next_in]; )
              Uh.inflateReset(i),
              n = Uh.inflate(i, a);
          switch (n) {
          case Lh:
          case Hh:
          case jh:
          case Vh:
              return this.onEnd(n),
              this.ended = !0,
              !1
          }
          if (o = i.avail_out,
          i.next_out && (0 === i.avail_out || n === Gh))
              if ("string" === this.options.to) {
                  let t = Io.utf8border(i.output, i.next_out)
                    , e = i.next_out - t
                    , r = Io.buf2string(i.output, t);
                  i.next_out = e,
                  i.avail_out = s - e,
                  e && i.output.set(i.output.subarray(t, t + e), 0),
                  this.onData(r)
              } else
                  this.onData(i.output.length === i.next_out ? i.output : i.output.subarray(0, i.next_out));
          if (n !== Nh || 0 !== o) {
              if (n === Gh)
                  return n = Uh.inflateEnd(this.strm),
                  this.onEnd(n),
                  this.ended = !0,
                  !0;
              if (0 === i.avail_in)
                  break
          }
      }
      return !0
  }
  ,
  qh.prototype.onData = function(t) {
      this.chunks.push(t)
  }
  ,
  qh.prototype.onEnd = function(t) {
      t === Nh && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Fo.flattenChunks(this.chunks)),
      this.chunks = [],
      this.err = t,
      this.msg = this.strm.msg
  }
  ;
  var Wh = {
      Inflate: qh,
      inflate: Xh,
      inflateRaw: function(t, e) {
          return (e = e || {}).raw = !0,
          Xh(t, e)
      },
      ungzip: Xh,
      constants: Ma
  };
  const {Deflate: Zh, deflate: Kh, deflateRaw: Yh, gzip: Jh} = Xo
    , {Inflate: Qh, inflate: $h, inflateRaw: tl, ungzip: el} = Wh;
  var il = $h;
  class sl {
      constructor(t) {
          var e = this;
          e.h = t.getUint16(),
          e.i = t.getUint16(),
          e.m = t.getUint32(),
          e.j = t.getUint32(),
          e.a = t.getUint16(),
          e.g = t.getUint16(),
          e.d = t.getUint16(),
          e.b = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          e.c = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          e.e = t.getInt16(),
          e.f = t.getUint16(),
          t.getBool() && (e.l = t.getString())
      }
      k() {}
  }
  class rl {
      constructor(t) {
          var e;
          if (this.j = t.getInt32(),
          this.b = t.getInt32(),
          this.e = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          (e = t.getInt32()) > 0) {
              this.i = new Array(e);
              for (let i = 0; i < e; ++i)
                  this.i[i] = t.getInt16()
          }
          if ((e = t.getInt32()) > 0) {
              this.a = new Array(e);
              for (let i = 0; i < e; ++i)
                  this.a[i] = t.getInt16()
          }
          this.d = new tn(t,qr),
          this.p = new tn(t,Wr),
          this.m = new tn(t,Zr),
          this.k = new tn(t,Zr),
          this.c = t.getFloat(),
          this.o = t.getFloat(),
          this.n = t.getFloat(),
          this.h = t.getInt16(),
          this.g = t.getInt16(),
          this.f = new tn(t,Wr),
          this.r = new tn(t,Kr),
          this.q = t.getInt16()
      }
  }
  class nl {
      constructor(t) {
          this.a = t.getInt32(),
          this.b = t.getUint32(),
          this.c = t.getUint32()
      }
  }
  class al {
      constructor(t) {
          this.c = t.getUint8(),
          this.l = t.getInt8(),
          this.i = t.getUint16(),
          this.a = t.getUint16(),
          this.d = t.getUint16(),
          this.e = t.getInt16(),
          this.g = t.getUint16(),
          this.k = t.getUint16(),
          this.m = t.getUint16(),
          this.f = t.getInt16(),
          this.h = t.getUint16(),
          this.j = t.getInt16(),
          this.b = t.getInt16()
      }
  }
  class ol {
      constructor(t) {
          this.c = t.getInt16(),
          this.i = t.getInt16(),
          this.j = _i(t.getFloat(), t.getFloat(), t.getFloat()),
          this.g = new tn(t,qr),
          this.a = new tn(t,Zr),
          this.f = new tn(t,qr),
          this.b = new tn(t,Zr),
          this.d = new tn(t,Zr),
          this.e = new tn(t,Zr),
          this.h = new tn(t,Kr)
      }
  }
  const hl = class {
      constructor(t) {
          var e = this;
          e.b = t.getInt16(),
          e.d = t.getFloat(),
          e.a = t.getFloat(),
          e.c = t.getUint16(),
          e.e = t.getUint32()
      }
  }
  ;
  class ll {
      constructor(t) {
          if (this.r = [],
          this.O = [],
          this.b = [],
          this.Q = [],
          this.D = [],
          this.i = [],
          this.K = [],
          this.q = [],
          this.C = [],
          this.a = [],
          this.F = [],
          this.H = [],
          this.o = [],
          this.x = [],
          this.L = [],
          this.e = [],
          this.f = [],
          this.m = [],
          this.u = [],
          this.M = [],
          this.y = [],
          this.t = [],
          this.B = [],
          this.z = [],
          this.l = [],
          this.v = [],
          this.A = [],
          this.N = [],
          this.n = [],
          this.k = [],
          this.d = [],
          this.c = [],
          this.R = [],
          this.p = [],
          this.j = [],
          !t)
              return void console.error("Bad buffer for DataView");
          let e = new Pn(t);
          if (604210112 != e.getUint32())
              return void console.log("Bad magic value");
          if (e.getUint32() < 2e3)
              return void console.log("Bad version");
          this.J = e.getUint32();
          var i = e.getUint32()
            , s = e.getUint32()
            , r = e.getUint32()
            , n = e.getUint32()
            , a = e.getUint32()
            , o = e.getUint32()
            , h = e.getUint32()
            , l = e.getUint32()
            , u = e.getUint32()
            , c = e.getUint32()
            , d = e.getUint32()
            , f = e.getUint32()
            , g = e.getUint32()
            , b = e.getUint32()
            , _ = e.getUint32()
            , p = e.getUint32()
            , m = e.getUint32()
            , v = e.getUint32()
            , x = e.getUint32()
            , T = e.getUint32()
            , w = e.getUint32()
            , y = e.getUint32()
            , A = e.getUint32()
            , E = e.getUint32()
            , C = e.getUint32()
            , M = e.getUint32()
            , k = e.getUint32()
            , F = e.getUint32()
            , S = e.getUint32()
            , D = e.getUint32()
            , I = e.getUint32()
            , R = e.getUint32()
            , U = e.getUint32()
            , O = e.getUint32()
            , P = e.getUint32();
          let B = new Uint8Array(t,e.position)
            , z = null;
          try {
              z = il(B)
          } catch (t) {
              return void console.log("Decompression error: " + t)
          }
          if (z.length < P)
              console.log("Unexpected data size", z.length, P);
          else {
              e = new Pn(z.buffer),
              e.position = i;
              var N = e.getInt32();
              if (N > 0) {
                  this.r = new Array(N);
                  for (let t = 0; t < N; ++t)
                      this.r[t] = new Cn(e)
              }
              e.position = s;
              var G = e.getInt32();
              if (G > 0) {
                  this.O = new Array(G);
                  for (let t = 0; t < G; ++t)
                      this.O[t] = e.getUint16()
              }
              e.position = r;
              var j = e.getInt32();
              if (j > 0) {
                  this.b = new Array(j);
                  for (let t = 0; t < j; ++t)
                      this.b[t] = e.getUint32()
              }
              e.position = n;
              var L = e.getInt32();
              if (L > 0) {
                  this.Q = new Array(L);
                  for (let t = 0; t < L; ++t)
                      this.Q[t] = new sl(e)
              }
              e.position = a;
              var H = e.getInt32();
              if (H > 0) {
                  this.D = new Array(H);
                  for (let t = 0; t < H; ++t)
                      this.D[t] = e.getInt16()
              }
              e.position = o;
              var V = e.getInt32();
              if (V > 0) {
                  this.i = new Array(V);
                  for (let t = 0; t < V; ++t)
                      this.i[t] = new On(e)
              }
              e.position = h;
              var q = e.getInt32();
              if (q > 0) {
                  this.K = new Array(q);
                  for (let t = 0; t < q; ++t)
                      this.K[t] = e.getInt16()
              }
              e.position = l;
              var X = e.getInt32();
              if (X > 0) {
                  this.q = new Array(X);
                  for (let t = 0; t < X; ++t)
                      this.q[t] = e.getInt16()
              }
              e.position = u;
              var W = e.getInt32();
              if (W > 0) {
                  this.C = new Array(W);
                  for (let t = 0; t < W; ++t)
                      this.C[t] = new Mn(e)
              }
              e.position = c;
              var Z = e.getInt32();
              if (Z > 0) {
                  this.a = new Array(Z);
                  for (let t = 0; t < Z; ++t)
                      this.a[t] = new al(e)
              }
              e.position = d;
              var K = e.getInt32();
              if (K > 0) {
                  this.F = new Array(K);
                  for (let t = 0; t < K; ++t)
                      this.F[t] = e.getInt16()
              }
              e.position = f;
              var Y = e.getInt32();
              if (Y > 0) {
                  this.h = new Array(Y);
                  for (let t = 0; t < Y; ++t)
                      this.h[t] = new kn(e)
              }
              e.position = g;
              var J = e.getInt32();
              if (J > 0) {
                  this.H = new Array(J);
                  for (let t = 0; t < J; ++t)
                      this.H[t] = new nl(e)
              }
              e.position = b;
              var Q = e.getInt32();
              if (Q > 0) {
                  this.o = new Array(Q);
                  for (let t = 0; t < Q; ++t)
                      this.o[t] = e.getInt16()
              }
              e.position = _;
              var $ = e.getInt32();
              if ($ > 0) {
                  this.f = new Array($);
                  for (let t = 0; t < $; ++t)
                      this.f[t] = new Fn(e)
              }
              e.position = p;
              var tt = e.getInt32();
              if (tt > 0) {
                  this.m = new Array(tt);
                  for (let t = 0; t < tt; ++t)
                      this.m[t] = e.getInt16()
              }
              e.position = m,
              this.s = _i(e.getFloat(), e.getFloat(), e.getFloat()),
              this.I = _i(e.getFloat(), e.getFloat(), e.getFloat()),
              this.P = e.getFloat(),
              this.w = _i(e.getFloat(), e.getFloat(), e.getFloat()),
              this.E = _i(e.getFloat(), e.getFloat(), e.getFloat()),
              this.g = e.getFloat(),
              e.position = v;
              var et = e.getInt32();
              if (et > 0) {
                  this.x = new Array(et);
                  for (let t = 0; t < et; ++t)
                      this.x[t] = e.getUint16()
              }
              e.position = x;
              var it = e.getInt32();
              if (it > 0) {
                  this.L = new Array(it);
                  for (let t = 0; t < it; ++t)
                      this.L[t] = _i(e.getFloat(), e.getFloat(), e.getFloat())
              }
              e.position = T;
              var st = e.getInt32();
              if (st > 0) {
                  this.e = new Array(st);
                  for (let t = 0; t < st; ++t)
                      this.e[t] = _i(e.getFloat(), e.getFloat(), e.getFloat())
              }
              e.position = w;
              var rt = e.getInt32();
              if (rt > 0) {
                  this.u = new Array(rt);
                  for (let t = 0; t < rt; ++t)
                      this.u[t] = e.getInt16()
              }
              e.position = y;
              var nt = e.getInt32();
              if (nt > 0) {
                  this.M = new Array(nt);
                  for (let t = 0; t < nt; ++t)
                      this.M[t] = new Sn(e)
              }
              e.position = A;
              var at = e.getInt32();
              if (at > 0) {
                  this.y = new Array(at);
                  for (let t = 0; t < at; ++t)
                      this.y[t] = e.getInt16()
              }
              e.position = E;
              var ot = e.getInt32();
              if (ot > 0) {
                  this.t = new Array(ot);
                  for (let t = 0; t < ot; ++t)
                      this.t[t] = new Dn(e)
              }
              e.position = C;
              var ht = e.getInt32();
              if (ht > 0) {
                  this.B = new Array(ht);
                  for (let t = 0; t < ht; ++t)
                      this.B[t] = new In(e)
              }
              e.position = M;
              var lt = e.getInt32();
              if (lt > 0) {
                  this.z = new Array(lt);
                  for (let t = 0; t < lt; ++t)
                      this.z[t] = e.getInt16()
              }
              e.position = k;
              var ut = e.getInt32();
              if (ut > 0) {
                  this.l = new Array(ut);
                  for (let t = 0; t < ut; ++t)
                      this.l[t] = new ol(e)
              }
              e.position = F;
              var ct = e.getInt32();
              if (ct > 0) {
                  this.v = new Array(ct);
                  for (let t = 0; t < ct; ++t)
                      this.v[t] = new Un(e)
              }
              e.position = D;
              var dt = e.getInt32();
              if (dt > 0) {
                  this.N = new Array(dt);
                  for (let t = 0; t < dt; ++t)
                      this.N[t] = new Rn(e)
              }
              e.position = I;
              var ft = e.getInt32();
              if (ft > 0) {
                  this.n = new Array(ft);
                  for (let t = 0; t < dt; ++t)
                      this.n[t] = e.getInt16()
              }
              e.position = R;
              var gt = e.getInt32();
              if (gt > 0) {
                  this.k = new Array(gt);
                  for (let t = 0; t < gt; ++t)
                      this.k[t] = new hl(e)
              }
              if (U > 0) {
                  e.position = U;
                  if (e.getUint32()) {
                      const t = e.position
                        , i = e.getInt32()
                        , s = e.getUint32()
                        , r = e.getInt32()
                        , n = e.getUint32()
                        , a = e.getInt32()
                        , o = e.getUint32()
                        , h = e.getInt32()
                        , l = e.getUint32();
                      let u = e.position;
                      e.position = t + s;
                      for (let t = 0; t < i; t++)
                          this.d.push(_i(e.getFloat(), e.getFloat(), e.getFloat()));
                      e.position = t + n;
                      for (let t = 0; t < r; t++)
                          this.c.push(_i(e.getFloat(), e.getFloat(), e.getFloat()));
                      e.position = t + o;
                      for (let t = 0; t < a; t++)
                          this.R.push(e.getUint16());
                      e.position = t + l;
                      for (let t = 0; t < h; t++)
                          this.p.push(e.getUint16());
                      e.position = u
                  }
              }
              if (O > 0) {
                  e.position = O;
                  if (e.getUint32()) {
                      this.G = _i(e.getFloat(), e.getFloat(), e.getFloat()),
                      this.j = [];
                      for (let t = 0; t < 5; t++)
                          this.j.push(e.getInt32())
                  }
              }
              e.position = S;
              var bt = e.getInt32();
              if (bt > 0) {
                  this.A = new Array(bt);
                  for (let t = 0; t < bt; ++t)
                      this.A[t] = new rl(e)
              }
          }
      }
  }
  const ul = class {
      constructor(t) {
          this.d = t,
          this.v = new Float32Array([1, 1, 1, 1]),
          this.e = !1,
          this.a = !0,
          this.s = null,
          this.m = null,
          this.t = 0,
          this.y = null,
          this.E = [],
          this.n = [],
          this.b = new Array,
          this.F = null,
          this.c = [],
          this.w = t.i,
          this.C = t.m,
          this.l = !1,
          this.u = !1,
          this.p = !1,
          this.g = As(),
          this.z = gi(),
          this.i = Sr()
      }
      q(t) {
          this.s = t;
          const e = t.P
            , i = this.d;
          this.m = e.C[this.d.a],
          this.t = this.m.g,
          kn.b(this);
          let s = e.o[i.f];
          1 == i.m && s > -1 && 1 == e.H[s].a && (this.w = -1e3,
          this.C = 3);
          for (let s = 0; s < this.C; s++) {
              if (i.f > -1 && i.f < e.o.length) {
                  let r = e.o[i.f + s];
                  r > -1 && r < e.H.length && this.E.splice(s, 0, t.u[r])
              }
              if (i.b > -1 && i.b < e.m.length) {
                  let t = e.m[i.b + s];
                  t > -1 && e.f && t < e.f.length ? this.n.splice(s, 0, e.f[t]) : this.n.splice(s, 0, null)
              }
              if (i.j > -1 && i.j < e.z.length) {
                  let t = e.z[i.j + s];
                  t > -1 && t < e.B.length ? this.c.splice(s, 0, e.B[t]) : this.c.splice(s, 0, null)
              }
          }
          this.b = new Array(this.n.length);
          for (let t = 0; t < this.b.length; t++)
              this.b[t] = Bi();
          e.t && i.e > -1 && i.e < e.t.length && (this.F = e.t[i.e])
      }
      o() {
          this.s.P;
          let t = Es(this.m.c[0], this.m.c[1], this.m.c[2], 1)
            , e = this.s.K[this.m.h].i
            , i = Bi();
          Hi(i, i, this.s.Q.viewMatrix),
          Hi(i, i, this.s.X),
          Hi(i, i, e),
          Rs(t, t, i),
          t[3] = 0;
          let s = Us(t);
          if ((3 & this.d.c) > 0) {
              let e = As();
              s > 0 ? Ss(e, t, 1 / s) : Cs(e, t),
              Ss(e, e, bi(_i(i[8], i[9], i[10])) * this.m.i),
              1 & this.d.c ? Fs(e, t, e) : ks(e, t, e),
              s = Ds(e)
          }
          return s
      }
      h() {
          this.s,
          this.s.Q.context;
          const t = this.s.ab;
          if (this.g[0] = this.g[1] = this.g[2] = this.g[3] = 1,
          this.F && this.F.e(t, this.s.O, this.g),
          this.c[0] && (this.g[3] *= this.c[0].d(t, this.s.O)),
          this.g[3] *= this.s.R[3],
          !(this.g[3] <= .001)) {
              for (let e = 0; e < this.c.length; e++) {
                  const i = this.c[e];
                  i && (this.v[e] = i.d(t, this.s.O))
              }
              if (!this.e || this.s.T) {
                  const t = this.j();
                  let e = !0;
                  for (const i of t) {
                      const t = i.d;
                      e = e && null != t
                  }
                  if (this.e = e,
                  !e)
                      return;
                  this.r = this.A(!1, !1),
                  this.f = this.A(!0, !1),
                  this.x = this.A(!1, !0)
              }
              if (this.n.forEach(( (e, i) => {
                  if (!this.s.aE && (Gi(this.b[i]),
                  this.n[i])) {
                      let e = !1
                        , s = !1;
                      this.n[i].c && this.n[i].c.d(t.e.e) ? (this.z = this.n[i].c.b(t, this.s.O),
                      s = !0) : mi(this.z, 0, 0, 0),
                      this.n[i].d && this.n[i].d.d(t.e.e) ? (this.i = this.n[i].d.b(t, this.s.O),
                      e = !0) : Gr(this.i, 0, 0, 0, 1);
                      let r, n = !1;
                      if (this.n[i].a && this.n[i].a.d(t.e.e) && (r = this.n[i].a.b(t, this.s.O),
                      n = !0),
                      Gi(this.b[i]),
                      Vi(this.b[i], this.b[i], _i(.5, .5, 0)),
                      n && qi(this.b[i], this.b[i], r),
                      e) {
                          let t = Bi();
                          Zi(t, this.i, [0, 0, 0]),
                          Hi(this.b[i], this.b[i], t)
                      }
                      s && Vi(this.b[i], this.b[i], this.z),
                      Vi(this.b[i], this.b[i], _i(-.5, -.5, 0))
                  }
              }
              )),
              this.e) {
                  (this.g[3] < 1 ? this.f : this.r).c = this.o()
              }
          }
      }
      k(t, e) {
          if (!this.r)
              return;
          const i = this.s.q.i();
          if (e)
              i.e(this.x);
          else {
              const e = this.r.g.b() <= $s.GxBlend_AlphaKey
                , s = null != this.s.gradientEffect
                , r = this.g[3] < 1;
              t && e && (r || s) ? (i.e(this.x),
              i.e(this.f)) : (!t && e || t && !e) && i.e(this.r)
          }
      }
      A(t, e) {
          const i = this
            , s = t && i.y.c < 2 ? $s.GxBlend_Alpha : i.y.c
            , r = [0, 1, 2, 10, 3, 4, 5, 13]
            , n = r[s]
            , a = this.s.q
            , o = this.s
            , h = Object.assign(Object.assign({}, this.s.au), this.s.x);
          for (let t = 0; t < this.n.length; t++)
              h["uTextureMatrix" + (t + 1).toString()] = this.b[t];
          h.uColor = this.g,
          h.uTexSampleAlpha = this.v,
          h.uBlendMode = n,
          h.uHasSpecEmiss = o.as[0] && o.as[1],
          h.uHasEmissiveGlowing = o.f,
          h.uUnlit = this.l ? 1 : 0,
          this.s.gradientEffect && (h.u_mulLum_OpaqMat = [0, 1, 0, 0]);
          let l = !this.s.m;
          const u = a.o(this.s.C, new cn(i.u,l,r[s],!0,!i.p,e ? 0 : 15), new us(this.w,i.j(),h,null != this.s.gradientEffect && s <= 2));
          return a.k(new dn(o.aO,2 * i.m.b,i.m.d), u, this.d.k, this.d.l)
      }
      B() {
          return this.E
      }
      j() {
          const t = []
            , e = this.s;
          return this.E.forEach(( (i, s) => {
              let r = null;
              i && (-1e3 == this.w ? e.as ? (r = e.as[s],
              r || (r = {
                  d: null,
                  l: !1
              })) : r = {
                  d: null,
                  l: !1
              } : r = 0 == i.b.a ? i.e : i.b.a > 0 && this.s.ag[i.b.a] ? this.s.ag[i.b.a] : {
                  d: null,
                  l: !1
              },
              r || (this.E[s].c || (WH.debug("can't find texture for material", s, "type", this.E[s].type, "index", this.E[s].d),
              this.E[s].c = !0),
              r = {
                  d: this.s.Q.greenPixelTexture
              })),
              t[s] = r
          }
          )),
          t
      }
      get show() {
          return this.a
      }
      set show(t) {
          this.a = t
      }
      get meshId() {
          return this.t
      }
      D() {
          this.s = null,
          this.m = null,
          this.y = null,
          this.E = null,
          this.n = null,
          this.F = null,
          this.c = null,
          this.g = null,
          this.b = null,
          this.z = null,
          this.i = null
      }
  }
  ;
  class cl {
      constructor(t, e) {
          this.b = e,
          this.d = t,
          this.e = null,
          this.c = !1
      }
      f() {
          this.e && this.e.b(),
          this.e = null
      }
      a(t) {
          0 != this.b.c && (this.e || (this.e = t.getTexture(this.b.c)))
      }
      get type() {
          return this.b.a
      }
  }
  const dl = function(t, e) {
      const i = Math.abs(t)
        , s = Math.abs(e);
      return Number((i - Math.floor(i / s) * s).toPrecision(8)) * Math.sign(t)
  }
    , fl = "DressingRoom"
    , gl = "Stand";
  class bl {
      constructor() {
          this.d = null,
          this.c = -1,
          this.a = Bi(),
          this.b = 1
      }
  }
  class _l {
      constructor(t, e, i) {
          this.Q = t,
          this.q = e,
          this.ad = i,
          this.D = !1,
          this.O = [],
          this.m = !1,
          this.S = !0,
          this.aQ = !0,
          this.aE = !1,
          this.M = !1,
          this.ab = new Hr,
          this.j = null,
          this.v = 0,
          this.i = null,
          this.aH = null,
          this.ag = {},
          this.as = [],
          this.f = !1,
          this.T = !1,
          this.J = 1,
          this.n = gi(),
          this.z = gi(),
          this.N = null,
          this.aG = null,
          this.aB = new Set,
          this.aO = null,
          this.X = Bi(),
          this.g = Bi(),
          this.al = Bi(),
          this.ac = Bi(),
          this.R = Es(1, 1, 1, 1),
          this.af = null,
          this.x = {},
          this.Y = -1,
          this.aA = !1,
          this.aM = Bi(),
          this.F = gi(),
          this.at = gi(),
          this.aP = As(),
          this.a = As(),
          this.G = !1,
          this.av = !1,
          this.y = null,
          this.aC = [],
          this.ab.f = 0,
          this.ab.e.e = -1,
          this.Z(i)
      }
      p(t) {
          this.aC.push(t)
      }
      Z(t) {
          const e = this.Q.options.contentPath + "mo3/" + t + ".mo3";
          $.ajax({
              url: e,
              type: "GET",
              dataType: "binary",
              responseType: "arraybuffer",
              processData: !1,
              renderer: this.Q,
              success: t => {
                  this.aL(t)
              }
              ,
              error: function(t, e, i) {
                  console.log(i)
              }
          })
      }
      aL(t) {
          this.P = new ll(t),
          this.U()
      }
      aD(t) {
          this.J = t
      }
      U() {
          const t = this.P
            , e = t.H.length
            , i = t.i.length
            , s = t.b.length
            , r = t.v.length
            , n = t.A.length;
          this.O = new Array(s);
          for (let t = 0; t < s; ++t)
              this.O[t] = 0;
          if (i > 0) {
              this.K = new Array(i);
              for (let e = 0; e < i; e++)
                  this.K[e] = new rn(this,e,t.i[e]);
              this.I = new Array(i);
              for (let e = 0; e < i; e++) {
                  this.I[e] = [];
                  for (let s = 0; s < i; s++)
                      t.i[s].f == e && this.I[e].push(s)
              }
          }
          this.u = new Array;
          for (let i = 0; i < e; i++)
              this.u[i] = new cl(i,t.H[i]),
              this.u[i].a(this.Q);
          this.l = new Array(r);
          for (let e = 0; e < r; e++)
              this.l[e] = new xn(this,t.v[e]),
              t.N && t.N.length && e < t.N.length && this.l[e].ai(t.N[e]);
          this.ak = new Array(n);
          for (let e = 0; e < n; e++)
              this.ak[e] = new En(this,t.A[e]);
          if (this.j && this.k(this.j),
          t.a) {
              const e = t.a.length;
              this.ae = new Array(e);
              for (let i = 0; i < e; ++i)
                  this.ae[i] = new ul(t.a[i]),
                  this.ae[i].q(this);
              this.aj = this.ae.concat()
          }
          this.P.r && t.O && (this.N = this.q.f(t.r),
          this.aG = this.q.e(t.O.length),
          this.aO = this.q.a(this.N, this.aG),
          this.aG.b(new Uint16Array(t.O))),
          this.C = this.q.l(t.i.length, t.t.length, t.B.length, t.f.length),
          this.au = {
              uInvTranspViewModelMat: this.ac,
              uModelMatrix: this.X,
              uDiffuseColor: this.R
          },
          this.ah("Stand");
          for (let t of this.aC)
              t();
          if (this.aC = [],
          mi(this.at, this.J, this.J, this.J),
          Gi(this.X),
          this.G && Wi(this.X, this.X, Math.PI / 2),
          this.av) {
              let t = gi();
              Gi(Bi()),
              mi(t, 1, -1, 1),
              qi(this.X, this.X, t)
          }
          qi(this.X, this.X, this.at),
          this.Q.doUpdateBounds = !0,
          this.D = !0
      }
      ax() {
          this.G = !0
      }
      H() {
          this.av = !0
      }
      aq(t) {
          const e = this.P;
          return e && e.Q && t > -1 && t < e.Q.length ? e.Q[t].l : t == e.Q.length ? fl : ""
      }
      B() {
          this.ah(gl)
      }
      get isMirrored() {
          return this.ao
      }
      set isMirrored(t) {
          this.T = this.ao != t,
          this.ao = t
      }
      az(t, e, i, s=1) {
          null != t || null != i ? (this.y || (this.y = new bl),
          this.y.d = t,
          this.y.c = e,
          i ? zi(this.y.a, i) : Gi(this.y.a),
          this.y.b = s,
          this.Q.doUpdateBounds = !0) : this.y = null
      }
      aI() {
          this.Q.context;
          this.P.r && this.P.O && this.Y != this.Q.currFrame && (this.N && this.N.ba(this.K, this.aB),
          this.C.b(this.K),
          this.Y = this.Q.currFrame)
      }
      s(t, e, i) {
          const s = [_i(t[0], t[1], t[2]), _i(t[0], t[1], e[2]), _i(t[0], e[1], t[2]), _i(t[0], e[1], e[2]), _i(e[0], t[1], t[2]), _i(e[0], t[1], e[2]), _i(e[0], e[1], t[2]), _i(e[0], e[1], e[2])].map((t => {
              const e = gi();
              return Ii(e, t, i),
              e
          }
          ))
            , r = _i(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY)
            , n = _i(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
          return s.forEach((t => {
              wi(r, r, t),
              yi(n, n, t)
          }
          )),
          [r, n]
      }
      ai() {
          var t, e, i, s, r, n;
          if (!this.ae)
              return null;
          let a = this.n
            , o = this.z;
          return mi(a, 9999, 9999, 999),
          mi(o, -9999, -9999, -9999),
          wi(a, a, null === (i = null === (e = null === (t = this.ab) || void 0 === t ? void 0 : t.e) || void 0 === e ? void 0 : e.c) || void 0 === i ? void 0 : i.b),
          yi(o, o, null === (n = null === (r = null === (s = this.ab) || void 0 === s ? void 0 : s.e) || void 0 === r ? void 0 : r.c) || void 0 === n ? void 0 : n.c),
          this.s(a, o, this.X)
      }
      A() {
          const t = this.P;
          if (!this.D)
              return;
          if (this.y) {
              mi(this.at, this.J, this.J, this.J);
              const t = this.y.d
                , s = this.y;
              if (!t.D)
                  return;
              Ai(this.at, this.at, s.b),
              e = this.X,
              i = this.at,
              e[0] = i[0],
              e[1] = 0,
              e[2] = 0,
              e[3] = 0,
              e[4] = 0,
              e[5] = i[1],
              e[6] = 0,
              e[7] = 0,
              e[8] = 0,
              e[9] = 0,
              e[10] = i[2],
              e[11] = 0,
              e[12] = 0,
              e[13] = 0,
              e[14] = 0,
              e[15] = 1,
              Hi(this.X, s.a, this.X),
              s.c >= 0 && s.c < t.K.length && Hi(this.X, t.K[s.c].i, this.X),
              Hi(this.X, t.X, this.X)
          }
          var e, i;
          Hi(this.g, this.Q.viewMatrix, this.X),
          Li(this.al, this.g),
          ji(this.ac, this.al),
          this.gradientEffect && this.o();
          let s = 1e3 * this.Q.delta;
          if (!this.aE && this.ab.e.e > -1) {
              let e = s;
              for (let i = 0; i < this.O.length; i++)
                  this.O[i] += e,
                  t.b[i] > 0 && (this.O[i] %= t.b[i]);
              this.aK(this.ab, e)
          }
          let r = this.ae ? this.ae.length : 0;
          this.aB.clear();
          for (let t = 0; t < r; ++t) {
              let e = this.ae[t];
              if (!e.show)
                  continue;
              let i = e.m.d
                , s = e.m.b;
              for (let t = 0; t < i; ++t)
                  this.aB.add(this.P.O[s + t])
          }
          let n = t.i.length;
          if (this.K) {
              for (let t = 0; t < n; ++t)
                  this.K[t].k = !1;
              for (let t = 0; t < n; ++t)
                  this.K[t].t(s);
              this.aI()
          }
          if (this.ae && this.ae.forEach((t => t.h())),
          this.aj && this.aj.sort((function(t, e) {
              return t.d.l != e.d.l ? t.d.l - e.d.l : t.meshId - e.meshId
          }
          )),
          this.T = !1,
          this.l && this.S)
              for (let t = 0; t < this.l.length; ++t)
                  this.l[t].U(this.ab, this.Q.delta);
          if (this.ak && this.aQ)
              for (let t = 0; t < this.ak.length; ++t)
                  this.ak[t].ac(this.ab, this.Q.delta),
                  this.ak[t].j()
      }
      L(t, e) {
          this.ag[t] = e,
          this.T = !0
      }
      d(t, e, i) {
          this.as = [t, e, i],
          this.T = !0
      }
      r(t) {
          this.f = t
      }
      h(t) {
          this.M = !!t
      }
      ar(t) {
          this.S = !!t
      }
      w(t) {
          this.aQ = !!t
      }
      c(t, e) {
          const i = this;
          if (!i.D)
              return;
          let s = 100 * e
            , r = s + rr[e] + t
            , n = i.ae.some((t => t.meshId == r));
          r = n ? r : 100 * e + 1,
          i.t(s, s + 99, !1),
          i.t(r, r, !0)
      }
      t(t, e, i) {
          const s = this.P;
          if (!this.ae || 0 == this.ae.length)
              return !1;
          for (let s = 0; s < this.ae.length; ++s) {
              const r = this.ae[s];
              r.meshId >= t && r.meshId <= e && (r.show = i)
          }
          if (s.n && s.n.length > 0)
              for (let r = 0; r < s.n.length; ++r) {
                  let n = s.n[r];
                  n >= t && n <= e && (this.l[r].am = i)
              }
          return !0
      }
      aJ(t, e) {
          if (!this.ae)
              return;
          const i = e + 1;
          let s = t > 0 ? e + t : -2 == t ? e + 0 : i
            , r = this.ae.some((t => t.meshId == s));
          s = r || -2 == t ? s : i,
          this.t(s, s, !0)
      }
      aN(t) {
          this.aE = t
      }
      W(t) {
          this.P.Q && (this.V(t, this.ab),
          this.ab.a = !1,
          this.ab.e.a = !1,
          this.ab.e.b = 0)
      }
      aK(t, e) {
          const i = this.P;
          if (t.e.b += e,
          t.d.e < 0 && !this.M && !t.a)
              if (t.e.c.e > -1) {
                  let e = 32767 * Math.random()
                    , s = 0
                    , r = t.e.e
                    , n = i.Q[r];
                  for (s += n.a; s < e && n.e > -1; )
                      r = n.e,
                      n = i.Q[r],
                      s += n.a;
                  t.d.e = r,
                  t.d.c = i.Q[r],
                  t.d.b = 0
              } else {
                  let e = i.Q.find((e => e.h == t.e.c.h && 0 == e.i));
                  e && (t.d.e = e.f,
                  t.d.c = e,
                  t.d.b = 0)
              }
          let s = t.e
            , r = t.d
            , n = s.c.m - s.b
            , a = 0
            , o = null;
          if (r.e > -1 && (o = i.Q[r.e],
          a = o.g),
          a > 0 && n < a ? (r.b = dl(a - n, o.m),
          t.f = n / a) : t.f = 1,
          t.b > 0) {
              let i = e / 1e3;
              t.c.b += e,
              t.b -= i / this.Q.crossFadeDuration
          }
          if (s.b >= s.c.m)
              if (r.e > -1 && !s.a) {
                  if (r.e > -1)
                      for (; !(32 & i.Q[r.e].j) && (64 & i.Q[r.e].j) > 0 && (r.e = i.Q[r.e].f,
                      r.c = i.Q[r.e],
                      !(r.e < 0)); )
                          ;
                  t.e = r,
                  t.d = new Lr,
                  t.f = 1
              } else
                  s.c.m > 0 && (s.b = dl(s.b, s.c.m))
      }
      ah(t, e=!0) {
          this.V(t, this.ab, e)
      }
      V(t, e, i=!0) {
          const s = this.P;
          let r = !1
            , n = !1;
          const a = t == fl;
          a && (t = gl,
          this.h(!0));
          for (let o = 0; o < s.Q.length; ++o) {
              const h = s.Q[o];
              if (h.l && (h.l == t && 0 == h.i)) {
                  r = !0,
                  i && null != e.e && (null != e.c && (e.b = 1),
                  e.c = new Lr,
                  e.c.e = e.e.e,
                  e.c.c = e.e.c,
                  e.c.b = e.e.b),
                  n = e.e.e != o,
                  e.e.e = o,
                  e.e.c = h,
                  e.e.b = 0,
                  e.d = new Lr,
                  e.f = 0,
                  e.a = a,
                  WH.debug("Set animation to", h.h, h.l);
                  break
              }
          }
          return t == gl || r ? n : this.V(gl, e)
      }
      E(t) {
          this.aA = t
      }
      aw(t) {
          const e = this.P;
          let i = null;
          if (!e.y || !e.y.length)
              return null;
          if (t < e.y.length)
              i = e.M[e.y[t]];
          else
              for (let t = 0; t < e.y.length; t++) {
                  const s = e.y[t];
                  if (-1 != s) {
                      i = e.M[s];
                      break
                  }
              }
          return i
      }
      get gradientEffect() {
          return this.af
      }
      set gradientEffect(t) {
          this.T = !0,
          this.af = t,
          this.an()
      }
      am(t) {
          if (this.y) {
              const t = this.y.d;
              if (t && !t.D)
                  return
          }
          if (this.N && this.aj)
              if (this.gradientEffect) {
                  if (t)
                      for (let t = 0; t < this.aj.length; ++t)
                          this.aj[t].show && this.aj[t].k(!1, !0);
                  for (let e = 0; e < this.aj.length; ++e)
                      this.aj[e].show && this.aj[e].k(t, !1)
              } else
                  for (let e = 0; e < this.aj.length; ++e)
                      this.aj[e].show && this.aj[e].k(t, !1);
          if (this.l && this.S)
              for (let e = 0; e < this.l.length; ++e)
                  this.l[e].x(t);
          if (this.ak && this.aQ)
              for (let e = 0; e < this.ak.length; ++e)
                  this.ak[e].V(t)
      }
      aa(t) {
          if (this.v == t)
              return;
          if (this.D)
              for (let t = 0; t < this.K.length; t++)
                  this.K[t].A = null;
          if (this.v = t,
          t <= 0)
              return;
          let e = this.Q.options.contentPath + "bone/" + t + ".bone"
            , i = this;
          $.ajax({
              url: e,
              type: "GET",
              dataType: "binary",
              responseType: "arraybuffer",
              processData: !1,
              renderer: this.Q,
              success: function(t) {
                  i.ap(t)
              },
              error: function(t, e, i) {
                  console.log(i)
              }
          })
      }
      ap(t) {
          let e = new Pn(t);
          e.getInt32();
          for (; e.position < e.buffer.byteLength; ) {
              let t = String.fromCharCode(e.getUint8(), e.getUint8(), e.getUint8(), e.getUint8())
                , i = e.getUint32();
              if ("BIDA" == t) {
                  let t = i / 2;
                  this.i = new Array(t);
                  for (let i = 0; i < t; i++)
                      this.i[i] = e.getUint16()
              }
              if ("BOMT" == t) {
                  let t = i / 64;
                  this.aH = new Array(t);
                  for (let i = 0; i < t; i++) {
                      let t = Ni(e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat(), e.getFloat());
                      this.aH[i] = t
                  }
              }
          }
          this.D && this.ay()
      }
      ay() {
          if (!(this.v <= 0) && this.i && this.i.length)
              for (let t = 0; t < this.i.length; t++)
                  this.K[this.i[t]].A = this.aH[t]
      }
      an() {
          if (!this.gradientEffect)
              return;
          const t = this.gradientEffect
            , e = this.x;
          e.u_gradGradientColors_0 = [...t.Colors0, 0],
          e.u_gradGradientColors_1 = [...t.Colors1, 0],
          e.u_gradGradientColors_2 = [...t.Colors2, t.Alpha[0]],
          e.u_gradEdgeColor = [...t.EdgeColor, t.Alpha[1]],
          e.u_gradBoundingBox = [this.aP[0], this.aP[1], this.aP[2], 1 / (this.z[2] - this.n[2])],
          e.u_gradUpVec = [this.at[0], this.at[1], this.at[2], 0],
          e.u_gradFlags = [(1 & t.gradFlags) > 0 ? 1 : 0, .7, (4 & t.gradFlags) > 0 ? 1 : 0, (8 & t.gradFlags) > 0 ? 1 : 0]
      }
      o() {
          if (!this.gradientEffect)
              return;
          this.gradientEffect;
          const t = this.x;
          Ms(this.aP, this.n[2], this.n[2], this.n[2], 1),
          Rs(this.aP, this.aP, this.g),
          Ms(this.a, 0, 0, 1, 0),
          Rs(this.a, this.a, this.ac),
          mi(this.at, this.a[0], this.a[1], this.a[2]),
          ki(this.at, this.at),
          t.u_gradBoundingBox[0] = this.aP[0],
          t.u_gradBoundingBox[1] = this.aP[1],
          t.u_gradBoundingBox[2] = this.aP[2],
          t.u_gradBoundingBox[3] = 1 / (this.z[2] - this.n[2]),
          t.u_gradUpVec[0] = this.at[0],
          t.u_gradUpVec[1] = this.at[1],
          t.u_gradUpVec[2] = this.at[2]
      }
      e(t) {
          let e = Mr();
          if (kr(e, t),
          this.l)
              for (let i = 0; i < this.l.length; i++)
                  this.l[i].J(t, e);
          if (this.ak)
              for (let e = 0; e < this.ak.length; e++)
                  this.ak[e].ae(t)
      }
      aF() {
          return this.y
      }
      k(t) {
          if (this.l)
              for (let e = 0; e < this.l.length; e++)
                  this.l[e].c(t);
          this.j = t
      }
  }
  class pl {
      static c(t, e, i) {
          const s = fr[e];
          if (s) {
              const e = i ? 4 : 0;
              return s.slice(2 * t + e, 2 * t + e + 2)
          }
      }
      static b(t, e, i, s) {
          let r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          if (!t)
              return WH.debug("selectBestTexture:", "textures are null"),
              null;
          for (let n = 0; n < t.length; n++) {
              let a = t[n]
                , o = a.Gender
                , h = a.Class
                , l = a.Race
                , u = a.ExtraData
                , c = 0;
              if (e > 1 || o != e) {
                  if (o < 2)
                      continue;
                  c = 0
              } else
                  c = 2;
              let d = 1;
              if (i > 0 && h == i)
                  d = 0;
              else if (h > 0)
                  continue;
              let f = 1;
              if (s > 0 && l == s)
                  f = 0;
              else if (l > 0)
                  continue;
              r[u + 3 * (f + 2 * (c + d))] = a.FileDataId
          }
          for (let t = 0; t < 2; t++)
              for (let e = 0; e < 2; e++)
                  for (let i = 0; i < 2; i++) {
                      let s = 3 * (t + 2 * (e + 2 * i));
                      if (r[s] > 0) {
                          let t;
                          return t = {
                              c: r[s],
                              b: r[s + 1],
                              a: r[s + 2]
                          },
                          t
                      }
                  }
          const n = pl.c(e, s, !0);
          return n && 0 != n[0] ? (s = n[0],
          e = n[1],
          pl.b(t, e, i, s)) : null
      }
      static a(t, e, i, s, r) {
          let n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (let a = 0; a < t.length; a++) {
              let o = t[a]
                , h = o.Gender
                , l = o.Class
                , u = o.Race
                , c = o.ExtraData
                , d = 0;
              if (i > 1 || h != i) {
                  if (h < 2)
                      continue;
                  d = 0
              } else
                  d = 2;
              let f = 1;
              if (s > 0 && l == s)
                  f = 0;
              else if (l > 0)
                  continue;
              let g = 1;
              if (r > 0 && u == r)
                  g = 0;
              else if (u > 0)
                  continue;
              let b = 1;
              if (-1 == e || c != e) {
                  if (-1 != c && -1 != e)
                      continue
              } else
                  b = 0;
              n[b + 2 * (g + 2 * (d + f))] = o.FileDataId
          }
          for (let t = 0; t < 2; t++)
              for (let e = 0; e < 2; e++)
                  for (let i = 0; i < 2; i++)
                      for (let s = 0; s < 2; s++) {
                          let r = s + 2 * (t + 2 * (e + 2 * i));
                          if (n[r])
                              return n[r]
                      }
          const a = pl.c(i, r, !1);
          return a && 0 != a[0] ? (r = a[0],
          i = a[1],
          pl.a(t, e, i, s, r)) : 0
      }
  }
  class ml {
      constructor() {
          this.f = !1,
          this.c = []
      }
      get loaded() {
          let t = !!this.h && this.h.D;
          if (t && this.c.length > 0) {
              for (let t of this.c)
                  t();
              this.c = []
          }
          return t
      }
      isLoaded() {
          return this.loaded
      }
      d(t) {
          this.c.push(t)
      }
      e() {
          return this.h
      }
      b(t) {
          t.a(this.h, this.f)
      }
      getNumAnimations() {
          var t;
          return (null === (t = this.h) || void 0 === t ? void 0 : t.D) ? 0 == this.h.P.Q.length ? 0 : this.h.P.Q.length + 1 : 0
      }
      getAnimation(t) {
          var e;
          return (null === (e = this.h) || void 0 === e ? void 0 : e.D) ? this.h.aq(t) : ""
      }
      resetAnimation() {
          var t;
          if (null === (t = this.h) || void 0 === t ? void 0 : t.D)
              return this.h.B()
      }
      setAnimPaused(t) {
          var e;
          if (null === (e = this.h) || void 0 === e ? void 0 : e.D)
              return this.h.aN(t)
      }
      setTPose(t) {
          var e;
          if (null === (e = this.h) || void 0 === e ? void 0 : e.D)
              return this.h.E(t)
      }
      setAnimation(t, e) {
          var i;
          (null === (i = this.h) || void 0 === i ? void 0 : i.D) && this.h.ah(t, !!e)
      }
      setParticlesEnabled(t) {
          var e;
          (null === (e = this.h) || void 0 === e ? void 0 : e.D) && this.h.ar(t)
      }
      setRibbonsEnabled(t) {
          var e;
          (null === (e = this.h) || void 0 === e ? void 0 : e.D) && this.h.w(t)
      }
      getTexUnits() {
          var t;
          return (null === (t = this.h) || void 0 === t ? void 0 : t.D) ? this.h.ae : null
      }
      setAnimNoSubAnim(t) {
          this.h && this.h.h(t)
      }
      attachList(t) {}
      setItems(t) {}
      clearSlots(t) {}
      setSheath(t, e) {}
      setAppearance(t) {}
      setShouldersOverride(t) {}
      setCustomizationsLoadedCallback(t) {}
      setModelLoadedCallback(t) {
          throw new Error("Method not implemented.")
      }
      setAnimationOverride(t, e) {
          throw new Error("Method not implemented.")
      }
      resetAnimationOverride(t) {
          throw new Error("Method not implemented.")
      }
      getAnimationDuration(t) {
          throw new Error("Method not implemented.")
      }
      getModelBounds() {
          throw new Error("Method not implemented.")
      }
      isRenderReady() {
          throw new Error("Method not implemented.")
      }
  }
  class vl extends ml {
      constructor(t, e, i, s, r, n) {
          super(),
          this.fe = t,
          this.i = e,
          this.hg = i,
          this.m = s,
          this.dc = r,
          this.f = n
      }
      get fileDataId() {
          return this.h ? this.h.ad : 0
      }
      get modelInstance() {
          return this.h
      }
      j() {
          256 & this.i.Item.Flags && (this.winding = !0,
          this.isMirrored = !0,
          this.h.H())
      }
      ba(t, e, i) {
          this.h && this.h.az(t, e, i)
      }
      k(t, e) {
          this.h && this.h.c(t, e)
      }
      l(t, e, i) {
          this.h && this.h.t(t, e, i)
      }
      setParticlesEnabled(t) {
          this.h && this.h.ar(t)
      }
      get winding() {
          return !!this.h && this.h.m
      }
      set winding(t) {
          this.h && (this.h.m = t)
      }
      get isMirrored() {
          return !!this.h && this.h.isMirrored
      }
      set isMirrored(t) {
          this.h && (this.h.isMirrored = t)
      }
      getBounds() {
          return this.modelInstance.D ? this.modelInstance.ai() : [null, null]
      }
      a() {
          this.h && this.h.A()
      }
      g(t) {
          this.h && this.h.am(t)
      }
  }
  class xl extends vl {
      constructor(t, e, i, s) {
          if (super(t, null, 0, 0, 0, s),
          this.h = new _l(t,t.renderer,e),
          i)
              for (let e in i)
                  0 != i[e] && this.h.L(+e, t.getTexture(i[e]))
      }
  }
  class Tl {
      constructor() {
          this.a = !1
      }
  }
  const wl = class {
      constructor(t, e) {
          this.c = t,
          this.j = [],
          this.e = !1,
          this.g = !1,
          this.i = e
      }
      h(t) {
          for (let e = 0; e < this.i.length; e++)
              this.j[e] && this.j[e].c && this.j[e].c.loaded && this.j[e].c.e().ah(t)
      }
      b(t) {
          this.e = t
      }
      f() {
          if (this.c.loaded)
              for (let t = 0; t < this.i.length; t++)
                  switch (this.i[t].EffectType) {
                  case 1:
                      this.l(t);
                      break;
                  case 2:
                      this.m(t);
                      break;
                  case 6:
                  case 7:
                  case 11:
                  case 12:
                  case 13:
                      break;
                  case 16:
                      this.k(t)
                  }
      }
      l(t) {
          let e = this.c.e();
          if (1 == this.i[t].ProcEffectType) {
              let i = this.i[t].Value[0];
              e.R = Es((i >> 16 & 255) / 255, (i >> 8 & 255) / 255, (255 & i) / 255, e.R[3])
          } else if (14 == this.i[t].ProcEffectType) {
              let i = Math.min(Math.max(this.i[t].Value[0], 0), 1);
              e.R[3] = i
          } else if (22 == this.i[t].ProcEffectType) {
              let i = this.i[t].Value[3];
              e.R = Es((i >> 16 & 255) / 255, (i >> 8 & 255) / 255, (255 & i) / 255, e.R[3])
          }
      }
      m(t) {
          if (!this.c)
              return;
          if (!this.c.loaded)
              return;
          let e = this.c.e();
          if (!this.j[t]) {
              const i = new Tl;
              if (this.j[t] = i,
              0 == this.i[t].ModelType) {
                  const s = new xl(e.Q,this.i[t].Model,{
                      2: this.i[t].Texture
                  },!1);
                  i.c = s
              } else
                  1 == this.i[t].ModelType || 2 == this.i[t].ModelType && jl.a(e.Q, ar.NPC, this.i[t].Model).then((t => {
                      i.c = t
                  }
                  ))
          }
          const i = this.j[t];
          if (!i.a) {
              if (!i.c && !i.b)
                  return;
              if (i.c && !i.c.loaded)
                  return;
              if (i.b && !i.b.J)
                  return;
              let _ = this.i[t].AttachmentID;
              this.i[t].Positioner > -1 && (_ = this.i[t].Positioner),
              _ < 0 && (_ = 19);
              let p = e.aw(_);
              const m = p ? p.d : -1;
              let v = Bi();
              if (p) {
                  let t = p.a;
                  Vi(v, v, _i(t[0], t[1], t[2]))
              }
              if (Vi(v, v, _i(this.i[t].Offset[0], -this.i[t].Offset[1], this.i[t].Offset[2])),
              Wi(v, v, -this.i[t].Yaw),
              s = v,
              r = v,
              n = this.i[t].Pitch,
              a = Math.sin(n),
              o = Math.cos(n),
              h = r[0],
              l = r[1],
              u = r[2],
              c = r[3],
              d = r[8],
              f = r[9],
              g = r[10],
              b = r[11],
              r !== s && (s[4] = r[4],
              s[5] = r[5],
              s[6] = r[6],
              s[7] = r[7],
              s[12] = r[12],
              s[13] = r[13],
              s[14] = r[14],
              s[15] = r[15]),
              s[0] = h * o - d * a,
              s[1] = l * o - f * a,
              s[2] = u * o - g * a,
              s[3] = c * o - b * a,
              s[8] = h * a + d * o,
              s[9] = l * a + f * o,
              s[10] = u * a + g * o,
              s[11] = c * a + b * o,
              Xi(v, v, this.i[t].Roll),
              qi(v, v, [this.i[t].Scale1, this.i[t].Scale1, this.i[t].Scale1]),
              qi(v, v, [this.i[t].Scale2, this.i[t].Scale2, this.i[t].Scale2]),
              i.c) {
                  const e = i.c.e();
                  e.aN(this.e),
                  this.i[t].ModelAlpha && (e.R[3] = this.i[t].ModelAlpha),
                  e.az(this.c.e(), m, v)
              }
              this.j[t].a = !0
          }
          var s, r, n, a, o, h, l, u, c, d, f, g, b;
          this.j[t].c && this.j[t].c.a(),
          this.j[t].b && this.j[t].b.m()
      }
      k(t) {
          const e = this.c.e();
          e.gradientEffect || (e.gradientEffect = this.i[t])
      }
      a(t) {
          for (const e of this.j)
              e && e.a && (e.c && e.c.g(t),
              e.b && e.b.o(t))
      }
      n() {
          for (const t of this.j)
              t && (t.a = !1,
              t.c && t.c.loaded && t.c.e().az(null, -1, null),
              t.b && t.b && t.b.c())
      }
      d(t) {
          this.j.forEach((e => {
              e.c && e.c.b(t),
              e.b && e.b.i(t)
          }
          ))
      }
  }
  ;
  class yl extends ml {
      constructor(t, e) {
          super(),
          this.w = t,
          this.o = e,
          this.u = !1,
          this.r = !1,
          this.s = !1,
          this.x = -1,
          this.C = -1,
          this.B = [],
          this.q = {},
          this.k = [],
          this.j = !1,
          this.y = null,
          this.t = 0,
          this.hg(e)
      }
      hg(t) {
          if (this.j)
              return;
          this.w.options;
          if (t.StateKit && this.k.push(new wl(this,t.StateKit.effects)),
          t.Creature && (this.y = t.Creature.CreatureGeosetData,
          this.t = t.Creature.CreatureGeosetDataID),
          t.Model && (this.h = new _l(this.w,this.w.renderer,t.Model),
          this.h.ax(),
          t.Creature && t.Creature.ParticleColor && this.h.k(t.Creature.ParticleColor),
          t.Scale && this.h.aD(t.Scale)),
          this.o.Creature && this.o.Creature.Texture && (this.z = this.ba(-1, pl.b(this.o.TextureFiles[this.o.Creature.Texture], 3, 0, 0)),
          this.h.d(this.z.b, this.z.e, this.z.d)),
          t.Textures)
              for (let e in t.Textures)
                  0 != t.Textures[e] && this.h.L(+e, this.w.getTexture(t.Textures[e]));
          this.s = !0,
          this.v()
      }
      ba(t, e) {
          let i = new mr;
          return e.c > 0 && (i.b = this.w.getTexture(e.c)),
          e.b > 0 && (i.e = this.w.getTexture(e.b)),
          e.a > 0 && (i.d = this.w.getTexture(e.a)),
          i
      }
      v() {
          this.j || (this.s = !0,
          this.z || (this.r = !0))
      }
      fe(t) {
          this.n = null,
          t <= 0 || (this.u = !1,
          jl.a(this.w, ar.NPC, t).then((t => {
              t instanceof yl && (this.n = t)
          }
          )))
      }
      l() {
          this.h,
          this.n
      }
      setAnimation(t, e=!0) {
          this.n && (this.n.setAnimation(t),
          t = "Mount"),
          this.h ? this.h.ah(t, e) : this.d(( () => {
              var i;
              null === (i = this.h) || void 0 === i || i.ah(t, e)
          }
          ))
      }
      i() {
          const t = this.h;
          if (t.t(0, 0, !0),
          0 != this.t && (t.t(1, 1699, !1),
          this.y))
              for (let e of this.y) {
                  let i = 100 * (e.GeosetIndex + 1)
                    , s = i + e.GeosetValue;
                  t.t(i, i + 99, !1),
                  t.t(s, s, !0)
              }
      }
      m() {
          this.i()
      }
      A() {
          const t = this.h;
          t.D && this.s && t.ae && 0 != t.ae.length && (this.m(),
          this.s = !1)
      }
      setParticlesEnabled(t) {
          this.h && this.h.ar(t)
      }
      getBounds() {
          if (this.h && this.h.D) {
              const [t,e] = this.h.ai();
              if (this.n && this.n.loaded && this.u) {
                  const [i,s] = this.n.getBounds();
                  yi(i, i, _i(0, 0, 0)),
                  wi(t, t, i),
                  yi(e, e, s)
              }
              return [t, e]
          }
          return [null, null]
      }
      a() {
          if (!this.j && this.loaded) {
              if (!this.u && this.h && this.n && this.n.loaded) {
                  const t = this.n.h.P
                    , e = t.M[t.y[0]]
                    , i = Bi();
                  Vi(i, i, e.a),
                  this.h.az(this.n.h, e.d, i, 1 / this.n.h.J),
                  this.h.ah("Mount", !1),
                  this.u = !0
              }
              this.dc && this.dc.a(),
              this.n && this.n.a(),
              this.k && this.k.forEach((t => t.f())),
              this.A(),
              this.h.A()
          }
      }
      g(t) {
          this.h.am(t),
          this.n && this.n.g(t),
          this.k && this.k.forEach((e => e.a(t)))
      }
      b(t) {
          super.b(t),
          this.n && this.n.b(t),
          this.dc && this.dc.b(t),
          this.k && this.k.forEach((e => e.d(t)))
      }
  }
  function Al(t) {
      return new Promise(( (e, i) => {
          $.getJSON(t).done((function(t) {
              e(t)
          }
          )).fail((function(t, e, s) {
              let r = e + ", " + s;
              console.log("Error loading metadata: " + r),
              i(e)
          }
          ))
      }
      ))
  }
  function El(t, e, i) {
      let s;
      return e == ar.HELM ? Cl(t, 1, i) : e == ar.SHOULDER ? Cl(t, 3, i) : e == ar.ITEM ? Cl(t, -1, i) : (e == ar.NPC || e == ar.HUMANOIDNPC ? s = "meta/npc/" : e == ar.OBJECT ? s = "meta/object/" : e == ar.CHARACTER ? s = "meta/character/" : e == ar.ITEMVISUAL && (s = "meta/itemvisual/"),
      Al(t + s + i + ".json"))
  }
  function Cl(t, e, i) {
      let s = "meta/item/";
      return 1 != e && 3 != e && 4 != e && 5 != e && 6 != e && 7 != e && 8 != e && 9 != e && 10 != e && 16 != e && 19 != e && 20 != e || (s = "meta/armor/" + e + "/"),
      Al(t + s + i + ".json")
  }
  class Ml {
      constructor() {
          this.b = null,
          this.e = 1,
          this.a = 0,
          this.d = -1,
          this.c = !1
      }
  }
  class kl {
      constructor(t, e) {
          this.b = t,
          this.a = e
      }
  }
  class Fl extends Ml {
      constructor() {
          super(...arguments),
          this.ba = []
      }
  }
  class Sl {
      constructor(t, e) {
          this.a = t,
          this.b = e
      }
  }
  function Dl(t, e) {
      return t == e || !!t && (!!e && (t.b == e.b && (t.a == e.a || !!t.a && (!!e.a && (t.a.c == e.a.c && (t.a.a == e.a.a && t.a.b == e.a.b))))))
  }
  class Il {
      constructor(t, e) {
          this.i = t,
          this.h = [],
          this.e = e,
          this.a = {},
          this.g = {}
      }
      f() {
          const t = [];
          for (let e of this.e.Options)
              for (let i of e.Choices)
                  for (let e of i.Elements)
                      e.SkinnedModel && t.push(e.SkinnedModel.CollectionFileDataID);
          const e = new Set(t)
            , i = this.i.w;
          i.renderer;
          if (0 != e.size)
              for (let t of e) {
                  const e = new Fl;
                  e.b = new xl(i,t,{},!0),
                  this.i.kj[t] = e
              }
      }
      j(t) {
          return pl.b(this.e.TextureFiles[t], this.i.J, this.i.M, this.i.K)
      }
      b(t) {
          WH.debug("applyCustomization options", t),
          this.h = [],
          this.i.B = [];
          for (const t in this.i.kj) {
              this.i.kj[t].ba = []
          }
          let e = 0
            , i = {}
            , s = {};
          for (let r = 0; r < t.length; r++) {
              let n = this.e.Options.find((e => e.Id == t[r].optionId));
              if (WH.debug("option", n),
              n) {
                  let a = n.Choices.find((e => e.Id == t[r].choiceId));
                  if (WH.debug("choice", a),
                  a) {
                      let r = a.Elements.filter((e => e.BoneSet && e.BoneSet.BoneFileDataID && (0 == e.VariationChoiceID || t.some((t => t.choiceId == e.VariationChoiceID)))));
                      r.length > 0 && (e = r[0].BoneSet.BoneFileDataID);
                      let o = a.Elements.filter((e => e.Material && (0 == e.VariationChoiceID || t.some((t => t.choiceId == e.VariationChoiceID)))));
                      o.sort(( (t, e) => e.VariationChoiceID - t.VariationChoiceID)),
                      o.forEach((t => {
                          WH.debug("element material", t);
                          let e = this.j(t.Material.MaterialResourcesID);
                          if (!e)
                              return void WH.debug("element material: can't get texture files for material", t);
                          let r = this.e.TextureLayers.find((e => e.ChrModelTextureTargetID == t.Material.TextureTarget));
                          if (!r)
                              return void WH.debug("element material: can't get texture layer for material", t);
                          const n = new Sl(e,r.TextureType);
                          Dl(n, this.g[t.Material.TextureTarget]) ? (i[t.Material.TextureTarget] = this.a[t.Material.TextureTarget],
                          s[t.Material.TextureTarget] = this.g[t.Material.TextureTarget]) : (i[t.Material.TextureTarget] = this.i.ba(r.TextureType, e),
                          s[t.Material.TextureTarget] = n)
                      }
                      )),
                      a.Elements.filter((e => e.Geoset && (0 == e.VariationChoiceID || t.some((t => t.choiceId == e.VariationChoiceID))))).sort(( (t, e) => t.Geoset.GeosetType - e.Geoset.GeosetType || t.Geoset.GeosetID - e.Geoset.GeosetID)).forEach((t => {
                          WH.debug("element geoset", t),
                          this.h.push(100 * t.Geoset.GeosetType + t.Geoset.GeosetID)
                      }
                      )),
                      a.Elements.filter((e => e.SkinnedModel && (0 == e.VariationChoiceID || t.some((t => t.choiceId == e.VariationChoiceID))))).forEach((t => {
                          WH.debug("element skinnedmodel", t),
                          t.ChrCustItemGeoModifyID;
                          const e = this.i.kj[t.SkinnedModel.CollectionFileDataID];
                          t.SkinnedModel.GeosetID < 100 && e.ba.push(new kl(100 * t.SkinnedModel.GeosetType + t.SkinnedModel.GeosetID,(1 & t.SkinnedModel.Flags) > 0))
                      }
                      ));
                      let h = a.Elements.find((e => 0 != e.CondModelFileDataId && (0 == e.VariationChoiceID || t.some((t => t.choiceId == e.VariationChoiceID)))));
                      24 != n.Id && 353 != n.Id || (h && !this.i.overrideModelFile ? this.i.overrideModelFile = h.CondModelFileDataId : !h && this.i.overrideModelFile && (this.i.overrideModelFile = 0)),
                      a.Elements.filter((e => e.ChrCustItemGeoModifyID && (0 == e.VariationChoiceID || t.some((t => t.choiceId == e.VariationChoiceID))))).forEach((t => {
                          WH.debug("element ChrCustItemGeoModify", t),
                          this.i && this.i.B.push(t.ChrCustItemGeoModifyID)
                      }
                      ))
                  }
              }
          }
          if (!this.a[10]) {
              let e = this.e.Options.find((t => t.Id == this.e.HairStyleOptionId));
              if (e) {
                  let r = e.Choices[1];
                  if (r) {
                      let e = r.Elements.filter((e => e.Material && 10 == e.Material.TextureTarget && (0 == e.VariationChoiceID || t.some((t => t.choiceId == e.VariationChoiceID)))));
                      if (e.length > 0) {
                          let t = this.j(e[0].Material.MaterialResourcesID);
                          if (t) {
                              const r = new Sl(t,0);
                              Dl(r, this.g[e[0].Material.TextureTarget]) ? (i[e[0].Material.TextureTarget] = this.a[e[0].Material.TextureTarget],
                              s[e[0].Material.TextureTarget] = this.g[e[0].Material.TextureTarget]) : (i[e[0].Material.TextureTarget] = this.i.ba(6, t),
                              s[e[0].Material.TextureTarget] = r)
                          }
                      }
                  }
              }
          }
          this.a = i,
          this.g = s,
          this.i.e().aa(e),
          this.i.r = !0
      }
      c() {
          let t = [];
          for (let e = 0; e < this.e.Options.length; e++) {
              let i = this.e.Options[e];
              if (i) {
                  let e = i.Choices[0];
                  e && t.push({
                      optionId: i.Id,
                      choiceId: e.Id
                  })
              }
          }
          this.b(t)
      }
      d(t) {
          let e = {
              options: t,
              sheathMain: -1,
              sheathOff: -1
          };
          for (let t of this.e.Options)
              e.options.some((e => e.optionId == t.Id)) || e.options.push({
                  optionId: t.Id,
                  choiceId: t.Choices[0].Id
              });
          return e
      }
  }
  class Rl {
      constructor() {
          this.a = null,
          this.c = 1,
          this.b = !1
      }
  }
  const Ul = class {
      constructor(t, e, i) {
          this.j = t,
          this.h = e,
          this.m = [],
          this.k = !1,
          this.f = [],
          i && this.e(i)
      }
      d() {}
      e(t) {
          this.i = t;
          El(this.j.fe.options.contentPath, ar.ITEMVISUAL, t).then((t => {
              this.c(t)
          }
          ))
      }
      c(t) {
          if (this.m = new Array(7),
          t.ItemEffects)
              for (let e = 0; e < t.ItemEffects.length; ++e) {
                  let i = t.ItemEffects[e];
                  if (-1 == i.SubClass || this.h == i.SubClass) {
                      if (i.Model) {
                          const t = new Rl;
                          this.m[i.Slot - 1] = t,
                          t.a = new _l(this.j.fe,this.j.fe.renderer,i.Model),
                          t.c = i.Scale && 1 != i.Scale ? i.Scale : 1
                      }
                      if (i.kit) {
                          const t = new wl(this.j,i.kit.effects);
                          this.f.push(t)
                      }
                  }
              }
          for (var e = 0; e < this.m.length; ++e)
              t.Equipment[e] && null == this.m[e] && (this.m[e] = new Rl,
              this.m[e].a = new _l(this.j.fe,this.j.fe.renderer,t.Equipment[e]));
          this.k = !0
      }
      a(t) {
          for (let e = 0; e < this.m.length; e++) {
              const i = this.m[e];
              i && i.b && i.a.am(t)
          }
      }
      g(t) {
          for (let e = 0; e < this.m.length; e++) {
              const i = this.m[e];
              i && i.b && (i.a && i.a.D && t.a(i.a, !1))
          }
      }
      l(t, e, i) {
          if (t.b)
              return;
          if (!i.loaded)
              return;
          if (!t.a || !t.a.D)
              return;
          const s = i.modelInstance.P;
          let r = null;
          if (e < 5) {
              if (!s.M[e])
                  return;
              r = s.M[e]
          } else
              r = i.modelInstance.aw(19);
          let n = Bi();
          Vi(n, n, r.a),
          qi(n, n, _i(t.c, t.c, t.c)),
          t.a.az(i.modelInstance, r.d, n),
          t.b = !0
      }
      b() {
          if (this.j.loaded) {
              for (const t of this.f)
                  t && t.f();
              for (let t = 0; t < this.m.length; t++) {
                  const e = this.m[t];
                  e && (this.l(e, t, this.j),
                  e.a.A())
              }
          }
      }
  }
  ;
  class Ol {
      constructor(t, e, i) {
          this.v = t,
          this.y = [],
          this.J = !1,
          this.F = null,
          this.B = [],
          this.r = Bi(),
          WH.debug("Creating item", i),
          this.C = e,
          this.z = i,
          this.j = t.K,
          this.u = t.J,
          this.t = t.M,
          this.h = or[e],
          this.x = hr[e],
          this.a = null,
          this.k = null,
          this.b = null,
          this.s = 0,
          this.n = 0,
          this.J = !1,
          this.D = !1,
          this.I = 0,
          this.l = 3,
          this.e = 0,
          i && this.E()
      }
      K() {
          var t = this;
          if (t.y) {
              for (let e = 0; e < t.y.length; ++e)
                  t.y[e] && (t.y[e].b = null,
                  t.y[e] = null);
              t.y = null
          }
          if (t.a) {
              for (let e = 0; e < t.a.length; ++e)
                  t.a[e].texture && t.a[e].texture.b(),
                  t.a[e].texture = null,
                  t.a[e] = null;
              t.a = null
          }
          if (t.k = null,
          t.b = null,
          t.B) {
              for (let e = 0; e < t.B.length; e++)
                  t.B[e].d();
              t.B = null
          }
          t.J = !1,
          WH.debug("Destroyed item", this.z)
      }
      E() {
          let t = this
            , e = this.v.w.options;
          WH.debug("Loading item", this.z),
          Cl(e.contentPath, this.C, this.z).then((t => {
              this.q(t)
          }
          )).catch(( () => {
              t.D = !0
          }
          ))
      }
      q(t) {
          if (!this.v)
              return void WH.debug("Char model was destroyed before it was loaded", this.z);
          const e = this.v.w
            , i = (e.options,
          this.u)
            , s = this.j
            , r = this.t;
          if (this.n = t.Item.Flags,
          this.s = t.Item.InventoryType,
          this.d = t.Item.ItemClass,
          this.A = t.Item.ItemSubClass,
          t.ComponentTextures) {
              this.a = [];
              for (let n in t.ComponentTextures) {
                  const a = parseInt(n)
                    , o = pl.b(t.TextureFiles[t.ComponentTextures[n]], i, r, s);
                  if (o) {
                      let t;
                      t = {
                          region: a,
                          gender: this.u,
                          file: o.c,
                          texture: null
                      },
                      12 != a ? t.texture = e.getTexture(o.c) : 16 == this.C && this.v.e().L(2, e.getTexture(o.c)),
                      this.a.push(t)
                  }
              }
          }
          this.k = t.Item.GeosetGroup,
          this.b = t.Item.AttachGeosetGroup,
          this.e = t.Item.GeosetGroupOverride,
          1 == this.C && (0 == i ? this.g = t.Item.HideGeosetMale : this.p = t.Item.HideGeosetFemale);
          let n = 0;
          if (3 == this.C ? n = 2 : ur[this.C] != ar.ARMOR && (n = 1),
          n > 0 && t.ComponentModels)
              for (let i = 0; i < n; ++i) {
                  let s = jl.c(e, t, ur[this.C], this.j, this.u, this.t);
                  if (3 == this.C && s.ed(i + 1),
                  null == s.modelInstance)
                      continue;
                  const r = new Ml;
                  r.b = s,
                  r.a = i,
                  t.Item && t.Item.ParticleColor && r.b.modelInstance.k(t.Item.ParticleColor),
                  this.y.push(r)
              }
          if ((6 == this.C || 16 == this.C) && t.ComponentModels) {
              let n = 0;
              if (16 == this.C && (n = 1),
              t.ComponentModels[n]) {
                  const a = t.ComponentModels[n]
                    , o = pl.a(t.ModelFiles[a], -1, i, r, s)
                    , h = new Ml
                    , l = 0 == n ? t.Textures : t.Textures2;
                  h.b = new xl(e,o,l,!1),
                  this.y = [h]
              }
          }
          const a = this.C;
          if ((4 == a || 5 == a || 20 == a || 6 == a || 7 == a || 10 == a || 8 == a || 1 == a || 9 == a || 19 == a || 16 == a) && t.ComponentModels) {
              let n = 0;
              if (1 != a && 6 != a || (n = 1),
              t.ComponentModels[n]) {
                  const a = t.ComponentModels[n];
                  if (a && t.ModelFiles && t.ModelFiles[a]) {
                      const o = pl.a(t.ModelFiles[a], -1, i, r, s);
                      if (o) {
                          const i = 0 == n ? t.Textures : t.Textures2;
                          this.F = new Ml,
                          this.F.b = new xl(e,o,i,!0),
                          this.F.b.d(( () => {
                              this.v.s = !0
                          }
                          ))
                      }
                  }
              }
          }
          7 == a && this.k[2] > 0 && (this.x += 2);
          const o = 0 != this.I ? this.I : 0 != t.Item.ItemVisual ? t.Item.ItemVisual : 0;
          if (0 != o) {
              const t = 2 == this.d ? this.A : -1;
              for (let e = 0; e < this.y.length; e++)
                  this.B.push(new Ul(this.y[e].b,t,o))
          }
          this.J = !0,
          WH.debug("Loaded item:", "DisplayId", this.z, "InventoryType", this.s),
          this.v.s = !0
      }
      G(t) {
          for (let t = 0; t < this.B.length; t++)
              this.B[t].d();
          this.B = [],
          this.I = t
      }
      f(t) {
          this.l = t
      }
      H(t) {
          if (3 == this.C) {
              const e = t.b.shoulderIndex;
              if (1 == e && !(1 & this.l))
                  return !0;
              if (2 == e && !(2 & this.l))
                  return !0
          }
          return !1
      }
      o(t) {
          for (let e = 0; e < this.B.length; ++e)
              this.B[e] && this.B[e].a(t);
          for (let e = 0; e < this.y.length; ++e) {
              const i = this.y[e];
              if (i && i.b) {
                  if (this.H(i))
                      continue;
                  i.b.g(t)
              }
          }
      }
      c() {
          if (this.y)
              for (let t = 0; t < this.y.length; ++t)
                  this.y[t].c = !1,
                  this.y[t].b && this.y[t].b.ba(null, -1, null);
          this.F && (this.F.c = !1)
      }
      w(t, e, i) {
          if (!t)
              return;
          if (!t.b)
              return;
          if (!t.b.modelInstance.D)
              return;
          const s = t.a;
          if (s < i.length) {
              let r = e.M[i[s]];
              if (t.c && r.d == t.d)
                  return;
              let n = !1
                , a = sr[t.b.fileDataId]
                , o = gi()
                , h = Bi();
              if (Gi(h),
              a && (mi(o, 1, 1, -1),
              qi(h, h, o),
              n = !0),
              (22 == this.C || 23 == this.C || 22 == this.h) && 256 & this.n && (mi(o, 1, -1, 1),
              qi(h, h, o),
              n = !0,
              t.b.isMirrored = !0),
              13 == this.C && 1024 & this.n && (mi(o, 1, -1, 1),
              qi(h, h, o),
              n = !0,
              t.b.isMirrored = !0),
              t.b.winding = n,
              5 == this.v.x && 26 == this.C && 2 == this.d && 18 == this.A && (Gi(h),
              Xi(h, h, -Math.PI / 2)),
              Vi(h, h, r.a),
              Hi(h, h, this.r),
              27 == this.C) {
                  let e = t.b.i.Scale;
                  mi(o, e, e, e),
                  qi(h, h, o)
              }
              t.b.ba(this.v.e(), r.d, h),
              t.c = !0,
              t.d = r.d
          }
          t.c = !0
      }
      L(t) {
          zi(this.r, t);
          for (let t = 0; t < this.y.length; ++t)
              this.y[t].c = !1
      }
      m() {
          if (!this.v.loaded)
              return;
          const t = this.v.e().P
            , e = this.v.N(this.h, this);
          for (let i = 0; i < this.y.length; ++i)
              this.w(this.y[i], t, e),
              this.B[i] && this.B[i].b();
          this.F && this.v.ih(this.F);
          for (let t = 0; t < this.y.length; ++t) {
              const e = this.y[t];
              if (e && e.b) {
                  if (this.H(e))
                      continue;
                  e.b.a()
              }
          }
      }
      i(t) {
          this.y.forEach((e => {
              e.b.b(t)
          }
          )),
          this.F && this.F.b.b(t)
      }
  }
  class Pl extends yl {
      constructor(t, e) {
          super(t, e),
          this.F = new Map,
          this.wv = [],
          this.kj = {},
          this.ml = null,
          t.options.charCustomization && (this.CB = t.options.charCustomization),
          this.yx = new Array(52);
          for (let t = 0; t < 52; t++)
              this.yx[t] = 100 * t + rr[t]
      }
      get overrideModelFile() {
          return this.ut
      }
      set overrideModelFile(t) {
          const e = this.ut;
          this.ut = t,
          e != t && (this.H(),
          this.cba(),
          this.s = !0)
      }
      H() {
          let t = this.ut ? this.ut : this.on.Model;
          this.h = new _l(this.w,this.w.renderer,t),
          this.h.ax(),
          this.h.r(27 == this.K || 30 == this.K),
          this.ml = null,
          this.s = !0
      }
      hg(t) {
          const e = this.w.options;
          this.K = t.Character.Race,
          this.J = t.Character.Gender,
          this.M = e.cls ? e.cls : 0;
          const i = e && e.items;
          El(e.contentPath, ar.CHARACTER, t.Character.ChrModelId).then((s => {
              var r, n;
              this.on = s,
              this.H(),
              (r = e.contentPath,
              n = t.Character.ChrModelId,
              new Promise(( (t, e) => {
                  const i = r + "meta/charactercustomization/" + n + ".json";
                  $.getJSON(i, (function(e) {
                      t(e)
                  }
                  ))
              }
              ))).then((e => {
                  var s, r;
                  if (WH.debug("Got customization data v2", e),
                  this.D = new Il(this,e),
                  null === (s = this.P) || void 0 === s || s.call(this, this.D.e),
                  this.D.f(),
                  this.CB)
                      this.setAppearance(this.CB);
                  else if (t.Character.Race > 0 && (null === (r = null == t ? void 0 : t.Creature) || void 0 === r ? void 0 : r.CreatureCustomizations)) {
                      let e = this.D.d(t.Creature.CreatureCustomizations);
                      this.setAppearance(e)
                  } else
                      this.D.c();
                  this.r && this.v(),
                  t.Equipment && this.Az(t.Equipment),
                  i && this.Az(i)
              }
              ))
          }
          )),
          this.r = !0
      }
      cba() {
          for (const [t,e] of this.F)
              e.c();
          for (const t in this.kj) {
              this.kj[t].c = !1
          }
          for (const t of this.k)
              t.n()
      }
      I(t, e, i) {
          if (!this.F)
              return;
          if (3 == t && this.wv && this.wv[0])
              return;
          let s = new Ol(this,t,e);
          i && s.G(i);
          let r = s.h
            , n = lr[t];
          this.F.get(r) && 0 != n ? (s.h = n,
          this.F.set(n, s)) : this.F.set(r, s)
      }
      ed(t) {
          var e = this.F.get(t);
          e || (t = or[t],
          e = this.F.get(t)),
          e && (this.F.delete(t),
          e.K())
      }
      N(t, e) {
          const i = this.h.P
            , s = []
            , r = {
              14: t => [0],
              26: t => 2 == t.d && 18 == t.A ? [1] : null
          };
          if (i.M && i.y) {
              const n = {
                  1: t => [11],
                  3: t => [6, 5],
                  22: t => {
                      var e;
                      return (null === (e = r[t.C]) || void 0 === e ? void 0 : e.call(r, t)) || [2]
                  }
                  ,
                  21: t => [1],
                  17: t => [1],
                  15: t => [2],
                  25: t => [1],
                  13: t => [1],
                  14: t => [0],
                  23: t => [2],
                  6: t => [53],
                  26: t => [1],
                  16: t => [57],
                  27: t => [55]
              };
              if (n[t]) {
                  const r = n[t](e);
                  for (let n = 0; n < r.length; ++n) {
                      let a = r[n];
                      (this.x >= 0 || this.C >= 0 || this.n) && gr[t] && (a = gr[t]),
                      this.x >= 0 && 21 == t && br[this.x][t] && (a = br[this.x][t]),
                      this.C >= 0 && 22 == t && br[this.C][t] && (a = br[this.C][t]),
                      15 == e.s && this.C >= 0 && 22 == t && br[this.C][e.C] && (a = br[this.C][e.C]),
                      a >= i.y.length || -1 == i.y[a] || s.push(i.y[a])
                  }
              }
          }
          return s
      }
      Az(t) {
          if ($.isArray(t))
              for (let e = 0; e < t.length; ++e)
                  this.I(t[e][0], t[e][1], t[e][2]);
          else
              for (let e in t)
                  this.I(parseInt(e), t[e]);
          this.s = !0,
          this.G()
      }
      sr(t, e, i) {
          for (const s in this.kj) {
              this.kj[s].b.l(t, e, i)
          }
      }
      m() {
          var t;
          const e = this.h;
          for (let t = 0; t < 52; t++)
              this.yx[t] = 100 * t + rr[t];
          for (const e of (null === (t = this.D) || void 0 === t ? void 0 : t.h) || [])
              e >= 0 && (this.yx[Math.floor(e / 100)] = e);
          for (const t in this.kj) {
              const e = this.kj[t].ba
                , i = this.kj[t].b;
              i.l(0, _r, !1);
              for (const t of e)
                  i.l(t.b, t.b, !0),
                  this.yx[Math.floor(t.b / 100)] = t.b
          }
          e.t(0, _r, !1),
          e.t(0, 0, !0);
          for (let t = 0; t < this.yx.length; t++)
              e.t(this.yx[t], this.yx[t], !0);
          let i = this.F.get(1)
            , s = this.F.get(3)
            , r = this.F.get(4)
            , n = this.F.get(5)
            , a = this.F.get(6)
            , o = this.F.get(7)
            , h = this.F.get(8)
            , l = this.F.get(9)
            , u = this.F.get(10)
            , c = this.F.get(19)
            , d = this.F.get(16)
            , f = !1
            , g = !1;
          n && n.k && n.k[2] ? g = !0 : o && o.k && o.k[2] && (f = !0);
          let b = g || f;
          this.F.forEach((t => {
              if (t && t.J && t.F) {
                  let e = t.F.b.modelInstance;
                  if (!e.D)
                      return;
                  e.t(0, _r, !1),
                  1 == t.C ? (e.aJ(t.k[0], 2700),
                  e.aJ(t.k[1], 2100)) : 3 == t.C ? e.aJ(t.k[0], 2600) : 4 == t.C ? (e.aJ(t.k[0], 800),
                  e.aJ(t.k[1], 1e3)) : 5 == t.C || 20 == t.C ? (u && u.J && u.k[0] ? e.aJ(-2, 800) : e.aJ(t.k[0], 800),
                  e.aJ(t.k[1], 1e3),
                  b && e.aJ(t.k[2], 1300),
                  e.aJ(t.k[3], 2200),
                  e.aJ(t.k[4], 2800)) : 6 == t.C ? e.aJ(t.k[0], 1800) : 7 == t.C ? (e.aJ(t.k[0], 1100),
                  e.aJ(t.k[1], 900),
                  b && e.aJ(t.k[2], 1300)) : 8 == t.C ? (e.aJ(t.k[0], 500),
                  e.aJ(t.k[1], 2e3)) : 10 == t.C ? (0 == t.k[0] && n && n.J && n.k[0] ? e.aJ(-2, 400) : e.aJ(t.k[0], 400),
                  e.aJ(t.k[1], 2300)) : 16 == t.C ? e.aJ(t.k[0], 1500) : 19 == t.C ? e.aJ(t.k[0], 1200) : 9 == t.C && (u && u.J && u.k[0] || null != (null == u ? void 0 : u.F) || n && n.J && n.k[2] && n.k[0] > 0 ? e.aJ(-2, 2300) : e.aJ(t.k[0], 2300))
              }
          }
          )),
          this.wv.forEach((t => {
              if (t && t.F) {
                  const e = t.F.b.modelInstance;
                  e.t(0, _r, !1),
                  e.aJ(t.k[0], 2600)
              }
          }
          )),
          this.F.forEach((t => {
              if (t && t.J && t.y)
                  for (let e of t.y) {
                      if (!e)
                          continue;
                      let i = e.b;
                      1 == t.C ? (i.k(t.b[0], 27),
                      i.k(t.b[1], 21)) : 3 == t.C ? i.k(t.b[0], 26) : 4 == t.C ? (i.k(t.b[0], 8),
                      i.k(t.b[1], 10)) : 5 == t.C || 20 == t.C ? (i.k(t.b[0], 8),
                      i.k(t.b[1], 10),
                      i.k(t.b[2], 13),
                      i.k(t.b[3], 22),
                      i.k(t.b[4], 28)) : 6 == t.C ? i.k(t.b[0], 18) : 7 == t.C ? (i.k(t.b[0], 11),
                      i.k(t.b[1], 9),
                      i.k(t.b[2], 13)) : 8 == t.C ? (i.k(t.b[0], 5),
                      i.k(t.b[1], 20)) : 10 == t.C ? (i.k(t.b[0], 4),
                      i.k(t.b[1], 23)) : 16 == t.C ? i.k(t.b[0], 15) : 19 == t.C ? i.k(t.b[0], 12) : 9 == t.C && i.k(t.b[0], 23)
                  }
          }
          )),
          this.wv.forEach((t => {
              if (t && t.y)
                  for (let e of t.y) {
                      let i = e.b;
                      i.k(t.b[0], 26),
                      t.e > 0 && (i.l(2600, 2699, !1),
                      i.k(t.e, 26))
                  }
          }
          ));
          if (i && i.J) {
              const t = i.F || i.y[0]
                , s = this.K
                , r = 0 == this.J ? i.g : i.p;
              if (t && r)
                  for (let t = 0; t < r.length; t++)
                      if (r[t].RaceId == s) {
                          const i = r[t].GeosetGroup;
                          if (5 == s && (1 == i || 2 == i))
                              continue;
                          if (i < 52)
                              if (0 == i)
                                  e.t(1, 99, !1);
                              else {
                                  const t = 100 * i;
                                  e.t(t, t + 99, !1)
                              }
                      }
          }
          if (i && i.y && i.e > 0)
              for (let t of i.y) {
                  let e = t.b;
                  e.l(2600, 2799, !1),
                  e.k(i.e, 27)
              }
          if (s && s.y && s.e > 0)
              for (let t of s.y) {
                  let e = t.b;
                  e.l(2600, 2699, !1),
                  e.k(s.e, 26)
              }
          if (a && a.y && a.e > 0)
              for (let t of a.y) {
                  let e = t.b;
                  e.l(1800, 1899, !1),
                  e.k(a.e, 18)
              }
          let _ = 0;
          if (c && (_ |= 16),
          u && u.J && u.k && u.k[0]) {
              let t = 401 + u.k[0];
              e.t(401, 499, !1),
              e.t(t, t, !0)
          } else if (n && n.J && n.k && n.k[0]) {
              let t = 801 + n.k[0];
              e.t(t, t, !0),
              u && u.k && 0 == u.k[0] && (u.x = 7,
              n.x = 8,
              WH.debug("updating sorting for chest/gloves"))
          }
          if (!(n || a || l) && r && r.J && r.k && r.k[0]) {
              let t = 801 + r.k[0];
              e.t(t, t, !0)
          }
          if (c && c.J)
              1048576 & c.n || (e.t(2200, 2299, !1),
              e.t(2202, 2202, !0));
          else if (n && n.J && n.k && n.k[3]) {
              let t = 2201 + n.k[3];
              e.t(2200, 2299, !1),
              e.t(t, t, !0)
          }
          let p, m = !1;
          if (a && a.J && a.k && a.k[0] && (m = !!(512 & a.n)),
          g) {
              e.t(501, 599, !1),
              e.t(902, 999, !1),
              e.t(1100, 1199, !1),
              e.t(1300, 1399, !1);
              let t = 1301 + n.k[2];
              e.t(t, t, !0)
          } else if (f) {
              e.t(501, 599, !1),
              e.t(902, 999, !1),
              e.t(1100, 1199, !1),
              e.t(1300, 1399, !1);
              let t = 1301 + o.k[2];
              e.t(t, t, !0)
          } else if (h && h.J && h.k && h.k[0]) {
              e.t(501, 599, !1),
              e.t(901, 901, !0);
              let t = 501 + h.k[0];
              e.t(t, t, !0)
          } else {
              let t;
              t = o && o.J && o.k && o.k[1] ? 901 + o.k[1] : 901,
              e.t(t, t, !0)
          }
          p = h && h.J && h.k && h.k[1] ? 2e3 + h.k[1] : !h || !h.J || 1048576 & h.n ? 2001 : 2002,
          e.t(2001, 2099, !1),
          e.t(p, p, !0);
          let v = !1;
          if (!b && c && c.J && c.k && c.k[0]) {
              let t;
              v = !1,
              m ? (v = !0,
              t = 1203) : (v = !0,
              t = 1201 + c.k[0]),
              e.t(t, t, !0)
          } else
              16 & _ && (e.t(1201, 1201, !0),
              b || (e.t(1202, 1202, !0),
              v = !0));
          if (!v && !g)
              if (n && n.J && n.k && n.k[1]) {
                  let t = 1001 + n.k[1];
                  e.t(t, t, !0)
              } else if (r && r.J && r.k && r.k[1]) {
                  let t = 1001 + r.k[1];
                  e.t(t, t, !0)
              }
          if (!g && o && o.J && o.k && o.k[0]) {
              let t = o.k[0]
                , i = 1101 + t
                , s = e.ae.some((t => t.meshId == i));
              t > 2 ? (e.t(1300, 1399, !1),
              s ? e.t(i, i, !0) : e.t(1301, 1301, !0)) : v || e.t(i, i, !0)
          }
          if (c && c.J && c.k && c.k[0] && this.B.length > 0)
              for (let t of this.B) {
                  const i = nr[t];
                  if (i && 12 == i.GeosetType && i.Original == c.k[0] + 1) {
                      e.t(1200, 1299, !1);
                      let t = 1200 + i.Override;
                      e.t(t, t, !0);
                      break
                  }
              }
          if (d && d.J && d.k && d.k[0]) {
              e.t(1500, 1599, !1);
              let t = 1501 + d.k[0];
              if (this.B.length > 0)
                  for (let e of this.B) {
                      const i = nr[e];
                      if (i && 15 == i.GeosetType && i.Original == d.k[0] + 1) {
                          t = 1500 + i.Override;
                          break
                      }
                  }
              e.t(t, t, !0)
          }
          if (a && a.J && a.k && a.k[0]) {
              e.t(1800, 1899, !1);
              let t = 1801 + a.k[0];
              e.t(t, t, !0)
          }
          o || g || f || v || m ? e.t(1400, 1499, !1) : e.t(1401, 1401, !0)
      }
      setParticlesEnabled(t) {
          super.setParticlesEnabled(t),
          this.F.forEach((e => {
              if (e.y)
                  for (let i = 0; i < e.y.length; ++i)
                      e.y[i] && e.y[i].b.setParticlesEnabled(t)
          }
          ))
      }
      v() {}
      gf() {
          if (!this.r)
              return;
          let t = !1;
          if (this.F.forEach((e => {
              if (e.J || e.D) {
                  if (e.a)
                      for (let i = 0; i < e.a.length; ++i)
                          if (e.a[i].texture && !e.a[i].texture.c())
                              return void (t = !0)
              } else
                  t = !0
          }
          )),
          t)
              return;
          if (!this.D)
              return;
          const e = this.D.e.Materials
            , i = this.D.e.TextureLayers
            , s = this.D.e.TextureSections;
          let r = !0
            , n = !0;
          15 != this.K && 21 != this.K || (n = !1),
          this.F.forEach((t => {
              let e = t.h;
              4 != e && 5 != e && 19 != e || (r = !1,
              null == t.a && (r = !0)),
              7 == e && (n = !1,
              null == t.a && (n = !0))
          }
          ));
          let a = -1;
          if (27 == this.K)
              for (let t of i)
                  9 == t.BlendMode && 1 == t.TextureType && t.Layer > a && (a = t.Layer);
          const o = (h = t => t.TextureType,
          i.reduce(( (t, e) => {
              var i;
              return (t[i = h(e)] || (t[i] = [])).push(e),
              t
          }
          ), {}));
          var h;
          for (const t in o) {
              const e = o[t];
              for (const t of e) {
                  const e = this.D.a[t.ChrModelTextureTargetID];
                  if (e && !e.c())
                      return
              }
          }
          for (const t in o) {
              const i = o[t]
                , h = i[0].TextureType;
              if (!this.q[t]) {
                  const i = e.find((t => t.TextureType == h));
                  if (!i) {
                      WH.debug("unable to find material info", h);
                      continue
                  }
                  this.q[t] = new Tr(this.w.context,i.Width,i.Height)
              }
              const l = this.q[t];
              l.k();
              for (const t of i) {
                  let e = -1;
                  t.Layer == a && (e = 0);
                  const i = this.D.a[t.ChrModelTextureTargetID];
                  if (!i)
                      continue;
                  const o = t.TextureSection;
                  if (3 != o && 5 != o || r && 3 == o || n && 5 == o) {
                      let r = 0
                        , n = 0
                        , a = 1
                        , h = 1;
                      if (-1 != o && s) {
                          const t = s.find((t => t.SectionType == o));
                          if (!t) {
                              WH.debug("can't find texture section data", o);
                              continue
                          }
                          r = t.X,
                          n = t.Y,
                          a = t.Width,
                          h = t.Height
                      }
                      l.c(i, r, n, a, h, t.BlendMode, t.Layer, e)
                  }
              }
              1 == h && 52 != this.K && 70 != this.K && this.E(l),
              26 != h || 52 != this.K && 70 != this.K || this.E(l),
              l.l()
          }
          this.O(this.h);
          for (let t in this.kj) {
              const e = this.kj[t];
              e.b && e.b.loaded && this.O(e.b.e())
          }
          this.r = !1
      }
      O(t) {
          if (this.q[1]) {
              const e = this.q[1];
              t.d(e.n(0), e.n(1), e.n(2))
          }
          for (let e in this.q) {
              this.q[e];
              t.L(e, this.q[e].n(0))
          }
      }
      E(t) {
          const e = [];
          this.F.forEach((t => {
              e.push(t)
          }
          )),
          e.sort((function(t, e) {
              return t.x - e.x
          }
          ));
          const i = this.D.e.TextureSections;
          for (let s = 0; s < e.length; s++) {
              const r = e[s];
              if (r.a)
                  for (let e = 0; e < r.a.length; e++) {
                      const s = r.a[e];
                      if (s.gender == this.J && s.texture && s.texture.c() && 12 != s.region) {
                          if (1 & this.o.Character.ChrModelFlags && 7 == s.region)
                              continue;
                          const e = i.find((t => t.SectionType == s.region));
                          if (!e) {
                              WH.debug("can't find texture section data", s.region);
                              continue
                          }
                          const r = new mr;
                          r.b = s.texture,
                          t.c(r, e.X, e.Y, e.Width, e.Height, 0, -1, -1)
                      }
                  }
          }
      }
      setAppearance(t) {
          var e;
          this.CB = t,
          this.x = t.sheathMain,
          this.C = t.sheathOff,
          null === (e = this.D) || void 0 === e || e.b(t.options),
          this.r = !0,
          this.s = !0,
          this.v(),
          this.G()
      }
      setCustomizationsLoadedCallback(t) {
          this.P = t
      }
      setItems(t) {
          const e = this.w.options;
          WH.debug("setItems", t);
          const i = [];
          for (let e = 0; e < t.length; e++)
              i.push([t[e].slot, t[e].display, t[e].visual]);
          i.forEach((t => {
              const i = [parseInt(t[0]), parseInt(t[1])];
              e.items.push(i)
          }
          )),
          this.Az(i),
          this.r = !0
      }
      attachList(t) {
          const e = this.w.options;
          WH.debug("attachList", t);
          const i = t.split(",")
            , s = [];
          for (let t = 0; t < i.length; t += 2)
              s.push([i[t], i[t + 1]]);
          s.forEach((t => {
              const i = [parseInt(t[0]), parseInt(t[1])];
              e.items.push(i)
          }
          )),
          this.Az(s),
          this.r = !0
      }
      clearSlots(t) {
          const e = this.w.options;
          WH.debug("clearSlots", t);
          const i = t.split(",");
          for (let t = 0; t < i.length; ++t) {
              this.ed(parseInt(i[t]));
              const s = [];
              e.items.forEach((i => {
                  0 != e.items[t].indexOf(parseInt(i)) && s.push(i)
              }
              )),
              e.items = s
          }
          this.G(),
          this.r = !0
      }
      setShouldersOverride(t) {
          if (WH.debug("setShouldersOverride", t),
          !t || 2 != t.length)
              return;
          for (let t = 0; t < 2; t++) {
              const e = this.wv[t];
              e && e.K(),
              this.wv[t] = null
          }
          for (let e = 0; e < 2; e++)
              if (null != t[e]) {
                  const i = new Ol(this,3,t[e]);
                  let s = 0;
                  s = 0 == e ? 1 : 2,
                  i.f(s),
                  this.wv[e] = i
              }
          const e = this.F.get(3);
          if (e) {
              let t = 3;
              for (let e = 0; e < 2; e++)
                  this.wv[e] && (t &= ~(1 << e));
              e.f(t)
          }
          this.wv && (this.wv[0] || this.wv[1]) && this.ed(3)
      }
      setSheath(t, e) {
          this.x = t,
          this.C = e,
          this.G()
      }
      G() {
          if (!this.loaded)
              return;
          const t = this.h;
          let e = (-1 == this.C || !this.C) && null != this.F.get(22)
            , i = !(-1 != this.x && this.x || null == this.F.get(13) && null == this.F.get(21));
          for (let i of cr) {
              let s = t.P.q[i];
              s > 0 && s < t.K.length && this.h.K[s].p(e ? "HandsClosed" : "")
          }
          for (let e of dr) {
              let s = t.P.q[e];
              s > 0 && s < t.K.length && t.K[s].p(i ? "HandsClosed" : "")
          }
      }
      ih(t) {
          const e = this.h;
          if (!e.D)
              return;
          const i = t.b.modelInstance;
          if (!i || !i.D)
              return;
          t.c || (i.az(e, -1, null),
          t.c = !0);
          let s = i.K;
          if (s) {
              for (let t = 0; t < s.length; t++) {
                  let i = s[t]
                    , r = this.ml[i.q.b];
                  if ("number" != typeof r)
                      continue;
                  let n = s[t].i
                    , a = e.K[r].i;
                  s[t].a = !0,
                  zi(n, a)
              }
              i.A()
          }
      }
      L() {
          const t = this.h;
          let e = {};
          for (let i = 0; i < t.K.length; i++)
              e[t.K[i].q.b] = i;
          this.ml = e
      }
      a() {
          if (this.h && this.h.D) {
              this.ml || (this.L(),
              this.G()),
              super.a();
              for (const t in this.kj) {
                  const e = this.kj[t];
                  this.ih(e)
              }
              this.F.forEach((t => {
                  if (t) {
                      if (2 == t.d && 13 == t.A) {
                          if (21 == t.h && -1 != this.x)
                              return;
                          if (22 == t.h && -1 != this.C)
                              return
                      }
                      t.m()
                  }
              }
              )),
              this.wv.forEach((t => {
                  t && t.y && t.m()
              }
              )),
              this.gf()
          }
      }
      static qp(t, e) {
          const i = t.b;
          if (!i.loaded)
              return;
          const s = i.modelInstance;
          if (!s || !s.D)
              return;
          s.K && s.am(e)
      }
      g(t) {
          if (this.h && this.h.D) {
              super.g(t);
              for (const e in this.kj) {
                  const i = this.kj[e];
                  Pl.qp(i, t)
              }
              if (this.F.forEach((e => {
                  if (e) {
                      if (2 == e.d && 13 == e.A) {
                          if (21 == e.h && -1 != this.x)
                              return;
                          if (22 == e.h && -1 != this.C)
                              return
                      }
                      e.o(t)
                  }
              }
              )),
              this.wv.forEach((e => {
                  e && e.y && e.o(t)
              }
              )),
              this.p)
                  for (let e = 0; e < this.p.length; e++) {
                      let i = this.p[e];
                      i.D && i.am(t)
                  }
              this.F.forEach((e => {
                  e && e.F && e.F.b && e.F.c && Pl.qp(e.F, t)
              }
              ))
          }
      }
      b(t) {
          super.b(t);
          for (const e in this.kj) {
              const i = this.kj[e];
              i.c && (i.b && i.b.loaded && i.b.b(t))
          }
          if (this.F.forEach((e => {
              if (e) {
                  if (2 == e.d && 13 == e.A) {
                      if (21 == e.h && -1 != this.x)
                          return;
                      if (22 == e.h && -1 != this.C)
                          return
                  }
                  e.i(t)
              }
          }
          )),
          this.wv.forEach((e => {
              e && e.y && e.i(t)
          }
          )),
          this.p)
              for (let e = 0; e < this.p.length; e++) {
                  let i = this.p[e];
                  i.D && t.a(i, !1)
              }
      }
  }
  class Bl extends vl {
      constructor(t, e, i, s, r, n) {
          super(t, e, i, s, r, n),
          this.cba()
      }
      cba() {
          let t = this.hg;
          const e = this.m
            , i = this.dc
            , s = this.i;
          if (s.ComponentModels) {
              let r = s.ComponentModels[0] || s.ComponentModels[1];
              r && s.ModelFiles && s.ModelFiles[r] && (27 == s.Item.InventoryType ? this.h = new _l(this.fe,this.fe.renderer,s.ModelFiles[r][0].FileDataId) : this.h = new _l(this.fe,this.fe.renderer,pl.a(s.ModelFiles[r], -1, e, i, t)),
              this.h.ax()),
              this.h && s.Item.AttachGeosetGroup && (this.h.c(s.Item.AttachGeosetGroup[0], 27),
              this.h.c(s.Item.AttachGeosetGroup[1], 21))
          }
          if (s.Textures)
              for (let t in s.Textures)
                  0 != s.Textures[t] && this.h.L(parseInt(t), this.fe.getTexture(s.Textures[t]))
      }
  }
  class zl extends vl {
      constructor(t, e, i, s, r, n) {
          super(t, e, i, s, r, n),
          this.cba = 0,
          this.gf()
      }
      get shoulderIndex() {
          return this.cba
      }
      ed(t) {
          this.cba != t && (this.cba = t,
          this.gf())
      }
      gf() {
          this.h = null;
          let t = this.hg;
          const e = this.m
            , i = this.dc
            , s = this.i;
          if (s.ComponentModels) {
              let r = s.ComponentModels[0]
                , n = s.ComponentModels[1];
              if (!r || 1 != this.cba && 0 != this.cba) {
                  if (n && (2 == this.cba || 0 == this.cba) && (n && s.ModelFiles[n] && (this.h = new _l(this.fe,this.fe.renderer,pl.a(s.ModelFiles[n], 1, e, i, t)),
                  this.h.ax()),
                  s.Textures2 && this.h))
                      for (let t in s.Textures2)
                          0 != s.Textures2[t] && this.h.L(+t, this.fe.getTexture(s.Textures2[t]))
              } else if (r && s.ModelFiles[r] && (this.h = new _l(this.fe,this.fe.renderer,pl.a(s.ModelFiles[r], 0, e, i, t)),
              this.h.ax()),
              this.h && s.Textures)
                  for (let t in s.Textures)
                      0 != s.Textures[t] && this.h.L(+t, this.fe.getTexture(s.Textures[t]))
          }
          this.h && s.Item.AttachGeosetGroup && this.h.c(s.Item.AttachGeosetGroup[0], 26)
      }
      a() {
          this.h.A()
      }
      g(t) {
          this.h.am(t)
      }
  }
  class Nl extends vl {
      constructor(t, e, i, s, r, n) {
          super(t, e, i, s, r, n),
          this.cba()
      }
      cba() {
          let t = this.hg;
          const e = this.m
            , i = this.dc
            , s = this.i;
          if (s.ComponentModels) {
              let r = s.ComponentModels[0];
              r && s.ModelFiles && s.ModelFiles[r] && (this.h = new _l(this.fe,this.fe.renderer,pl.a(s.ModelFiles[r], -1, e, i, t)))
          }
          if (this.h && s.Textures)
              for (let t in s.Textures)
                  0 != s.Textures[t] && (this.h.ag[+t] = this.fe.getTexture(s.Textures[t]))
      }
  }

  class jl {
      static b(t, e, i) {
          if (e.Character || i == ar.CHARACTER)
              return new Pl(t,e);
          if (i == ar.NPC || i == ar.HUMANOIDNPC)
              return new yl(t,e);
          if (i == ar.HELM || i == ar.SHOULDER || i == ar.ITEM) {
              const s = jl.c(t, e, i, 1, 0, 0);
              return s.j(),
              s
          }
          if (i == ar.OBJECT)
              return new Gl(t,e);
          throw "Couldn't create actor"
      }
      static c(t, e, i, s, r, n) {
          if (i == ar.HELM)
              return new Bl(t,e,s,r,n,!1);
          if (i == ar.SHOULDER)
              return new zl(t,e,s,r,n,!1);
          if (i == ar.ITEM)
              return new Nl(t,e,s,r,n,!1);
          throw "Couldn't create item actor"
      }
      static a(t, e, i) {
          return e == ar.PATH ? new Promise(( (e, s) => {
              e(new xl(t,i,{},!1))
          }
          )) : El(t.options.contentPath, e, i).then((i => jl.b(t, i, e)))
      }
  }

  ;
  let Hl = {
      Types: ar
  };
  const Vl = Object.assign(es, {
      Tools: ci,
      WebGL: Ll,
      WEBGL: 1,
      WOW: 2,
      FLASH: 2,
      Wow: Hl
  });
  window.ZamModelViewer = Vl
}
)();
//# sourceMappingURL=viewer.min.js.map
